{"ast":null,"code":"/**\n* Muuri v0.9.5\n* https://muuri.dev/\n* Copyright (c) 2015-present, Haltu Oy\n* Released under the MIT license\n* https://github.com/haltu/muuri/blob/master/LICENSE.md\n* @license MIT\n*\n* Muuri Packer\n* Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri Ticker / Muuri Emitter / Muuri Dragger\n* Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri AutoScroller\n* Copyright (c) 2019-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*/\n\nvar GRID_INSTANCES = {};\nvar ITEM_ELEMENT_MAP = typeof Map === 'function' ? new Map() : null;\nvar ACTION_SWAP = 'swap';\nvar ACTION_MOVE = 'move';\nvar EVENT_SYNCHRONIZE = 'synchronize';\nvar EVENT_LAYOUT_START = 'layoutStart';\nvar EVENT_LAYOUT_END = 'layoutEnd';\nvar EVENT_LAYOUT_ABORT = 'layoutAbort';\nvar EVENT_ADD = 'add';\nvar EVENT_REMOVE = 'remove';\nvar EVENT_SHOW_START = 'showStart';\nvar EVENT_SHOW_END = 'showEnd';\nvar EVENT_HIDE_START = 'hideStart';\nvar EVENT_HIDE_END = 'hideEnd';\nvar EVENT_FILTER = 'filter';\nvar EVENT_SORT = 'sort';\nvar EVENT_MOVE = 'move';\nvar EVENT_SEND = 'send';\nvar EVENT_BEFORE_SEND = 'beforeSend';\nvar EVENT_RECEIVE = 'receive';\nvar EVENT_BEFORE_RECEIVE = 'beforeReceive';\nvar EVENT_DRAG_INIT = 'dragInit';\nvar EVENT_DRAG_START = 'dragStart';\nvar EVENT_DRAG_MOVE = 'dragMove';\nvar EVENT_DRAG_SCROLL = 'dragScroll';\nvar EVENT_DRAG_END = 'dragEnd';\nvar EVENT_DRAG_RELEASE_START = 'dragReleaseStart';\nvar EVENT_DRAG_RELEASE_END = 'dragReleaseEnd';\nvar EVENT_DESTROY = 'destroy';\nvar HAS_TOUCH_EVENTS = ('ontouchstart' in window);\nvar HAS_POINTER_EVENTS = !!window.PointerEvent;\nvar HAS_MS_POINTER_EVENTS = !!window.navigator.msPointerEnabled;\nvar MAX_SAFE_FLOAT32_INTEGER = 16777216;\n\n/**\n * Event emitter constructor.\n *\n * @class\n */\nfunction Emitter() {\n  this._events = {};\n  this._queue = [];\n  this._counter = 0;\n  this._clearOnEmit = false;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\nEmitter.prototype.on = function (event, listener) {\n  if (!this._events || !event || !listener) return this;\n\n  // Get listeners queue and create it if it does not exist.\n  var listeners = this._events[event];\n  if (!listeners) listeners = this._events[event] = [];\n\n  // Add the listener to the queue.\n  listeners.push(listener);\n  return this;\n};\n\n/**\n * Unbind all event listeners that match the provided listener function.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\nEmitter.prototype.off = function (event, listener) {\n  if (!this._events || !event || !listener) return this;\n\n  // Get listeners and return immediately if none is found.\n  var listeners = this._events[event];\n  if (!listeners || !listeners.length) return this;\n\n  // Remove all matching listeners.\n  var index;\n  while ((index = listeners.indexOf(listener)) !== -1) {\n    listeners.splice(index, 1);\n  }\n  return this;\n};\n\n/**\n * Unbind all listeners of the provided event.\n *\n * @public\n * @param {String} event\n * @returns {Emitter}\n */\nEmitter.prototype.clear = function (event) {\n  if (!this._events || !event) return this;\n  var listeners = this._events[event];\n  if (listeners) {\n    listeners.length = 0;\n    delete this._events[event];\n  }\n  return this;\n};\n\n/**\n * Emit all listeners in a specified event with the provided arguments.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\nEmitter.prototype.emit = function (event) {\n  if (!this._events || !event) {\n    this._clearOnEmit = false;\n    return this;\n  }\n\n  // Get event listeners and quit early if there's no listeners.\n  var listeners = this._events[event];\n  if (!listeners || !listeners.length) {\n    this._clearOnEmit = false;\n    return this;\n  }\n  var queue = this._queue;\n  var startIndex = queue.length;\n  var argsLength = arguments.length - 1;\n  var args;\n\n  // If we have more than 3 arguments let's put the arguments in an array and\n  // apply it to the listeners.\n  if (argsLength > 3) {\n    args = [];\n    args.push.apply(args, arguments);\n    args.shift();\n  }\n\n  // Add the current listeners to the callback queue before we process them.\n  // This is necessary to guarantee that all of the listeners are called in\n  // correct order even if new event listeners are removed/added during\n  // processing and/or events are emitted during processing.\n  queue.push.apply(queue, listeners);\n\n  // Reset the event's listeners if need be.\n  if (this._clearOnEmit) {\n    listeners.length = 0;\n    this._clearOnEmit = false;\n  }\n\n  // Increment queue counter. This is needed for the scenarios where emit is\n  // triggered while the queue is already processing. We need to keep track of\n  // how many \"queue processors\" there are active so that we can safely reset\n  // the queue in the end when the last queue processor is finished.\n  ++this._counter;\n\n  // Process the queue (the specific part of it for this emit).\n  var i = startIndex;\n  var endIndex = queue.length;\n  for (; i < endIndex; i++) {\n    // prettier-ignore\n    argsLength === 0 ? queue[i]() : argsLength === 1 ? queue[i](arguments[1]) : argsLength === 2 ? queue[i](arguments[1], arguments[2]) : argsLength === 3 ? queue[i](arguments[1], arguments[2], arguments[3]) : queue[i].apply(null, args);\n\n    // Stop processing if the emitter is destroyed.\n    if (!this._events) return this;\n  }\n\n  // Decrement queue process counter.\n  --this._counter;\n\n  // Reset the queue if there are no more queue processes running.\n  if (!this._counter) queue.length = 0;\n  return this;\n};\n\n/**\n * Emit all listeners in a specified event with the provided arguments and\n * remove the event's listeners just before calling the them. This method allows\n * the emitter to serve as a queue where all listeners are called only once.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\nEmitter.prototype.burst = function () {\n  if (!this._events) return this;\n  this._clearOnEmit = true;\n  this.emit.apply(this, arguments);\n  return this;\n};\n\n/**\n * Check how many listeners there are for a specific event.\n *\n * @public\n * @param {String} event\n * @returns {Boolean}\n */\nEmitter.prototype.countListeners = function (event) {\n  if (!this._events) return 0;\n  var listeners = this._events[event];\n  return listeners ? listeners.length : 0;\n};\n\n/**\n * Destroy emitter instance. Basically just removes all bound listeners.\n *\n * @public\n * @returns {Emitter}\n */\nEmitter.prototype.destroy = function () {\n  if (!this._events) return this;\n  this._queue.length = this._counter = 0;\n  this._events = null;\n  return this;\n};\nvar pointerout = HAS_POINTER_EVENTS ? 'pointerout' : HAS_MS_POINTER_EVENTS ? 'MSPointerOut' : '';\nvar waitDuration = 100;\n\n/**\n * If you happen to use Edge or IE on a touch capable device there is a\n * a specific case where pointercancel and pointerend events are never emitted,\n * even though one them should always be emitted when you release your finger\n * from the screen. The bug appears specifically when Muuri shifts the dragged\n * element's position in the DOM after pointerdown event, IE and Edge don't like\n * that behaviour and quite often forget to emit the pointerend/pointercancel\n * event. But, they do emit pointerout event so we utilize that here.\n * Specifically, if there has been no pointermove event within 100 milliseconds\n * since the last pointerout event we force cancel the drag operation. This hack\n * works surprisingly well 99% of the time. There is that 1% chance there still\n * that dragged items get stuck but it is what it is.\n *\n * @class\n * @param {Dragger} dragger\n */\nfunction EdgeHack(dragger) {\n  if (!pointerout) return;\n  this._dragger = dragger;\n  this._timeout = null;\n  this._outEvent = null;\n  this._isActive = false;\n  this._addBehaviour = this._addBehaviour.bind(this);\n  this._removeBehaviour = this._removeBehaviour.bind(this);\n  this._onTimeout = this._onTimeout.bind(this);\n  this._resetData = this._resetData.bind(this);\n  this._onStart = this._onStart.bind(this);\n  this._onOut = this._onOut.bind(this);\n  this._dragger.on('start', this._onStart);\n}\n\n/**\n * @private\n */\nEdgeHack.prototype._addBehaviour = function () {\n  if (this._isActive) return;\n  this._isActive = true;\n  this._dragger.on('move', this._resetData);\n  this._dragger.on('cancel', this._removeBehaviour);\n  this._dragger.on('end', this._removeBehaviour);\n  window.addEventListener(pointerout, this._onOut);\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._removeBehaviour = function () {\n  if (!this._isActive) return;\n  this._dragger.off('move', this._resetData);\n  this._dragger.off('cancel', this._removeBehaviour);\n  this._dragger.off('end', this._removeBehaviour);\n  window.removeEventListener(pointerout, this._onOut);\n  this._resetData();\n  this._isActive = false;\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._resetData = function () {\n  window.clearTimeout(this._timeout);\n  this._timeout = null;\n  this._outEvent = null;\n};\n\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nEdgeHack.prototype._onStart = function (e) {\n  if (e.pointerType === 'mouse') return;\n  this._addBehaviour();\n};\n\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nEdgeHack.prototype._onOut = function (e) {\n  if (!this._dragger._getTrackedTouch(e)) return;\n  this._resetData();\n  this._outEvent = e;\n  this._timeout = window.setTimeout(this._onTimeout, waitDuration);\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._onTimeout = function () {\n  var e = this._outEvent;\n  this._resetData();\n  if (this._dragger.isActive()) this._dragger._onCancel(e);\n};\n\n/**\n * @public\n */\nEdgeHack.prototype.destroy = function () {\n  if (!pointerout) return;\n  this._dragger.off('start', this._onStart);\n  this._removeBehaviour();\n};\n\n// Playing it safe here, test all potential prefixes capitalized and lowercase.\nvar vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o', 'Webkit', 'Moz', 'MS', 'O'];\nvar cache$2 = {};\n\n/**\n * Get prefixed CSS property name when given a non-prefixed CSS property name.\n * Returns null if the property is not supported at all.\n *\n * @param {CSSStyleDeclaration} style\n * @param {String} prop\n * @returns {String}\n */\nfunction getPrefixedPropName(style, prop) {\n  var prefixedProp = cache$2[prop] || '';\n  if (prefixedProp) return prefixedProp;\n  var camelProp = prop[0].toUpperCase() + prop.slice(1);\n  var i = 0;\n  while (i < vendorPrefixes.length) {\n    prefixedProp = vendorPrefixes[i] ? vendorPrefixes[i] + camelProp : prop;\n    if (prefixedProp in style) {\n      cache$2[prop] = prefixedProp;\n      return prefixedProp;\n    }\n    ++i;\n  }\n  return '';\n}\n\n/**\n * Check if passive events are supported.\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n *\n * @returns {Boolean}\n */\nfunction hasPassiveEvents() {\n  var isPassiveEventsSupported = false;\n  try {\n    var passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        isPassiveEventsSupported = true;\n      }\n    });\n    window.addEventListener('testPassive', null, passiveOpts);\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n  return isPassiveEventsSupported;\n}\nvar ua = window.navigator.userAgent.toLowerCase();\nvar isEdge = ua.indexOf('edge') > -1;\nvar isIE = ua.indexOf('trident') > -1;\nvar isFirefox = ua.indexOf('firefox') > -1;\nvar isAndroid = ua.indexOf('android') > -1;\nvar listenerOptions = hasPassiveEvents() ? {\n  passive: true\n} : false;\nvar taProp = 'touchAction';\nvar taPropPrefixed = getPrefixedPropName(document.documentElement.style, taProp);\nvar taDefaultValue = 'auto';\n\n/**\n * Creates a new Dragger instance for an element.\n *\n * @public\n * @class\n * @param {HTMLElement} element\n * @param {Object} [cssProps]\n */\nfunction Dragger(element, cssProps) {\n  this._element = element;\n  this._emitter = new Emitter();\n  this._isDestroyed = false;\n  this._cssProps = {};\n  this._touchAction = '';\n  this._isActive = false;\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n  this._onStart = this._onStart.bind(this);\n  this._onMove = this._onMove.bind(this);\n  this._onCancel = this._onCancel.bind(this);\n  this._onEnd = this._onEnd.bind(this);\n\n  // Can't believe had to build a freaking class for a hack!\n  this._edgeHack = null;\n  if ((isEdge || isIE) && (HAS_POINTER_EVENTS || HAS_MS_POINTER_EVENTS)) {\n    this._edgeHack = new EdgeHack(this);\n  }\n\n  // Apply initial CSS props.\n  this.setCssProps(cssProps);\n\n  // If touch action was not provided with initial CSS props let's assume it's\n  // auto.\n  if (!this._touchAction) {\n    this.setTouchAction(taDefaultValue);\n  }\n\n  // Prevent native link/image dragging for the item and it's children.\n  element.addEventListener('dragstart', Dragger._preventDefault, false);\n\n  // Listen to start event.\n  element.addEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n}\n\n/**\n * Protected properties\n * ********************\n */\n\nDragger._pointerEvents = {\n  start: 'pointerdown',\n  move: 'pointermove',\n  cancel: 'pointercancel',\n  end: 'pointerup'\n};\nDragger._msPointerEvents = {\n  start: 'MSPointerDown',\n  move: 'MSPointerMove',\n  cancel: 'MSPointerCancel',\n  end: 'MSPointerUp'\n};\nDragger._touchEvents = {\n  start: 'touchstart',\n  move: 'touchmove',\n  cancel: 'touchcancel',\n  end: 'touchend'\n};\nDragger._mouseEvents = {\n  start: 'mousedown',\n  move: 'mousemove',\n  cancel: '',\n  end: 'mouseup'\n};\nDragger._inputEvents = function () {\n  if (HAS_TOUCH_EVENTS) return Dragger._touchEvents;\n  if (HAS_POINTER_EVENTS) return Dragger._pointerEvents;\n  if (HAS_MS_POINTER_EVENTS) return Dragger._msPointerEvents;\n  return Dragger._mouseEvents;\n}();\nDragger._emitter = new Emitter();\nDragger._emitterEvents = {\n  start: 'start',\n  move: 'move',\n  end: 'end',\n  cancel: 'cancel'\n};\nDragger._activeInstances = [];\n\n/**\n * Protected static methods\n * ************************\n */\n\nDragger._preventDefault = function (e) {\n  if (e.preventDefault && e.cancelable !== false) e.preventDefault();\n};\nDragger._activateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n  if (index > -1) return;\n  Dragger._activeInstances.push(instance);\n  Dragger._emitter.on(Dragger._emitterEvents.move, instance._onMove);\n  Dragger._emitter.on(Dragger._emitterEvents.cancel, instance._onCancel);\n  Dragger._emitter.on(Dragger._emitterEvents.end, instance._onEnd);\n  if (Dragger._activeInstances.length === 1) {\n    Dragger._bindListeners();\n  }\n};\nDragger._deactivateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n  if (index === -1) return;\n  Dragger._activeInstances.splice(index, 1);\n  Dragger._emitter.off(Dragger._emitterEvents.move, instance._onMove);\n  Dragger._emitter.off(Dragger._emitterEvents.cancel, instance._onCancel);\n  Dragger._emitter.off(Dragger._emitterEvents.end, instance._onEnd);\n  if (!Dragger._activeInstances.length) {\n    Dragger._unbindListeners();\n  }\n};\nDragger._bindListeners = function () {\n  window.addEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.addEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n  if (Dragger._inputEvents.cancel) {\n    window.addEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\nDragger._unbindListeners = function () {\n  window.removeEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.removeEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n  if (Dragger._inputEvents.cancel) {\n    window.removeEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\nDragger._getEventPointerId = function (event) {\n  // If we have pointer id available let's use it.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId;\n  }\n\n  // For touch events let's get the first changed touch's identifier.\n  if (event.changedTouches) {\n    return event.changedTouches[0] ? event.changedTouches[0].identifier : null;\n  }\n\n  // For mouse/other events let's provide a static id.\n  return 1;\n};\nDragger._getTouchById = function (event, id) {\n  // If we have a pointer event return the whole event if there's a match, and\n  // null otherwise.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId === id ? event : null;\n  }\n\n  // For touch events let's check if there's a changed touch object that matches\n  // the pointerId in which case return the touch object.\n  if (event.changedTouches) {\n    for (var i = 0; i < event.changedTouches.length; i++) {\n      if (event.changedTouches[i].identifier === id) {\n        return event.changedTouches[i];\n      }\n    }\n    return null;\n  }\n\n  // For mouse/other events let's assume there's only one pointer and just\n  // return the event.\n  return event;\n};\nDragger._onMove = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.move, e);\n};\nDragger._onCancel = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.cancel, e);\n};\nDragger._onEnd = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.end, e);\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Reset current drag operation (if any).\n *\n * @private\n */\nDragger.prototype._reset = function () {\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n  this._isActive = false;\n  Dragger._deactivateInstance(this);\n};\n\n/**\n * Create a custom dragger event from a raw event.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {Object}\n */\nDragger.prototype._createEvent = function (type, e) {\n  var touch = this._getTrackedTouch(e);\n  return {\n    // Hammer.js compatibility interface.\n    type: type,\n    srcEvent: e,\n    distance: this.getDistance(),\n    deltaX: this.getDeltaX(),\n    deltaY: this.getDeltaY(),\n    deltaTime: type === Dragger._emitterEvents.start ? 0 : this.getDeltaTime(),\n    isFirst: type === Dragger._emitterEvents.start,\n    isFinal: type === Dragger._emitterEvents.end || type === Dragger._emitterEvents.cancel,\n    pointerType: e.pointerType || (e.touches ? 'touch' : 'mouse'),\n    // Partial Touch API interface.\n    identifier: this._pointerId,\n    screenX: touch.screenX,\n    screenY: touch.screenY,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    target: touch.target\n  };\n};\n\n/**\n * Emit a raw event as dragger event internally.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._emit = function (type, e) {\n  this._emitter.emit(type, this._createEvent(type, e));\n};\n\n/**\n * If the provided event is a PointerEvent this method will return it if it has\n * the same pointerId as the instance. If the provided event is a TouchEvent\n * this method will try to look for a Touch instance in the changedTouches that\n * has an identifier matching this instance's pointerId. If the provided event\n * is a MouseEvent (or just any other event than PointerEvent or TouchEvent)\n * it will be returned immediately.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {?(Touch|PointerEvent|MouseEvent)}\n */\nDragger.prototype._getTrackedTouch = function (e) {\n  if (this._pointerId === null) return null;\n  return Dragger._getTouchById(e, this._pointerId);\n};\n\n/**\n * Handler for start event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onStart = function (e) {\n  if (this._isDestroyed) return;\n\n  // If pointer id is already assigned let's return early.\n  if (this._pointerId !== null) return;\n\n  // Get (and set) pointer id.\n  this._pointerId = Dragger._getEventPointerId(e);\n  if (this._pointerId === null) return;\n\n  // Setup initial data and emit start event.\n  var touch = this._getTrackedTouch(e);\n  this._startX = this._currentX = touch.clientX;\n  this._startY = this._currentY = touch.clientY;\n  this._startTime = Date.now();\n  this._isActive = true;\n  this._emit(Dragger._emitterEvents.start, e);\n\n  // If the drag procedure was not reset within the start procedure let's\n  // activate the instance (start listening to move/cancel/end events).\n  if (this._isActive) {\n    Dragger._activateInstance(this);\n  }\n};\n\n/**\n * Handler for move event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onMove = function (e) {\n  var touch = this._getTrackedTouch(e);\n  if (!touch) return;\n  this._currentX = touch.clientX;\n  this._currentY = touch.clientY;\n  this._emit(Dragger._emitterEvents.move, e);\n};\n\n/**\n * Handler for cancel event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onCancel = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n  this._emit(Dragger._emitterEvents.cancel, e);\n  this._reset();\n};\n\n/**\n * Handler for end event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onEnd = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n  this._emit(Dragger._emitterEvents.end, e);\n  this._reset();\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Check if the element is being dragged at the moment.\n *\n * @public\n * @returns {Boolean}\n */\nDragger.prototype.isActive = function () {\n  return this._isActive;\n};\n\n/**\n * Set element's touch-action CSS property.\n *\n * @public\n * @param {String} value\n */\nDragger.prototype.setTouchAction = function (value) {\n  // Store unmodified touch action value (we trust user input here).\n  this._touchAction = value;\n\n  // Set touch-action style.\n  if (taPropPrefixed) {\n    this._cssProps[taPropPrefixed] = '';\n    this._element.style[taPropPrefixed] = value;\n  }\n\n  // If we have an unsupported touch-action value let's add a special listener\n  // that prevents default action on touch start event. A dirty hack, but best\n  // we can do for now. The other options would be to somehow polyfill the\n  // unsupported touch action behavior with custom heuristics which sounds like\n  // a can of worms. We do a special exception here for Firefox Android which's\n  // touch-action does not work properly if the dragged element is moved in the\n  // the DOM tree on touchstart.\n  if (HAS_TOUCH_EVENTS) {\n    this._element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n    if (this._element.style[taPropPrefixed] !== value || isFirefox && isAndroid) {\n      this._element.addEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n    }\n  }\n};\n\n/**\n * Update element's CSS properties. Accepts an object with camel cased style\n * props with value pairs as it's first argument.\n *\n * @public\n * @param {Object} [newProps]\n */\nDragger.prototype.setCssProps = function (newProps) {\n  if (!newProps) return;\n  var currentProps = this._cssProps;\n  var element = this._element;\n  var prop;\n  var prefixedProp;\n\n  // Reset current props.\n  for (prop in currentProps) {\n    element.style[prop] = currentProps[prop];\n    delete currentProps[prop];\n  }\n\n  // Set new props.\n  for (prop in newProps) {\n    // Make sure we have a value for the prop.\n    if (!newProps[prop]) continue;\n\n    // Special handling for touch-action.\n    if (prop === taProp) {\n      this.setTouchAction(newProps[prop]);\n      continue;\n    }\n\n    // Get prefixed prop and skip if it does not exist.\n    prefixedProp = getPrefixedPropName(element.style, prop);\n    if (!prefixedProp) continue;\n\n    // Store the prop and add the style.\n    currentProps[prefixedProp] = '';\n    element.style[prefixedProp] = newProps[prop];\n  }\n};\n\n/**\n * How much the pointer has moved on x-axis from start position, in pixels.\n * Positive value indicates movement from left to right.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaX = function () {\n  return this._currentX - this._startX;\n};\n\n/**\n * How much the pointer has moved on y-axis from start position, in pixels.\n * Positive value indicates movement from top to bottom.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaY = function () {\n  return this._currentY - this._startY;\n};\n\n/**\n * How far (in pixels) has pointer moved from start position.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDistance = function () {\n  var x = this.getDeltaX();\n  var y = this.getDeltaY();\n  return Math.sqrt(x * x + y * y);\n};\n\n/**\n * How long has pointer been dragged.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaTime = function () {\n  return this._startTime ? Date.now() - this._startTime : 0;\n};\n\n/**\n * Bind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\nDragger.prototype.on = function (eventName, listener) {\n  this._emitter.on(eventName, listener);\n};\n\n/**\n * Unbind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\nDragger.prototype.off = function (eventName, listener) {\n  this._emitter.off(eventName, listener);\n};\n\n/**\n * Destroy the instance and unbind all drag event listeners.\n *\n * @public\n */\nDragger.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  var element = this._element;\n  if (this._edgeHack) this._edgeHack.destroy();\n\n  // Reset data and deactivate the instance.\n  this._reset();\n\n  // Destroy emitter.\n  this._emitter.destroy();\n\n  // Unbind event handlers.\n  element.removeEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n  element.removeEventListener('dragstart', Dragger._preventDefault, false);\n  element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n\n  // Reset styles.\n  for (var prop in this._cssProps) {\n    element.style[prop] = this._cssProps[prop];\n    delete this._cssProps[prop];\n  }\n\n  // Reset data.\n  this._element = null;\n\n  // Mark as destroyed.\n  this._isDestroyed = true;\n};\nvar dt = 1000 / 60;\nvar raf = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n  return this.setTimeout(function () {\n    callback(Date.now());\n  }, dt);\n}).bind(window);\n\n/**\n * A ticker system for handling DOM reads and writes in an efficient way.\n *\n * @class\n */\nfunction Ticker(numLanes) {\n  this._nextStep = null;\n  this._lanes = [];\n  this._stepQueue = [];\n  this._stepCallbacks = {};\n  this._step = this._step.bind(this);\n  for (var i = 0; i < numLanes; i++) {\n    this._lanes.push(new TickerLane());\n  }\n}\nTicker.prototype._step = function (time) {\n  var lanes = this._lanes;\n  var stepQueue = this._stepQueue;\n  var stepCallbacks = this._stepCallbacks;\n  var i, j, id, laneQueue, laneCallbacks, laneIndices;\n  this._nextStep = null;\n  for (i = 0; i < lanes.length; i++) {\n    laneQueue = lanes[i].queue;\n    laneCallbacks = lanes[i].callbacks;\n    laneIndices = lanes[i].indices;\n    for (j = 0; j < laneQueue.length; j++) {\n      id = laneQueue[j];\n      if (!id) continue;\n      stepQueue.push(id);\n      stepCallbacks[id] = laneCallbacks[id];\n      delete laneCallbacks[id];\n      delete laneIndices[id];\n    }\n    laneQueue.length = 0;\n  }\n  for (i = 0; i < stepQueue.length; i++) {\n    id = stepQueue[i];\n    if (stepCallbacks[id]) stepCallbacks[id](time);\n    delete stepCallbacks[id];\n  }\n  stepQueue.length = 0;\n};\nTicker.prototype.add = function (laneIndex, id, callback) {\n  this._lanes[laneIndex].add(id, callback);\n  if (!this._nextStep) this._nextStep = raf(this._step);\n};\nTicker.prototype.remove = function (laneIndex, id) {\n  this._lanes[laneIndex].remove(id);\n};\n\n/**\n * A lane for ticker.\n *\n * @class\n */\nfunction TickerLane() {\n  this.queue = [];\n  this.indices = {};\n  this.callbacks = {};\n}\nTickerLane.prototype.add = function (id, callback) {\n  var index = this.indices[id];\n  if (index !== undefined) this.queue[index] = undefined;\n  this.queue.push(id);\n  this.callbacks[id] = callback;\n  this.indices[id] = this.queue.length - 1;\n};\nTickerLane.prototype.remove = function (id) {\n  var index = this.indices[id];\n  if (index === undefined) return;\n  this.queue[index] = undefined;\n  delete this.callbacks[id];\n  delete this.indices[id];\n};\nvar LAYOUT_READ = 'layoutRead';\nvar LAYOUT_WRITE = 'layoutWrite';\nvar VISIBILITY_READ = 'visibilityRead';\nvar VISIBILITY_WRITE = 'visibilityWrite';\nvar DRAG_START_READ = 'dragStartRead';\nvar DRAG_START_WRITE = 'dragStartWrite';\nvar DRAG_MOVE_READ = 'dragMoveRead';\nvar DRAG_MOVE_WRITE = 'dragMoveWrite';\nvar DRAG_SCROLL_READ = 'dragScrollRead';\nvar DRAG_SCROLL_WRITE = 'dragScrollWrite';\nvar DRAG_SORT_READ = 'dragSortRead';\nvar PLACEHOLDER_LAYOUT_READ = 'placeholderLayoutRead';\nvar PLACEHOLDER_LAYOUT_WRITE = 'placeholderLayoutWrite';\nvar PLACEHOLDER_RESIZE_WRITE = 'placeholderResizeWrite';\nvar AUTO_SCROLL_READ = 'autoScrollRead';\nvar AUTO_SCROLL_WRITE = 'autoScrollWrite';\nvar DEBOUNCE_READ = 'debounceRead';\nvar LANE_READ = 0;\nvar LANE_READ_TAIL = 1;\nvar LANE_WRITE = 2;\nvar ticker = new Ticker(3);\nfunction addLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, LAYOUT_WRITE + itemId, write);\n}\nfunction cancelLayoutTick(itemId) {\n  ticker.remove(LANE_READ, LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, LAYOUT_WRITE + itemId);\n}\nfunction addVisibilityTick(itemId, read, write) {\n  ticker.add(LANE_READ, VISIBILITY_READ + itemId, read);\n  ticker.add(LANE_WRITE, VISIBILITY_WRITE + itemId, write);\n}\nfunction cancelVisibilityTick(itemId) {\n  ticker.remove(LANE_READ, VISIBILITY_READ + itemId);\n  ticker.remove(LANE_WRITE, VISIBILITY_WRITE + itemId);\n}\nfunction addDragStartTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_START_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_START_WRITE + itemId, write);\n}\nfunction cancelDragStartTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_START_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_START_WRITE + itemId);\n}\nfunction addDragMoveTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_MOVE_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_MOVE_WRITE + itemId, write);\n}\nfunction cancelDragMoveTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_MOVE_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_MOVE_WRITE + itemId);\n}\nfunction addDragScrollTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_SCROLL_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_SCROLL_WRITE + itemId, write);\n}\nfunction cancelDragScrollTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_SCROLL_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_SCROLL_WRITE + itemId);\n}\nfunction addDragSortTick(itemId, read) {\n  ticker.add(LANE_READ_TAIL, DRAG_SORT_READ + itemId, read);\n}\nfunction cancelDragSortTick(itemId) {\n  ticker.remove(LANE_READ_TAIL, DRAG_SORT_READ + itemId);\n}\nfunction addPlaceholderLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId, write);\n}\nfunction cancelPlaceholderLayoutTick(itemId) {\n  ticker.remove(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId);\n}\nfunction addPlaceholderResizeTick(itemId, write) {\n  ticker.add(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId, write);\n}\nfunction cancelPlaceholderResizeTick(itemId) {\n  ticker.remove(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId);\n}\nfunction addAutoScrollTick(read, write) {\n  ticker.add(LANE_READ, AUTO_SCROLL_READ, read);\n  ticker.add(LANE_WRITE, AUTO_SCROLL_WRITE, write);\n}\nfunction cancelAutoScrollTick() {\n  ticker.remove(LANE_READ, AUTO_SCROLL_READ);\n  ticker.remove(LANE_WRITE, AUTO_SCROLL_WRITE);\n}\nfunction addDebounceTick(debounceId, read) {\n  ticker.add(LANE_READ, DEBOUNCE_READ + debounceId, read);\n}\nfunction cancelDebounceTick(debounceId) {\n  ticker.remove(LANE_READ, DEBOUNCE_READ + debounceId);\n}\nvar AXIS_X = 1;\nvar AXIS_Y = 2;\nvar FORWARD = 4;\nvar BACKWARD = 8;\nvar LEFT = AXIS_X | BACKWARD;\nvar RIGHT = AXIS_X | FORWARD;\nvar UP = AXIS_Y | BACKWARD;\nvar DOWN = AXIS_Y | FORWARD;\nvar functionType = 'function';\n\n/**\n * Check if a value is a function.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isFunction(val) {\n  return typeof val === functionType;\n}\nvar cache$1 = typeof WeakMap === 'function' ? new WeakMap() : null;\n\n/**\n * Returns the computed value of an element's style property as a string.\n *\n * @param {HTMLElement} element\n * @param {String} style\n * @returns {String}\n */\nfunction getStyle(element, style) {\n  var styles = cache$1 && cache$1.get(element);\n  if (!styles) {\n    styles = window.getComputedStyle(element, null);\n    if (cache$1) cache$1.set(element, styles);\n  }\n  return styles.getPropertyValue(style);\n}\n\n/**\n * Returns the computed value of an element's style property transformed into\n * a float value.\n *\n * @param {HTMLElement} el\n * @param {String} style\n * @returns {Number}\n */\nfunction getStyleAsFloat(el, style) {\n  return parseFloat(getStyle(el, style)) || 0;\n}\nvar DOC_ELEM = document.documentElement;\nvar BODY = document.body;\nvar THRESHOLD_DATA = {\n  value: 0,\n  offset: 0\n};\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {HTMLElement|Window}\n */\nfunction getScrollElement(element) {\n  if (element === window || element === DOC_ELEM || element === BODY) {\n    return window;\n  } else {\n    return element;\n  }\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollLeft(element) {\n  return element === window ? element.pageXOffset : element.scrollLeft;\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollTop(element) {\n  return element === window ? element.pageYOffset : element.scrollTop;\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollLeftMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollWidth - DOC_ELEM.clientWidth;\n  } else {\n    return element.scrollWidth - element.clientWidth;\n  }\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollTopMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollHeight - DOC_ELEM.clientHeight;\n  } else {\n    return element.scrollHeight - element.clientHeight;\n  }\n}\n\n/**\n * Get window's or element's client rectangle data relative to the element's\n * content dimensions (includes inner size + padding, excludes scrollbars,\n * borders and margins).\n *\n * @param {HTMLElement|Window} element\n * @returns {Rectangle}\n */\nfunction getContentRect(element, result) {\n  result = result || {};\n  if (element === window) {\n    result.width = DOC_ELEM.clientWidth;\n    result.height = DOC_ELEM.clientHeight;\n    result.left = 0;\n    result.right = result.width;\n    result.top = 0;\n    result.bottom = result.height;\n  } else {\n    var bcr = element.getBoundingClientRect();\n    var borderLeft = element.clientLeft || getStyleAsFloat(element, 'border-left-width');\n    var borderTop = element.clientTop || getStyleAsFloat(element, 'border-top-width');\n    result.width = element.clientWidth;\n    result.height = element.clientHeight;\n    result.left = bcr.left + borderLeft;\n    result.right = result.left + result.width;\n    result.top = bcr.top + borderTop;\n    result.bottom = result.top + result.height;\n  }\n  return result;\n}\n\n/**\n * @param {Item} item\n * @returns {Object}\n */\nfunction getItemAutoScrollSettings(item) {\n  return item._drag._getGrid()._settings.dragAutoScroll;\n}\n\n/**\n * @param {Item} item\n */\nfunction prepareItemScrollSync(item) {\n  if (!item._drag) return;\n  item._drag._prepareScroll();\n}\n\n/**\n * @param {Item} item\n */\nfunction applyItemScrollSync(item) {\n  if (!item._drag || !item._isActive) return;\n  var drag = item._drag;\n  drag._scrollDiffX = drag._scrollDiffY = 0;\n  item._setTranslate(drag._left, drag._top);\n}\n\n/**\n * Compute threshold value and edge offset.\n *\n * @param {Number} threshold\n * @param {Number} safeZone\n * @param {Number} itemSize\n * @param {Number} targetSize\n * @returns {Object}\n */\nfunction computeThreshold(threshold, safeZone, itemSize, targetSize) {\n  THRESHOLD_DATA.value = Math.min(targetSize / 2, threshold);\n  THRESHOLD_DATA.offset = Math.max(0, itemSize + THRESHOLD_DATA.value * 2 + targetSize * safeZone - targetSize) / 2;\n  return THRESHOLD_DATA;\n}\nfunction ScrollRequest() {\n  this.reset();\n}\nScrollRequest.prototype.reset = function () {\n  if (this.isActive) this.onStop();\n  this.item = null;\n  this.element = null;\n  this.isActive = false;\n  this.isEnding = false;\n  this.direction = null;\n  this.value = null;\n  this.maxValue = 0;\n  this.threshold = 0;\n  this.distance = 0;\n  this.speed = 0;\n  this.duration = 0;\n  this.action = null;\n};\nScrollRequest.prototype.hasReachedEnd = function () {\n  return FORWARD & this.direction ? this.value >= this.maxValue : this.value <= 0;\n};\nScrollRequest.prototype.computeCurrentScrollValue = function () {\n  if (this.value === null) {\n    return AXIS_X & this.direction ? getScrollLeft(this.element) : getScrollTop(this.element);\n  }\n  return Math.max(0, Math.min(this.value, this.maxValue));\n};\nScrollRequest.prototype.computeNextScrollValue = function (deltaTime) {\n  var delta = this.speed * (deltaTime / 1000);\n  var nextValue = FORWARD & this.direction ? this.value + delta : this.value - delta;\n  return Math.max(0, Math.min(nextValue, this.maxValue));\n};\nScrollRequest.prototype.computeSpeed = function () {\n  var data = {\n    direction: null,\n    threshold: 0,\n    distance: 0,\n    value: 0,\n    maxValue: 0,\n    deltaTime: 0,\n    duration: 0,\n    isEnding: false\n  };\n  return function (deltaTime) {\n    var item = this.item;\n    var speed = getItemAutoScrollSettings(item).speed;\n    if (isFunction(speed)) {\n      data.direction = this.direction;\n      data.threshold = this.threshold;\n      data.distance = this.distance;\n      data.value = this.value;\n      data.maxValue = this.maxValue;\n      data.duration = this.duration;\n      data.speed = this.speed;\n      data.deltaTime = deltaTime;\n      data.isEnding = this.isEnding;\n      return speed(item, this.element, data);\n    } else {\n      return speed;\n    }\n  };\n}();\nScrollRequest.prototype.tick = function (deltaTime) {\n  if (!this.isActive) {\n    this.isActive = true;\n    this.onStart();\n  }\n  this.value = this.computeCurrentScrollValue();\n  this.speed = this.computeSpeed(deltaTime);\n  this.value = this.computeNextScrollValue(deltaTime);\n  this.duration += deltaTime;\n  return this.value;\n};\nScrollRequest.prototype.onStart = function () {\n  var item = this.item;\n  var onStart = getItemAutoScrollSettings(item).onStart;\n  if (isFunction(onStart)) onStart(item, this.element, this.direction);\n};\nScrollRequest.prototype.onStop = function () {\n  var item = this.item;\n  var onStop = getItemAutoScrollSettings(item).onStop;\n  if (isFunction(onStop)) onStop(item, this.element, this.direction);\n  // Manually nudge sort to happen. There's a good chance that the item is still\n  // after the scroll stops which means that the next sort will be triggered\n  // only after the item is moved or it's parent scrolled.\n  if (item._drag) item._drag.sort();\n};\nfunction ScrollAction() {\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n}\nScrollAction.prototype.reset = function () {\n  if (this.requestX) this.requestX.action = null;\n  if (this.requestY) this.requestY.action = null;\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n};\nScrollAction.prototype.addRequest = function (request) {\n  if (AXIS_X & request.direction) {\n    this.removeRequest(this.requestX);\n    this.requestX = request;\n  } else {\n    this.removeRequest(this.requestY);\n    this.requestY = request;\n  }\n  request.action = this;\n};\nScrollAction.prototype.removeRequest = function (request) {\n  if (!request) return;\n  if (this.requestX === request) {\n    this.requestX = null;\n    request.action = null;\n  } else if (this.requestY === request) {\n    this.requestY = null;\n    request.action = null;\n  }\n};\nScrollAction.prototype.computeScrollValues = function () {\n  this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n  this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n};\nScrollAction.prototype.scroll = function () {\n  var element = this.element;\n  if (!element) return;\n  if (element.scrollTo) {\n    element.scrollTo(this.scrollLeft, this.scrollTop);\n  } else {\n    element.scrollLeft = this.scrollLeft;\n    element.scrollTop = this.scrollTop;\n  }\n};\nfunction Pool(createItem, releaseItem) {\n  this.pool = [];\n  this.createItem = createItem;\n  this.releaseItem = releaseItem;\n}\nPool.prototype.pick = function () {\n  return this.pool.pop() || this.createItem();\n};\nPool.prototype.release = function (item) {\n  this.releaseItem(item);\n  if (this.pool.indexOf(item) !== -1) return;\n  this.pool.push(item);\n};\nPool.prototype.reset = function () {\n  this.pool.length = 0;\n};\n\n/**\n * Check if two rectangles are overlapping.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction isOverlapping(a, b) {\n  return !(a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top);\n}\n\n/**\n * Calculate intersection area between two rectangle.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction getIntersectionArea(a, b) {\n  if (!isOverlapping(a, b)) return 0;\n  var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n  var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n  return width * height;\n}\n\n/**\n * Calculate how many percent the intersection area of two rectangles is from\n * the maximum potential intersection area between the rectangles.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction getIntersectionScore(a, b) {\n  var area = getIntersectionArea(a, b);\n  if (!area) return 0;\n  var maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n  return area / maxArea * 100;\n}\nvar RECT_1 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\nvar RECT_2 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\nfunction AutoScroller() {\n  this._isDestroyed = false;\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  this._items = [];\n  this._actions = [];\n  this._requests = {};\n  this._requests[AXIS_X] = {};\n  this._requests[AXIS_Y] = {};\n  this._requestOverlapCheck = {};\n  this._dragPositions = {};\n  this._dragDirections = {};\n  this._overlapCheckInterval = 150;\n  this._requestPool = new Pool(function () {\n    return new ScrollRequest();\n  }, function (request) {\n    request.reset();\n  });\n  this._actionPool = new Pool(function () {\n    return new ScrollAction();\n  }, function (action) {\n    action.reset();\n  });\n  this._readTick = this._readTick.bind(this);\n  this._writeTick = this._writeTick.bind(this);\n}\nAutoScroller.AXIS_X = AXIS_X;\nAutoScroller.AXIS_Y = AXIS_Y;\nAutoScroller.FORWARD = FORWARD;\nAutoScroller.BACKWARD = BACKWARD;\nAutoScroller.LEFT = LEFT;\nAutoScroller.RIGHT = RIGHT;\nAutoScroller.UP = UP;\nAutoScroller.DOWN = DOWN;\nAutoScroller.smoothSpeed = function (maxSpeed, acceleration, deceleration) {\n  return function (item, element, data) {\n    var targetSpeed = 0;\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        var factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = maxSpeed / data.threshold * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n    var currentSpeed = data.speed;\n    var nextSpeed = targetSpeed;\n    if (currentSpeed === targetSpeed) {\n      return nextSpeed;\n    }\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n};\nAutoScroller.pointerHandle = function (pointerSize) {\n  var rect = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  };\n  var size = pointerSize || 1;\n  return function (item, x, y, w, h, pX, pY) {\n    rect.left = pX - size * 0.5;\n    rect.top = pY - size * 0.5;\n    rect.width = size;\n    rect.height = size;\n    return rect;\n  };\n};\nAutoScroller.prototype._readTick = function (time) {\n  if (this._isDestroyed) return;\n  if (time && this._tickTime) {\n    this._tickDeltaTime = time - this._tickTime;\n    this._tickTime = time;\n    this._updateRequests();\n    this._updateActions();\n  } else {\n    this._tickTime = time;\n    this._tickDeltaTime = 0;\n  }\n};\nAutoScroller.prototype._writeTick = function () {\n  if (this._isDestroyed) return;\n  this._applyActions();\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\nAutoScroller.prototype._startTicking = function () {\n  this._isTicking = true;\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\nAutoScroller.prototype._stopTicking = function () {\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  cancelAutoScrollTick();\n};\nAutoScroller.prototype._getItemHandleRect = function (item, handle, rect) {\n  var itemDrag = item._drag;\n  if (handle) {\n    var ev = itemDrag._dragMoveEvent || itemDrag._dragStartEvent;\n    var data = handle(item, itemDrag._clientX, itemDrag._clientY, item._width, item._height, ev.clientX, ev.clientY);\n    rect.left = data.left;\n    rect.top = data.top;\n    rect.width = data.width;\n    rect.height = data.height;\n  } else {\n    rect.left = itemDrag._clientX;\n    rect.top = itemDrag._clientY;\n    rect.width = item._width;\n    rect.height = item._height;\n  }\n  rect.right = rect.left + rect.width;\n  rect.bottom = rect.top + rect.height;\n  return rect;\n};\nAutoScroller.prototype._requestItemScroll = function (item, axis, element, direction, threshold, distance, maxValue) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n  if (request) {\n    if (request.element !== element || request.direction !== direction) {\n      request.reset();\n    }\n  } else {\n    request = this._requestPool.pick();\n  }\n  request.item = item;\n  request.element = element;\n  request.direction = direction;\n  request.threshold = threshold;\n  request.distance = distance;\n  request.maxValue = maxValue;\n  reqMap[item._id] = request;\n};\nAutoScroller.prototype._cancelItemScroll = function (item, axis) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n  if (!request) return;\n  if (request.action) request.action.removeRequest(request);\n  this._requestPool.release(request);\n  delete reqMap[item._id];\n};\nAutoScroller.prototype._checkItemOverlap = function (item, checkX, checkY) {\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n  if (!targets || !targets.length) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n  var dragDirections = this._dragDirections[item._id];\n  var dragDirectionX = dragDirections[0];\n  var dragDirectionY = dragDirections[1];\n  if (!dragDirectionX && !dragDirectionY) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n  var testRect = RECT_2;\n  var target = null;\n  var testElement = null;\n  var testAxisX = true;\n  var testAxisY = true;\n  var testScore = 0;\n  var testPriority = 0;\n  var testThreshold = null;\n  var testDirection = null;\n  var testDistance = 0;\n  var testMaxScrollX = 0;\n  var testMaxScrollY = 0;\n  var xElement = null;\n  var xPriority = -Infinity;\n  var xThreshold = 0;\n  var xScore = 0;\n  var xDirection = null;\n  var xDistance = 0;\n  var xMaxScroll = 0;\n  var yElement = null;\n  var yPriority = -Infinity;\n  var yThreshold = 0;\n  var yScore = 0;\n  var yDirection = null;\n  var yDistance = 0;\n  var yMaxScroll = 0;\n  for (var i = 0; i < targets.length; i++) {\n    target = targets[i];\n    testAxisX = checkX && dragDirectionX && target.axis !== AXIS_Y;\n    testAxisY = checkY && dragDirectionY && target.axis !== AXIS_X;\n    testPriority = target.priority || 0;\n\n    // Ignore this item if it's x-axis and y-axis priority is lower than\n    // the currently matching item's.\n    if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n      continue;\n    }\n    testElement = getScrollElement(target.element || target);\n    testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n    testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1;\n\n    // Ignore this item if there is no possibility to scroll.\n    if (!testMaxScrollX && !testMaxScrollY) continue;\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect);\n\n    // Ignore this item if it's not overlapping at all with the dragged item.\n    if (testScore <= 0) continue;\n\n    // Test x-axis.\n    if (testAxisX && testPriority >= xPriority && testMaxScrollX > 0 && (testPriority > xPriority || testScore > xScore)) {\n      testDirection = null;\n      testThreshold = computeThreshold(typeof target.threshold === 'number' ? target.threshold : threshold, safeZone, itemRect.width, testRect.width);\n      if (dragDirectionX === RIGHT) {\n        testDistance = testRect.right + testThreshold.offset - itemRect.right;\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) < testMaxScrollX) {\n          testDirection = RIGHT;\n        }\n      } else if (dragDirectionX === LEFT) {\n        testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) > 0) {\n          testDirection = LEFT;\n        }\n      }\n      if (testDirection !== null) {\n        xElement = testElement;\n        xPriority = testPriority;\n        xThreshold = testThreshold.value;\n        xScore = testScore;\n        xDirection = testDirection;\n        xDistance = testDistance;\n        xMaxScroll = testMaxScrollX;\n      }\n    }\n\n    // Test y-axis.\n    if (testAxisY && testPriority >= yPriority && testMaxScrollY > 0 && (testPriority > yPriority || testScore > yScore)) {\n      testDirection = null;\n      testThreshold = computeThreshold(typeof target.threshold === 'number' ? target.threshold : threshold, safeZone, itemRect.height, testRect.height);\n      if (dragDirectionY === DOWN) {\n        testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) < testMaxScrollY) {\n          testDirection = DOWN;\n        }\n      } else if (dragDirectionY === UP) {\n        testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) > 0) {\n          testDirection = UP;\n        }\n      }\n      if (testDirection !== null) {\n        yElement = testElement;\n        yPriority = testPriority;\n        yThreshold = testThreshold.value;\n        yScore = testScore;\n        yDirection = testDirection;\n        yDistance = testDistance;\n        yMaxScroll = testMaxScrollY;\n      }\n    }\n  }\n\n  // Request or cancel x-axis scroll.\n  if (checkX) {\n    if (xElement) {\n      this._requestItemScroll(item, AXIS_X, xElement, xDirection, xThreshold, xDistance, xMaxScroll);\n    } else {\n      this._cancelItemScroll(item, AXIS_X);\n    }\n  }\n\n  // Request or cancel y-axis scroll.\n  if (checkY) {\n    if (yElement) {\n      this._requestItemScroll(item, AXIS_Y, yElement, yDirection, yThreshold, yDistance, yMaxScroll);\n    } else {\n      this._cancelItemScroll(item, AXIS_Y);\n    }\n  }\n};\nAutoScroller.prototype._updateScrollRequest = function (scrollRequest) {\n  var item = scrollRequest.item;\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var targetCount = targets && targets.length || 0;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n  var testRect = RECT_2;\n  var target = null;\n  var testElement = null;\n  var testIsAxisX = false;\n  var testScore = null;\n  var testThreshold = null;\n  var testDistance = null;\n  var testScroll = null;\n  var testMaxScroll = null;\n  var hasReachedEnd = null;\n  for (var i = 0; i < targetCount; i++) {\n    target = targets[i];\n\n    // Make sure we have a matching element.\n    testElement = getScrollElement(target.element || target);\n    if (testElement !== scrollRequest.element) continue;\n\n    // Make sure we have a matching axis.\n    testIsAxisX = !!(AXIS_X & scrollRequest.direction);\n    if (testIsAxisX) {\n      if (target.axis === AXIS_Y) continue;\n    } else {\n      if (target.axis === AXIS_X) continue;\n    }\n\n    // Stop scrolling if there is no room to scroll anymore.\n    testMaxScroll = testIsAxisX ? getScrollLeftMax(testElement) : getScrollTopMax(testElement);\n    if (testMaxScroll <= 0) {\n      break;\n    }\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect);\n\n    // Stop scrolling if dragged item is not overlapping with the scroll\n    // element anymore.\n    if (testScore <= 0) {\n      break;\n    }\n\n    // Compute threshold and edge offset.\n    testThreshold = computeThreshold(typeof target.threshold === 'number' ? target.threshold : threshold, safeZone, testIsAxisX ? itemRect.width : itemRect.height, testIsAxisX ? testRect.width : testRect.height);\n\n    // Compute distance (based on current direction).\n    if (scrollRequest.direction === LEFT) {\n      testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n    } else if (scrollRequest.direction === RIGHT) {\n      testDistance = testRect.right + testThreshold.offset - itemRect.right;\n    } else if (scrollRequest.direction === UP) {\n      testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n    } else {\n      testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n    }\n\n    // Stop scrolling if threshold is not exceeded.\n    if (testDistance > testThreshold.value) {\n      break;\n    }\n\n    // Stop scrolling if we have reached the end of the scroll value.\n    testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n    hasReachedEnd = FORWARD & scrollRequest.direction ? testScroll >= testMaxScroll : testScroll <= 0;\n    if (hasReachedEnd) {\n      break;\n    }\n\n    // Scrolling can continue, let's update the values.\n    scrollRequest.maxValue = testMaxScroll;\n    scrollRequest.threshold = testThreshold.value;\n    scrollRequest.distance = testDistance;\n    scrollRequest.isEnding = false;\n    return true;\n  }\n\n  // Before we end the request, let's see if we need to stop the scrolling\n  // smoothly or immediately.\n  if (settings.smoothStop === true && scrollRequest.speed > 0) {\n    if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n    scrollRequest.isEnding = hasReachedEnd ? false : true;\n  } else {\n    scrollRequest.isEnding = false;\n  }\n  return scrollRequest.isEnding;\n};\nAutoScroller.prototype._updateRequests = function () {\n  var items = this._items;\n  var requestsX = this._requests[AXIS_X];\n  var requestsY = this._requests[AXIS_Y];\n  var item, reqX, reqY, checkTime, needsCheck, checkX, checkY;\n  for (var i = 0; i < items.length; i++) {\n    item = items[i];\n    checkTime = this._requestOverlapCheck[item._id];\n    needsCheck = checkTime > 0 && this._tickTime - checkTime > this._overlapCheckInterval;\n    checkX = true;\n    reqX = requestsX[item._id];\n    if (reqX && reqX.isActive) {\n      checkX = !this._updateScrollRequest(reqX);\n      if (checkX) {\n        needsCheck = true;\n        this._cancelItemScroll(item, AXIS_X);\n      }\n    }\n    checkY = true;\n    reqY = requestsY[item._id];\n    if (reqY && reqY.isActive) {\n      checkY = !this._updateScrollRequest(reqY);\n      if (checkY) {\n        needsCheck = true;\n        this._cancelItemScroll(item, AXIS_Y);\n      }\n    }\n    if (needsCheck) {\n      this._requestOverlapCheck[item._id] = 0;\n      this._checkItemOverlap(item, checkX, checkY);\n    }\n  }\n};\nAutoScroller.prototype._requestAction = function (request, axis) {\n  var actions = this._actions;\n  var isAxisX = axis === AXIS_X;\n  var action = null;\n  for (var i = 0; i < actions.length; i++) {\n    action = actions[i];\n\n    // If the action's request does not match the request's -> skip.\n    if (request.element !== action.element) {\n      action = null;\n      continue;\n    }\n\n    // If the request and action share the same element, but the request slot\n    // for the requested axis is already reserved let's ignore and cancel this\n    // request.\n    if (isAxisX ? action.requestX : action.requestY) {\n      this._cancelItemScroll(request.item, axis);\n      return;\n    }\n\n    // Seems like we have found our action, let's break the loop.\n    break;\n  }\n  if (!action) action = this._actionPool.pick();\n  action.element = request.element;\n  action.addRequest(request);\n  request.tick(this._tickDeltaTime);\n  actions.push(action);\n};\nAutoScroller.prototype._updateActions = function () {\n  var items = this._items;\n  var requests = this._requests;\n  var actions = this._actions;\n  var itemId;\n  var reqX;\n  var reqY;\n  var i;\n\n  // Generate actions.\n  for (i = 0; i < items.length; i++) {\n    itemId = items[i]._id;\n    reqX = requests[AXIS_X][itemId];\n    reqY = requests[AXIS_Y][itemId];\n    if (reqX) this._requestAction(reqX, AXIS_X);\n    if (reqY) this._requestAction(reqY, AXIS_Y);\n  }\n\n  // Compute actions' scroll values.\n  for (i = 0; i < actions.length; i++) {\n    actions[i].computeScrollValues();\n  }\n};\nAutoScroller.prototype._applyActions = function () {\n  var actions = this._actions;\n  var items = this._items;\n  var i;\n\n  // No actions -> no scrolling.\n  if (!actions.length) return;\n\n  // Scroll all the required elements.\n  for (i = 0; i < actions.length; i++) {\n    actions[i].scroll();\n    this._actionPool.release(actions[i]);\n  }\n\n  // Reset actions.\n  actions.length = 0;\n\n  // Sync the item position immediately after all the auto-scrolling business is\n  // finished. Without this procedure the items will jitter during auto-scroll\n  // (in some cases at least) since the drag scroll handler is async (bound to\n  // raf tick). Note that this procedure should not emit any dragScroll events,\n  // because otherwise they would be emitted twice for the same event.\n  for (i = 0; i < items.length; i++) prepareItemScrollSync(items[i]);\n  for (i = 0; i < items.length; i++) applyItemScrollSync(items[i]);\n};\nAutoScroller.prototype._updateDragDirection = function (item) {\n  var dragPositions = this._dragPositions[item._id];\n  var dragDirections = this._dragDirections[item._id];\n  var x1 = item._drag._left;\n  var y1 = item._drag._top;\n  if (dragPositions.length) {\n    var x2 = dragPositions[0];\n    var y2 = dragPositions[1];\n    dragDirections[0] = x1 > x2 ? RIGHT : x1 < x2 ? LEFT : dragDirections[0] || 0;\n    dragDirections[1] = y1 > y2 ? DOWN : y1 < y2 ? UP : dragDirections[1] || 0;\n  }\n  dragPositions[0] = x1;\n  dragPositions[1] = y1;\n};\nAutoScroller.prototype.addItem = function (item) {\n  if (this._isDestroyed) return;\n  var index = this._items.indexOf(item);\n  if (index === -1) {\n    this._items.push(item);\n    this._requestOverlapCheck[item._id] = this._tickTime;\n    this._dragDirections[item._id] = [0, 0];\n    this._dragPositions[item._id] = [];\n    if (!this._isTicking) this._startTicking();\n  }\n};\nAutoScroller.prototype.updateItem = function (item) {\n  if (this._isDestroyed) return;\n\n  // Make sure the item still exists in the auto-scroller.\n  if (!this._dragDirections[item._id]) return;\n  this._updateDragDirection(item);\n  if (!this._requestOverlapCheck[item._id]) {\n    this._requestOverlapCheck[item._id] = this._tickTime;\n  }\n};\nAutoScroller.prototype.removeItem = function (item) {\n  if (this._isDestroyed) return;\n  var index = this._items.indexOf(item);\n  if (index === -1) return;\n  var itemId = item._id;\n  var reqX = this._requests[AXIS_X][itemId];\n  if (reqX) {\n    this._cancelItemScroll(item, AXIS_X);\n    delete this._requests[AXIS_X][itemId];\n  }\n  var reqY = this._requests[AXIS_Y][itemId];\n  if (reqY) {\n    this._cancelItemScroll(item, AXIS_Y);\n    delete this._requests[AXIS_Y][itemId];\n  }\n  delete this._requestOverlapCheck[itemId];\n  delete this._dragPositions[itemId];\n  delete this._dragDirections[itemId];\n  this._items.splice(index, 1);\n  if (this._isTicking && !this._items.length) {\n    this._stopTicking();\n  }\n};\nAutoScroller.prototype.isItemScrollingX = function (item) {\n  var reqX = this._requests[AXIS_X][item._id];\n  return !!(reqX && reqX.isActive);\n};\nAutoScroller.prototype.isItemScrollingY = function (item) {\n  var reqY = this._requests[AXIS_Y][item._id];\n  return !!(reqY && reqY.isActive);\n};\nAutoScroller.prototype.isItemScrolling = function (item) {\n  return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n};\nAutoScroller.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  var items = this._items.slice(0);\n  for (var i = 0; i < items.length; i++) {\n    this.removeItem(items[i]);\n  }\n  this._actions.length = 0;\n  this._requestPool.reset();\n  this._actionPool.reset();\n  this._isDestroyed = true;\n};\nvar ElProto = window.Element.prototype;\nvar matchesFn = ElProto.matches || ElProto.matchesSelector || ElProto.webkitMatchesSelector || ElProto.mozMatchesSelector || ElProto.msMatchesSelector || ElProto.oMatchesSelector || function () {\n  return false;\n};\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {Element} el\n * @param {String} selector\n * @returns {Boolean}\n */\nfunction elementMatches(el, selector) {\n  return matchesFn.call(el, selector);\n}\n\n/**\n * Add class to an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\nfunction addClass(element, className) {\n  if (!className) return;\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (!elementMatches(element, '.' + className)) {\n      element.className += ' ' + className;\n    }\n  }\n}\nvar tempArray = [];\nvar numberType = 'number';\n\n/**\n * Insert an item or an array of items to array to a specified index. Mutates\n * the array. The index can be negative in which case the items will be added\n * to the end of the array.\n *\n * @param {Array} array\n * @param {*} items\n * @param {Number} [index=-1]\n */\nfunction arrayInsert(array, items, index) {\n  var startIndex = typeof index === numberType ? index : -1;\n  if (startIndex < 0) startIndex = array.length - startIndex + 1;\n  array.splice.apply(array, tempArray.concat(startIndex, 0, items));\n  tempArray.length = 0;\n}\n\n/**\n * Normalize array index. Basically this function makes sure that the provided\n * array index is within the bounds of the provided array and also transforms\n * negative index to the matching positive index. The third (optional) argument\n * allows you to define offset for array's length in case you are adding items\n * to the array or removing items from the array.\n *\n * @param {Array} array\n * @param {Number} index\n * @param {Number} [sizeOffset]\n */\nfunction normalizeArrayIndex(array, index, sizeOffset) {\n  var maxIndex = Math.max(0, array.length - 1 + (sizeOffset || 0));\n  return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;\n}\n\n/**\n * Move array item to another index.\n *\n * @param {Array} array\n * @param {Number} fromIndex\n *   - Index (positive or negative) of the item that will be moved.\n * @param {Number} toIndex\n *   - Index (positive or negative) where the item should be moved to.\n */\nfunction arrayMove(array, fromIndex, toIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return;\n\n  // Normalize the indices.\n  var from = normalizeArrayIndex(array, fromIndex);\n  var to = normalizeArrayIndex(array, toIndex);\n\n  // Add target item to the new position.\n  if (from !== to) {\n    array.splice(to, 0, array.splice(from, 1)[0]);\n  }\n}\n\n/**\n * Swap array items.\n *\n * @param {Array} array\n * @param {Number} index\n *   - Index (positive or negative) of the item that will be swapped.\n * @param {Number} withIndex\n *   - Index (positive or negative) of the other item that will be swapped.\n */\nfunction arraySwap(array, index, withIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return;\n\n  // Normalize the indices.\n  var indexA = normalizeArrayIndex(array, index);\n  var indexB = normalizeArrayIndex(array, withIndex);\n  var temp;\n\n  // Swap the items.\n  if (indexA !== indexB) {\n    temp = array[indexA];\n    array[indexA] = array[indexB];\n    array[indexB] = temp;\n  }\n}\nvar transformProp = getPrefixedPropName(document.documentElement.style, 'transform') || 'transform';\nvar styleNameRegEx = /([A-Z])/g;\nvar prefixRegex = /^(webkit-|moz-|ms-|o-)/;\nvar msPrefixRegex = /^(-m-s-)/;\n\n/**\n * Transforms a camel case style property to kebab case style property. Handles\n * vendor prefixed properties elegantly as well, e.g. \"WebkitTransform\" and\n * \"webkitTransform\" are both transformed into \"-webkit-transform\".\n *\n * @param {String} property\n * @returns {String}\n */\nfunction getStyleName(property) {\n  // Initial slicing, turns \"fooBarProp\" into \"foo-bar-prop\".\n  var styleName = property.replace(styleNameRegEx, '-$1').toLowerCase();\n\n  // Handle properties that start with \"webkit\", \"moz\", \"ms\" or \"o\" prefix (we\n  // need to add an extra '-' to the beginnig).\n  styleName = styleName.replace(prefixRegex, '-$1');\n\n  // Handle properties that start with \"MS\" prefix (we need to transform the\n  // \"-m-s-\" into \"-ms-\").\n  styleName = styleName.replace(msPrefixRegex, '-ms-');\n  return styleName;\n}\nvar transformStyle = getStyleName(transformProp);\nvar transformNone$1 = 'none';\nvar displayInline = 'inline';\nvar displayNone = 'none';\nvar displayStyle = 'display';\n\n/**\n * Returns true if element is transformed, false if not. In practice the\n * element's display value must be anything else than \"none\" or \"inline\" as\n * well as have a valid transform value applied in order to be counted as a\n * transformed element.\n *\n * Borrowed from Mezr (v0.6.1):\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\nfunction isTransformed(element) {\n  var transform = getStyle(element, transformStyle);\n  if (!transform || transform === transformNone$1) return false;\n  var display = getStyle(element, displayStyle);\n  if (display === displayInline || display === displayNone) return false;\n  return true;\n}\n\n/**\n * Returns an absolute positioned element's containing block, which is\n * considered to be the closest ancestor element that the target element's\n * positioning is relative to. Disclaimer: this only works as intended for\n * absolute positioned elements.\n *\n * @param {HTMLElement} element\n * @returns {(Document|Element)}\n */\nfunction getContainingBlock(element) {\n  // As long as the containing block is an element, static and not\n  // transformed, try to get the element's parent element and fallback to\n  // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n  var doc = document;\n  var res = element || doc;\n  while (res && res !== doc && getStyle(res, 'position') === 'static' && !isTransformed(res)) {\n    res = res.parentElement || doc;\n  }\n  return res;\n}\nvar offsetA = {};\nvar offsetB = {};\nvar offsetDiff = {};\n\n/**\n * Returns the element's document offset, which in practice means the vertical\n * and horizontal distance between the element's northwest corner and the\n * document's northwest corner. Note that this function always returns the same\n * object so be sure to read the data from it instead using it as a reference.\n *\n * @param {(Document|Element|Window)} element\n * @param {Object} [offsetData]\n *   - Optional data object where the offset data will be inserted to. If not\n *     provided a new object will be created for the return data.\n * @returns {Object}\n */\nfunction getOffset(element, offsetData) {\n  var offset = offsetData || {};\n  var rect;\n\n  // Set up return data.\n  offset.left = 0;\n  offset.top = 0;\n\n  // Document's offsets are always 0.\n  if (element === document) return offset;\n\n  // Add viewport scroll left/top to the respective offsets.\n  offset.left = window.pageXOffset || 0;\n  offset.top = window.pageYOffset || 0;\n\n  // Window's offsets are the viewport scroll left/top values.\n  if (element.self === window.self) return offset;\n\n  // Add element's client rects to the offsets.\n  rect = element.getBoundingClientRect();\n  offset.left += rect.left;\n  offset.top += rect.top;\n\n  // Exclude element's borders from the offset.\n  offset.left += getStyleAsFloat(element, 'border-left-width');\n  offset.top += getStyleAsFloat(element, 'border-top-width');\n  return offset;\n}\n\n/**\n * Calculate the offset difference two elements.\n *\n * @param {HTMLElement} elemA\n * @param {HTMLElement} elemB\n * @param {Boolean} [compareContainingBlocks=false]\n *   - When this is set to true the containing blocks of the provided elements\n *     will be used for calculating the difference. Otherwise the provided\n *     elements will be compared directly.\n * @returns {Object}\n */\nfunction getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n  offsetDiff.left = 0;\n  offsetDiff.top = 0;\n\n  // If elements are same let's return early.\n  if (elemA === elemB) return offsetDiff;\n\n  // Compare containing blocks if necessary.\n  if (compareContainingBlocks) {\n    elemA = getContainingBlock(elemA);\n    elemB = getContainingBlock(elemB);\n\n    // If containing blocks are identical, let's return early.\n    if (elemA === elemB) return offsetDiff;\n  }\n\n  // Finally, let's calculate the offset diff.\n  getOffset(elemA, offsetA);\n  getOffset(elemB, offsetB);\n  offsetDiff.left = offsetB.left - offsetA.left;\n  offsetDiff.top = offsetB.top - offsetA.top;\n  return offsetDiff;\n}\n\n/**\n * Check if overflow style value is scrollable.\n *\n * @param {String} value\n * @returns {Boolean}\n */\nfunction isScrollableOverflow(value) {\n  return value === 'auto' || value === 'scroll' || value === 'overlay';\n}\n\n/**\n * Check if an element is scrollable.\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\nfunction isScrollable(element) {\n  return isScrollableOverflow(getStyle(element, 'overflow')) || isScrollableOverflow(getStyle(element, 'overflow-x')) || isScrollableOverflow(getStyle(element, 'overflow-y'));\n}\n\n/**\n * Collect element's ancestors that are potentially scrollable elements. The\n * provided element is also also included in the check, meaning that if it is\n * scrollable it is added to the result array.\n *\n * @param {HTMLElement} element\n * @param {Array} [result]\n * @returns {Array}\n */\nfunction getScrollableAncestors(element, result) {\n  result = result || [];\n\n  // Find scroll parents.\n  while (element && element !== document) {\n    // If element is inside ShadowDOM let's get it's host node from the real\n    // DOM and continue looping.\n    if (element.getRootNode && element instanceof DocumentFragment) {\n      element = element.getRootNode().host;\n      continue;\n    }\n\n    // If element is scrollable let's add it to the scrollable list.\n    if (isScrollable(element)) {\n      result.push(element);\n    }\n    element = element.parentNode;\n  }\n\n  // Always add window to the results.\n  result.push(window);\n  return result;\n}\nvar translateValue = {};\nvar transformNone = 'none';\nvar rxMat3d = /^matrix3d/;\nvar rxMatTx = /([^,]*,){4}/;\nvar rxMat3dTx = /([^,]*,){12}/;\nvar rxNextItem = /[^,]*,/;\n\n/**\n * Returns the element's computed translateX and translateY values as a floats.\n * The returned object is always the same object and updated every time this\n * function is called.\n *\n * @param {HTMLElement} element\n * @returns {Object}\n */\nfunction getTranslate(element) {\n  translateValue.x = 0;\n  translateValue.y = 0;\n  var transform = getStyle(element, transformStyle);\n  if (!transform || transform === transformNone) {\n    return translateValue;\n  }\n\n  // Transform style can be in either matrix3d(...) or matrix(...).\n  var isMat3d = rxMat3d.test(transform);\n  var tX = transform.replace(isMat3d ? rxMat3dTx : rxMatTx, '');\n  var tY = tX.replace(rxNextItem, '');\n  translateValue.x = parseFloat(tX) || 0;\n  translateValue.y = parseFloat(tY) || 0;\n  return translateValue;\n}\n\n/**\n * Remove class from an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\nfunction removeClass(element, className) {\n  if (!className) return;\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    if (elementMatches(element, '.' + className)) {\n      element.className = (' ' + element.className + ' ').replace(' ' + className + ' ', ' ').trim();\n    }\n  }\n}\nvar IS_IOS = /^(iPad|iPhone|iPod)/.test(window.navigator.platform) || /^Mac/.test(window.navigator.platform) && window.navigator.maxTouchPoints > 1;\nvar START_PREDICATE_INACTIVE = 0;\nvar START_PREDICATE_PENDING = 1;\nvar START_PREDICATE_RESOLVED = 2;\nvar SCROLL_LISTENER_OPTIONS = hasPassiveEvents() ? {\n  passive: true\n} : false;\n\n/**\n * Bind touch interaction to an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDrag(item) {\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  this._item = item;\n  this._gridId = grid._id;\n  this._isDestroyed = false;\n  this._isMigrating = false;\n\n  // Start predicate data.\n  this._startPredicate = isFunction(settings.dragStartPredicate) ? settings.dragStartPredicate : ItemDrag.defaultStartPredicate;\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n  this._startPredicateResult = undefined;\n\n  // Data for drag sort predicate heuristics.\n  this._isSortNeeded = false;\n  this._sortTimer = undefined;\n  this._blockedSortIndex = null;\n  this._sortX1 = 0;\n  this._sortX2 = 0;\n  this._sortY1 = 0;\n  this._sortY2 = 0;\n\n  // Setup item's initial drag data.\n  this._reset();\n\n  // Bind the methods that needs binding.\n  this._preStartCheck = this._preStartCheck.bind(this);\n  this._preEndCheck = this._preEndCheck.bind(this);\n  this._onScroll = this._onScroll.bind(this);\n  this._prepareStart = this._prepareStart.bind(this);\n  this._applyStart = this._applyStart.bind(this);\n  this._prepareMove = this._prepareMove.bind(this);\n  this._applyMove = this._applyMove.bind(this);\n  this._prepareScroll = this._prepareScroll.bind(this);\n  this._applyScroll = this._applyScroll.bind(this);\n  this._handleSort = this._handleSort.bind(this);\n  this._handleSortDelayed = this._handleSortDelayed.bind(this);\n\n  // Get drag handle element.\n  this._handle = settings.dragHandle && element.querySelector(settings.dragHandle) || element;\n\n  // Init dragger.\n  this._dragger = new Dragger(this._handle, settings.dragCssProps);\n  this._dragger.on('start', this._preStartCheck);\n  this._dragger.on('move', this._preStartCheck);\n  this._dragger.on('cancel', this._preEndCheck);\n  this._dragger.on('end', this._preEndCheck);\n}\n\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @type {AutoScroller}\n */\nItemDrag.autoScroller = new AutoScroller();\n\n/**\n * Public static methods\n * *********************\n */\n\n/**\n * Default drag start predicate handler that handles anchor elements\n * gracefully. The return value of this function defines if the drag is\n * started, rejected or pending. When true is returned the dragging is started\n * and when false is returned the dragging is rejected. If nothing is returned\n * the predicate will be called again on the next drag movement.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} event\n * @param {Object} [options]\n *   - An optional options object which can be used to pass the predicate\n *     it's options manually. By default the predicate retrieves the options\n *     from the grid's settings.\n * @returns {(Boolean|undefined)}\n */\nItemDrag.defaultStartPredicate = function (item, event, options) {\n  var drag = item._drag;\n\n  // Make sure left button is pressed on mouse.\n  if (event.isFirst && event.srcEvent.button) {\n    return false;\n  }\n\n  // If the start event is trusted, non-cancelable and it's default action has\n  // not been prevented it is in most cases a sign that the gesture would be\n  // cancelled anyways right after it has started (e.g. starting drag while\n  // the page is scrolling).\n  if (!IS_IOS && event.isFirst && event.srcEvent.isTrusted === true && event.srcEvent.defaultPrevented === false && event.srcEvent.cancelable === false) {\n    return false;\n  }\n\n  // Final event logic. At this stage return value does not matter anymore,\n  // the predicate is either resolved or it's not and there's nothing to do\n  // about it. Here we just reset data and if the item element is a link\n  // we follow it (if there has only been slight movement).\n  if (event.isFinal) {\n    drag._finishStartPredicate(event);\n    return;\n  }\n\n  // Setup predicate data from options if not already set.\n  var predicate = drag._startPredicateData;\n  if (!predicate) {\n    var config = options || drag._getGrid()._settings.dragStartPredicate || {};\n    drag._startPredicateData = predicate = {\n      distance: Math.max(config.distance, 0) || 0,\n      delay: Math.max(config.delay, 0) || 0\n    };\n  }\n\n  // If delay is defined let's keep track of the latest event and initiate\n  // delay if it has not been done yet.\n  if (predicate.delay) {\n    predicate.event = event;\n    if (!predicate.delayTimer) {\n      predicate.delayTimer = window.setTimeout(function () {\n        predicate.delay = 0;\n        if (drag._resolveStartPredicate(predicate.event)) {\n          drag._forceResolveStartPredicate(predicate.event);\n          drag._resetStartPredicate();\n        }\n      }, predicate.delay);\n    }\n  }\n  return drag._resolveStartPredicate(event);\n};\n\n/**\n * Default drag sort predicate.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} [options]\n * @param {Number} [options.threshold=50]\n * @param {String} [options.action='move']\n * @returns {?Object}\n *   - Returns `null` if no valid index was found. Otherwise returns drag sort\n *     command.\n */\nItemDrag.defaultSortPredicate = function () {\n  var itemRect = {};\n  var targetRect = {};\n  var returnData = {};\n  var gridsArray = [];\n  var minThreshold = 1;\n  var maxThreshold = 100;\n  function getTargetGrid(item, rootGrid, threshold) {\n    var target = null;\n    var dragSort = rootGrid._settings.dragSort;\n    var bestScore = -1;\n    var gridScore;\n    var grids;\n    var grid;\n    var container;\n    var containerRect;\n    var left;\n    var top;\n    var right;\n    var bottom;\n    var i;\n\n    // Get potential target grids.\n    if (dragSort === true) {\n      gridsArray[0] = rootGrid;\n      grids = gridsArray;\n    } else if (isFunction(dragSort)) {\n      grids = dragSort.call(rootGrid, item);\n    }\n\n    // Return immediately if there are no grids.\n    if (!grids || !Array.isArray(grids) || !grids.length) {\n      return target;\n    }\n\n    // Loop through the grids and get the best match.\n    for (i = 0; i < grids.length; i++) {\n      grid = grids[i];\n\n      // Filter out all destroyed grids.\n      if (grid._isDestroyed) continue;\n\n      // Compute the grid's client rect an clamp the initial boundaries to\n      // viewport dimensions.\n      grid._updateBoundingRect();\n      left = Math.max(0, grid._left);\n      top = Math.max(0, grid._top);\n      right = Math.min(window.innerWidth, grid._right);\n      bottom = Math.min(window.innerHeight, grid._bottom);\n\n      // The grid might be inside one or more elements that clip it's visibility\n      // (e.g overflow scroll/hidden) so we want to find out the visible portion\n      // of the grid in the viewport and use that in our calculations.\n      container = grid._element.parentNode;\n      while (container && container !== document && container !== document.documentElement && container !== document.body) {\n        if (container.getRootNode && container instanceof DocumentFragment) {\n          container = container.getRootNode().host;\n          continue;\n        }\n        if (getStyle(container, 'overflow') !== 'visible') {\n          containerRect = container.getBoundingClientRect();\n          left = Math.max(left, containerRect.left);\n          top = Math.max(top, containerRect.top);\n          right = Math.min(right, containerRect.right);\n          bottom = Math.min(bottom, containerRect.bottom);\n        }\n        if (getStyle(container, 'position') === 'fixed') {\n          break;\n        }\n        container = container.parentNode;\n      }\n\n      // No need to go further if target rect does not have visible area.\n      if (left >= right || top >= bottom) continue;\n\n      // Check how much dragged element overlaps the container element.\n      targetRect.left = left;\n      targetRect.top = top;\n      targetRect.width = right - left;\n      targetRect.height = bottom - top;\n      gridScore = getIntersectionScore(itemRect, targetRect);\n\n      // Check if this grid is the best match so far.\n      if (gridScore > threshold && gridScore > bestScore) {\n        bestScore = gridScore;\n        target = grid;\n      }\n    }\n\n    // Always reset grids array.\n    gridsArray.length = 0;\n    return target;\n  }\n  return function (item, options) {\n    var drag = item._drag;\n    var rootGrid = drag._getGrid();\n\n    // Get drag sort predicate settings.\n    var sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;\n    var sortAction = options && options.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n    var migrateAction = options && options.migrateAction === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n\n    // Sort threshold must be a positive number capped to a max value of 100. If\n    // that's not the case this function will not work correctly. So let's clamp\n    // the threshold just in case.\n    sortThreshold = Math.min(Math.max(sortThreshold, minThreshold), maxThreshold);\n\n    // Populate item rect data.\n    itemRect.width = item._width;\n    itemRect.height = item._height;\n    itemRect.left = drag._clientX;\n    itemRect.top = drag._clientY;\n\n    // Calculate the target grid.\n    var grid = getTargetGrid(item, rootGrid, sortThreshold);\n\n    // Return early if we found no grid container element that overlaps the\n    // dragged item enough.\n    if (!grid) return null;\n    var isMigration = item.getGrid() !== grid;\n    var gridOffsetLeft = 0;\n    var gridOffsetTop = 0;\n    var matchScore = 0;\n    var matchIndex = -1;\n    var hasValidTargets = false;\n    var target;\n    var score;\n    var i;\n\n    // If item is moved within it's originating grid adjust item's left and\n    // top props. Otherwise if item is moved to/within another grid get the\n    // container element's offset (from the element's content edge).\n    if (grid === rootGrid) {\n      itemRect.left = drag._gridX + item._marginLeft;\n      itemRect.top = drag._gridY + item._marginTop;\n    } else {\n      grid._updateBorders(1, 0, 1, 0);\n      gridOffsetLeft = grid._left + grid._borderLeft;\n      gridOffsetTop = grid._top + grid._borderTop;\n    }\n\n    // Loop through the target grid items and try to find the best match.\n    for (i = 0; i < grid._items.length; i++) {\n      target = grid._items[i];\n\n      // If the target item is not active or the target item is the dragged\n      // item let's skip to the next item.\n      if (!target._isActive || target === item) {\n        continue;\n      }\n\n      // Mark the grid as having valid target items.\n      hasValidTargets = true;\n\n      // Calculate the target's overlap score with the dragged item.\n      targetRect.width = target._width;\n      targetRect.height = target._height;\n      targetRect.left = target._left + target._marginLeft + gridOffsetLeft;\n      targetRect.top = target._top + target._marginTop + gridOffsetTop;\n      score = getIntersectionScore(itemRect, targetRect);\n\n      // Update best match index and score if the target's overlap score with\n      // the dragged item is higher than the current best match score.\n      if (score > matchScore) {\n        matchIndex = i;\n        matchScore = score;\n      }\n    }\n\n    // If there is no valid match and the dragged item is being moved into\n    // another grid we need to do some guess work here. If there simply are no\n    // valid targets (which means that the dragged item will be the only active\n    // item in the new grid) we can just add it as the first item. If we have\n    // valid items in the new grid and the dragged item is overlapping one or\n    // more of the items in the new grid let's make an exception with the\n    // threshold and just pick the item which the dragged item is overlapping\n    // most. However, if the dragged item is not overlapping any of the valid\n    // items in the new grid let's position it as the last item in the grid.\n    if (isMigration && matchScore < sortThreshold) {\n      matchIndex = hasValidTargets ? matchIndex : 0;\n      matchScore = sortThreshold;\n    }\n\n    // Check if the best match overlaps enough to justify a placement switch.\n    if (matchScore >= sortThreshold) {\n      returnData.grid = grid;\n      returnData.index = matchIndex;\n      returnData.action = isMigration ? migrateAction : sortAction;\n      return returnData;\n    }\n    return null;\n  };\n}();\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Abort dragging and reset drag data.\n *\n * @public\n */\nItemDrag.prototype.stop = function () {\n  if (!this._isActive) return;\n\n  // If the item is being dropped into another grid, finish it up and return\n  // immediately.\n  if (this._isMigrating) {\n    this._finishMigration();\n    return;\n  }\n  var item = this._item;\n  var itemId = item._id;\n\n  // Stop auto-scroll.\n  ItemDrag.autoScroller.removeItem(item);\n\n  // Cancel queued ticks.\n  cancelDragStartTick(itemId);\n  cancelDragMoveTick(itemId);\n  cancelDragScrollTick(itemId);\n\n  // Cancel sort procedure.\n  this._cancelSort();\n  if (this._isStarted) {\n    // Remove scroll listeners.\n    this._unbindScrollListeners();\n    var element = item._element;\n    var grid = this._getGrid();\n    var draggingClass = grid._settings.itemDraggingClass;\n\n    // Append item element to the container if it's not it's child. Also make\n    // sure the translate values are adjusted to account for the DOM shift.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n      item._setTranslate(this._gridX, this._gridY);\n\n      // We need to do forced reflow to make sure the dragging class is removed\n      // gracefully.\n      // eslint-disable-next-line\n      if (draggingClass) element.clientWidth;\n    }\n\n    // Remove dragging class.\n    removeClass(element, draggingClass);\n  }\n\n  // Reset drag data.\n  this._reset();\n};\n\n/**\n * Manually trigger drag sort. This is only needed for special edge cases where\n * e.g. you have disabled sort and want to trigger a sort right after enabling\n * it (and don't want to wait for the next move/scroll event).\n *\n * @private\n * @param {Boolean} [force=false]\n */\nItemDrag.prototype.sort = function (force) {\n  var item = this._item;\n  if (this._isActive && item._isActive && this._dragMoveEvent) {\n    if (force === true) {\n      this._handleSort();\n    } else {\n      addDragSortTick(item._id, this._handleSort);\n    }\n  }\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemDrag.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n  this._dragger.destroy();\n  ItemDrag.autoScroller.removeItem(this._item);\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Get Grid instance.\n *\n * @private\n * @returns {?Grid}\n */\nItemDrag.prototype._getGrid = function () {\n  return GRID_INSTANCES[this._gridId] || null;\n};\n\n/**\n * Setup/reset drag data.\n *\n * @private\n */\nItemDrag.prototype._reset = function () {\n  this._isActive = false;\n  this._isStarted = false;\n\n  // The dragged item's container element.\n  this._container = null;\n\n  // The dragged item's containing block.\n  this._containingBlock = null;\n\n  // Drag/scroll event data.\n  this._dragStartEvent = null;\n  this._dragMoveEvent = null;\n  this._dragPrevMoveEvent = null;\n  this._scrollEvent = null;\n\n  // All the elements which need to be listened for scroll events during\n  // dragging.\n  this._scrollers = [];\n\n  // The current translateX/translateY position.\n  this._left = 0;\n  this._top = 0;\n\n  // Dragged element's current position within the grid.\n  this._gridX = 0;\n  this._gridY = 0;\n\n  // Dragged element's current offset from window's northwest corner. Does\n  // not account for element's margins.\n  this._clientX = 0;\n  this._clientY = 0;\n\n  // Keep track of the clientX/Y diff for scrolling.\n  this._scrollDiffX = 0;\n  this._scrollDiffY = 0;\n\n  // Keep track of the clientX/Y diff for moving.\n  this._moveDiffX = 0;\n  this._moveDiffY = 0;\n\n  // Offset difference between the dragged element's temporary drag\n  // container and it's original container.\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n\n/**\n * Bind drag scroll handlers to all scrollable ancestor elements of the\n * dragged element and the drag container element.\n *\n * @private\n */\nItemDrag.prototype._bindScrollListeners = function () {\n  var gridContainer = this._getGrid()._element;\n  var dragContainer = this._container;\n  var scrollers = this._scrollers;\n  var gridScrollers;\n  var i;\n\n  // Get dragged element's scrolling parents.\n  scrollers.length = 0;\n  getScrollableAncestors(this._item._element.parentNode, scrollers);\n\n  // If drag container is defined and it's not the same element as grid\n  // container then we need to add the grid container and it's scroll parents\n  // to the elements which are going to be listener for scroll events.\n  if (dragContainer !== gridContainer) {\n    gridScrollers = [];\n    getScrollableAncestors(gridContainer, gridScrollers);\n    for (i = 0; i < gridScrollers.length; i++) {\n      if (scrollers.indexOf(gridScrollers[i]) < 0) {\n        scrollers.push(gridScrollers[i]);\n      }\n    }\n  }\n\n  // Bind scroll listeners.\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n};\n\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n */\nItemDrag.prototype._unbindScrollListeners = function () {\n  var scrollers = this._scrollers;\n  var i;\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n  scrollers.length = 0;\n};\n\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n * @param {Object} event\n * @returns {Boolean}\n */\nItemDrag.prototype._resolveStartPredicate = function (event) {\n  var predicate = this._startPredicateData;\n  if (event.distance < predicate.distance || predicate.delay) return;\n  this._resetStartPredicate();\n  return true;\n};\n\n/**\n * Forcefully resolve drag start predicate.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._forceResolveStartPredicate = function (event) {\n  if (!this._isDestroyed && this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateState = START_PREDICATE_RESOLVED;\n    this._onStart(event);\n  }\n};\n\n/**\n * Finalize start predicate.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._finishStartPredicate = function (event) {\n  var element = this._item._element;\n\n  // Check if this is a click (very subjective heuristics).\n  var isClick = Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200;\n\n  // Reset predicate.\n  this._resetStartPredicate();\n\n  // If the gesture can be interpreted as click let's try to open the element's\n  // href url (if it is an anchor element).\n  if (isClick) openAnchorHref(element);\n};\n\n/**\n * Reset drag sort heuristics.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n */\nItemDrag.prototype._resetHeuristics = function (x, y) {\n  this._blockedSortIndex = null;\n  this._sortX1 = this._sortX2 = x;\n  this._sortY1 = this._sortY2 = y;\n};\n\n/**\n * Run heuristics and return true if overlap check can be performed, and false\n * if it can not.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n * @returns {Boolean}\n */\nItemDrag.prototype._checkHeuristics = function (x, y) {\n  var settings = this._getGrid()._settings.dragSortHeuristics;\n  var minDist = settings.minDragDistance;\n\n  // Skip heuristics if not needed.\n  if (minDist <= 0) {\n    this._blockedSortIndex = null;\n    return true;\n  }\n  var diffX = x - this._sortX2;\n  var diffY = y - this._sortY2;\n\n  // If we can't do proper bounce back check make sure that the blocked index\n  // is not set.\n  var canCheckBounceBack = minDist > 3 && settings.minBounceBackAngle > 0;\n  if (!canCheckBounceBack) {\n    this._blockedSortIndex = null;\n  }\n  if (Math.abs(diffX) > minDist || Math.abs(diffY) > minDist) {\n    // Reset blocked index if angle changed enough. This check requires a\n    // minimum value of 3 for minDragDistance to function properly.\n    if (canCheckBounceBack) {\n      var angle = Math.atan2(diffX, diffY);\n      var prevAngle = Math.atan2(this._sortX2 - this._sortX1, this._sortY2 - this._sortY1);\n      var deltaAngle = Math.atan2(Math.sin(angle - prevAngle), Math.cos(angle - prevAngle));\n      if (Math.abs(deltaAngle) > settings.minBounceBackAngle) {\n        this._blockedSortIndex = null;\n      }\n    }\n\n    // Update points.\n    this._sortX1 = this._sortX2;\n    this._sortY1 = this._sortY2;\n    this._sortX2 = x;\n    this._sortY2 = y;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Reset for default drag start predicate function.\n *\n * @private\n */\nItemDrag.prototype._resetStartPredicate = function () {\n  var predicate = this._startPredicateData;\n  if (predicate) {\n    if (predicate.delayTimer) {\n      predicate.delayTimer = window.clearTimeout(predicate.delayTimer);\n    }\n    this._startPredicateData = null;\n  }\n};\n\n/**\n * Handle the sorting procedure. Manage drag sort heuristics/interval and\n * check overlap when necessary.\n *\n * @private\n */\nItemDrag.prototype._handleSort = function () {\n  if (!this._isActive) return;\n  var settings = this._getGrid()._settings;\n\n  // No sorting when drag sort is disabled. Also, account for the scenario where\n  // dragSort is temporarily disabled during drag procedure so we need to reset\n  // sort timer heuristics state too.\n  if (!settings.dragSort || !settings.dragAutoScroll.sortDuringScroll && ItemDrag.autoScroller.isItemScrolling(this._item)) {\n    this._sortX1 = this._sortX2 = this._gridX;\n    this._sortY1 = this._sortY2 = this._gridY;\n    // We set this to true intentionally so that overlap check would be\n    // triggered as soon as possible after sort becomes enabled again.\n    this._isSortNeeded = true;\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n    return;\n  }\n\n  // If sorting is enabled we always need to run the heuristics check to keep\n  // the tracked coordinates updated. We also allow an exception when the sort\n  // timer is finished because the heuristics are intended to prevent overlap\n  // checks based on the dragged element's immediate movement and a delayed\n  // overlap check is valid if it comes through, because it was valid when it\n  // was invoked.\n  var shouldSort = this._checkHeuristics(this._gridX, this._gridY);\n  if (!this._isSortNeeded && !shouldSort) return;\n  var sortInterval = settings.dragSortHeuristics.sortInterval;\n  if (sortInterval <= 0 || this._isSortNeeded) {\n    this._isSortNeeded = false;\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n    this._checkOverlap();\n  } else if (this._sortTimer === undefined) {\n    this._sortTimer = window.setTimeout(this._handleSortDelayed, sortInterval);\n  }\n};\n\n/**\n * Delayed sort handler.\n *\n * @private\n */\nItemDrag.prototype._handleSortDelayed = function () {\n  this._isSortNeeded = true;\n  this._sortTimer = undefined;\n  addDragSortTick(this._item._id, this._handleSort);\n};\n\n/**\n * Cancel and reset sort procedure.\n *\n * @private\n */\nItemDrag.prototype._cancelSort = function () {\n  this._isSortNeeded = false;\n  if (this._sortTimer !== undefined) {\n    this._sortTimer = window.clearTimeout(this._sortTimer);\n  }\n  cancelDragSortTick(this._item._id);\n};\n\n/**\n * Handle the ending of the drag procedure for sorting.\n *\n * @private\n */\nItemDrag.prototype._finishSort = function () {\n  var isSortEnabled = this._getGrid()._settings.dragSort;\n  var needsFinalCheck = isSortEnabled && (this._isSortNeeded || this._sortTimer !== undefined);\n  this._cancelSort();\n  if (needsFinalCheck) this._checkOverlap();\n};\n\n/**\n * Check (during drag) if an item is overlapping other items and based on\n * the configuration layout the items.\n *\n * @private\n */\nItemDrag.prototype._checkOverlap = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  var settings = this._getGrid()._settings;\n  var result;\n  var currentGrid;\n  var currentIndex;\n  var targetGrid;\n  var targetIndex;\n  var targetItem;\n  var sortAction;\n  var isMigration;\n\n  // Get overlap check result.\n  if (isFunction(settings.dragSortPredicate)) {\n    result = settings.dragSortPredicate(item, this._dragMoveEvent);\n  } else {\n    result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);\n  }\n\n  // Let's make sure the result object has a valid index before going further.\n  if (!result || typeof result.index !== 'number') return;\n  sortAction = result.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n  currentGrid = item.getGrid();\n  targetGrid = result.grid || currentGrid;\n  isMigration = currentGrid !== targetGrid;\n  currentIndex = currentGrid._items.indexOf(item);\n  targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration && sortAction === ACTION_MOVE ? 1 : 0);\n\n  // Prevent position bounce.\n  if (!isMigration && targetIndex === this._blockedSortIndex) {\n    return;\n  }\n\n  // If the item was moved within it's current grid.\n  if (!isMigration) {\n    // Make sure the target index is not the current index.\n    if (currentIndex !== targetIndex) {\n      this._blockedSortIndex = currentIndex;\n\n      // Do the sort.\n      (sortAction === ACTION_SWAP ? arraySwap : arrayMove)(currentGrid._items, currentIndex, targetIndex);\n\n      // Emit move event.\n      if (currentGrid._hasListeners(EVENT_MOVE)) {\n        currentGrid._emit(EVENT_MOVE, {\n          item: item,\n          fromIndex: currentIndex,\n          toIndex: targetIndex,\n          action: sortAction\n        });\n      }\n\n      // Layout the grid.\n      currentGrid.layout();\n    }\n  }\n\n  // If the item was moved to another grid.\n  else {\n    this._blockedSortIndex = null;\n\n    // Let's fetch the target item when it's still in it's original index.\n    targetItem = targetGrid._items[targetIndex];\n\n    // Emit beforeSend event.\n    if (currentGrid._hasListeners(EVENT_BEFORE_SEND)) {\n      currentGrid._emit(EVENT_BEFORE_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    // Emit beforeReceive event.\n    if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n      targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    // Update item's grid id reference.\n    item._gridId = targetGrid._id;\n\n    // Update drag instance's migrating indicator.\n    this._isMigrating = item._gridId !== this._gridId;\n\n    // Move item instance from current grid to target grid.\n    currentGrid._items.splice(currentIndex, 1);\n    arrayInsert(targetGrid._items, item, targetIndex);\n\n    // Reset sort data.\n    item._sortData = null;\n\n    // Emit send event.\n    if (currentGrid._hasListeners(EVENT_SEND)) {\n      currentGrid._emit(EVENT_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    // Emit receive event.\n    if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n      targetGrid._emit(EVENT_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    // If the sort action is \"swap\" let's respect it and send the target item\n    // (if it exists) from the target grid to the originating grid. This process\n    // is done on purpose after the dragged item placed within the target grid\n    // so that we can keep this implementation as simple as possible utilizing\n    // the existing API.\n    if (sortAction === ACTION_SWAP && targetItem && targetItem.isActive()) {\n      // Sanity check to make sure that the target item is still part of the\n      // target grid. It could have been manipulated in the event handlers.\n      if (targetGrid._items.indexOf(targetItem) > -1) {\n        targetGrid.send(targetItem, currentGrid, currentIndex, {\n          appendTo: this._container || document.body,\n          layoutSender: false,\n          layoutReceiver: false\n        });\n      }\n    }\n\n    // Layout both grids.\n    currentGrid.layout();\n    targetGrid.layout();\n  }\n};\n\n/**\n * If item is dragged into another grid, finish the migration process\n * gracefully.\n *\n * @private\n */\nItemDrag.prototype._finishMigration = function () {\n  var item = this._item;\n  var release = item._dragRelease;\n  var element = item._element;\n  var isActive = item._isActive;\n  var targetGrid = item.getGrid();\n  var targetGridElement = targetGrid._element;\n  var targetSettings = targetGrid._settings;\n  var targetContainer = targetSettings.dragContainer || targetGridElement;\n  var currentSettings = this._getGrid()._settings;\n  var currentContainer = element.parentNode;\n  var currentVisClass = isActive ? currentSettings.itemVisibleClass : currentSettings.itemHiddenClass;\n  var nextVisClass = isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n  var translate;\n  var offsetDiff;\n\n  // Destroy current drag. Note that we need to set the migrating flag to\n  // false first, because otherwise we create an infinite loop between this\n  // and the drag.stop() method.\n  this._isMigrating = false;\n  this.destroy();\n\n  // Update item class.\n  if (currentSettings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, currentSettings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  }\n\n  // Update visibility class.\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  }\n\n  // Move the item inside the target container if it's different than the\n  // current container.\n  if (targetContainer !== currentContainer) {\n    targetContainer.appendChild(element);\n    offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n    translate = getTranslate(element);\n    translate.x -= offsetDiff.left;\n    translate.y -= offsetDiff.top;\n  }\n\n  // Update item's cached dimensions.\n  item._refreshDimensions();\n\n  // Calculate the offset difference between target's drag container (if any)\n  // and actual grid container element. We save it later for the release\n  // process.\n  offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n  release._containerDiffX = offsetDiff.left;\n  release._containerDiffY = offsetDiff.top;\n\n  // Recreate item's drag handler.\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n  // Adjust the position of the item element if it was moved from a container\n  // to another.\n  if (targetContainer !== currentContainer) {\n    item._setTranslate(translate.x, translate.y);\n  }\n\n  // Update child element's styles to reflect the current visibility state.\n  item._visibility.setStyles(isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\n\n  // Start the release.\n  release.start();\n};\n\n/**\n * Drag pre-start handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._preStartCheck = function (event) {\n  // Let's activate drag start predicate state.\n  if (this._startPredicateState === START_PREDICATE_INACTIVE) {\n    this._startPredicateState = START_PREDICATE_PENDING;\n  }\n\n  // If predicate is pending try to resolve it.\n  if (this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateResult = this._startPredicate(this._item, event);\n    if (this._startPredicateResult === true) {\n      this._startPredicateState = START_PREDICATE_RESOLVED;\n      this._onStart(event);\n    } else if (this._startPredicateResult === false) {\n      this._resetStartPredicate(event);\n      this._dragger._reset();\n      this._startPredicateState = START_PREDICATE_INACTIVE;\n    }\n  }\n\n  // Otherwise if predicate is resolved and drag is active, move the item.\n  else if (this._startPredicateState === START_PREDICATE_RESOLVED && this._isActive) {\n    this._onMove(event);\n  }\n};\n\n/**\n * Drag pre-end handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._preEndCheck = function (event) {\n  var isResolved = this._startPredicateState === START_PREDICATE_RESOLVED;\n\n  // Do final predicate check to allow user to unbind stuff for the current\n  // drag procedure within the predicate callback. The return value of this\n  // check will have no effect to the state of the predicate.\n  this._startPredicate(this._item, event);\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n  if (!isResolved || !this._isActive) return;\n  if (this._isStarted) {\n    this._onEnd(event);\n  } else {\n    this.stop();\n  }\n};\n\n/**\n * Drag start handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onStart = function (event) {\n  var item = this._item;\n  if (!item._isActive) return;\n  this._isActive = true;\n  this._dragStartEvent = event;\n  ItemDrag.autoScroller.addItem(item);\n  addDragStartTick(item._id, this._prepareStart, this._applyStart);\n};\n\n/**\n * Prepare item to be dragged.\n *\n * @private\n *  ItemDrag.prototype\n */\nItemDrag.prototype._prepareStart = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  var element = item._element;\n  var grid = this._getGrid();\n  var settings = grid._settings;\n  var gridContainer = grid._element;\n  var dragContainer = settings.dragContainer || gridContainer;\n  var containingBlock = getContainingBlock(dragContainer);\n  var translate = getTranslate(element);\n  var elementRect = element.getBoundingClientRect();\n  var hasDragContainer = dragContainer !== gridContainer;\n  this._container = dragContainer;\n  this._containingBlock = containingBlock;\n  this._clientX = elementRect.left;\n  this._clientY = elementRect.top;\n  this._left = this._gridX = translate.x;\n  this._top = this._gridY = translate.y;\n  this._scrollDiffX = this._scrollDiffY = 0;\n  this._moveDiffX = this._moveDiffY = 0;\n  this._resetHeuristics(this._gridX, this._gridY);\n\n  // If a specific drag container is set and it is different from the\n  // grid's container element we store the offset between containers.\n  if (hasDragContainer) {\n    var offsetDiff = getOffsetDiff(containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  }\n};\n\n/**\n * Start drag for the item.\n *\n * @private\n */\nItemDrag.prototype._applyStart = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  var grid = this._getGrid();\n  var element = item._element;\n  var release = item._dragRelease;\n  var migrate = item._migrate;\n  var hasDragContainer = this._container !== grid._element;\n  if (item.isPositioning()) {\n    item._layout.stop(true, this._left, this._top);\n  }\n  if (migrate._isActive) {\n    this._left -= migrate._containerDiffX;\n    this._top -= migrate._containerDiffY;\n    this._gridX -= migrate._containerDiffX;\n    this._gridY -= migrate._containerDiffY;\n    migrate.stop(true, this._left, this._top);\n  }\n  if (item.isReleasing()) {\n    release._reset();\n  }\n  if (grid._settings.dragPlaceholder.enabled) {\n    item._dragPlaceholder.create();\n  }\n  this._isStarted = true;\n  grid._emit(EVENT_DRAG_INIT, item, this._dragStartEvent);\n  if (hasDragContainer) {\n    // If the dragged element is a child of the drag container all we need to\n    // do is setup the relative drag position data.\n    if (element.parentNode === this._container) {\n      this._gridX -= this._containerDiffX;\n      this._gridY -= this._containerDiffY;\n    }\n    // Otherwise we need to append the element inside the correct container,\n    // setup the actual drag position data and adjust the element's translate\n    // values to account for the DOM position shift.\n    else {\n      this._left += this._containerDiffX;\n      this._top += this._containerDiffY;\n      this._container.appendChild(element);\n      item._setTranslate(this._left, this._top);\n    }\n  }\n  addClass(element, grid._settings.itemDraggingClass);\n  this._bindScrollListeners();\n  grid._emit(EVENT_DRAG_START, item, this._dragStartEvent);\n};\n\n/**\n * Drag move handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onMove = function (event) {\n  var item = this._item;\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n  this._dragMoveEvent = event;\n  addDragMoveTick(item._id, this._prepareMove, this._applyMove);\n  addDragSortTick(item._id, this._handleSort);\n};\n\n/**\n * Prepare dragged item for moving.\n *\n * @private\n */\nItemDrag.prototype._prepareMove = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  var settings = this._getGrid()._settings;\n  var axis = settings.dragAxis;\n  var nextEvent = this._dragMoveEvent;\n  var prevEvent = this._dragPrevMoveEvent || this._dragStartEvent || nextEvent;\n\n  // Update horizontal position data.\n  if (axis !== 'y') {\n    var moveDiffX = nextEvent.clientX - prevEvent.clientX;\n    this._left = this._left - this._moveDiffX + moveDiffX;\n    this._gridX = this._gridX - this._moveDiffX + moveDiffX;\n    this._clientX = this._clientX - this._moveDiffX + moveDiffX;\n    this._moveDiffX = moveDiffX;\n  }\n\n  // Update vertical position data.\n  if (axis !== 'x') {\n    var moveDiffY = nextEvent.clientY - prevEvent.clientY;\n    this._top = this._top - this._moveDiffY + moveDiffY;\n    this._gridY = this._gridY - this._moveDiffY + moveDiffY;\n    this._clientY = this._clientY - this._moveDiffY + moveDiffY;\n    this._moveDiffY = moveDiffY;\n  }\n  this._dragPrevMoveEvent = nextEvent;\n};\n\n/**\n * Apply movement to dragged item.\n *\n * @private\n */\nItemDrag.prototype._applyMove = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  this._moveDiffX = this._moveDiffY = 0;\n  item._setTranslate(this._left, this._top);\n  this._getGrid()._emit(EVENT_DRAG_MOVE, item, this._dragMoveEvent);\n  ItemDrag.autoScroller.updateItem(item);\n};\n\n/**\n * Drag scroll handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onScroll = function (event) {\n  var item = this._item;\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n  this._scrollEvent = event;\n  addDragScrollTick(item._id, this._prepareScroll, this._applyScroll);\n  addDragSortTick(item._id, this._handleSort);\n};\n\n/**\n * Prepare dragged item for scrolling.\n *\n * @private\n */\nItemDrag.prototype._prepareScroll = function () {\n  if (!this._isActive) return;\n\n  // If item is not active do nothing.\n  var item = this._item;\n  if (!item._isActive) return;\n  var element = item._element;\n  var grid = this._getGrid();\n  var gridContainer = grid._element;\n  var rect = element.getBoundingClientRect();\n\n  // Update container diff.\n  if (this._container !== gridContainer) {\n    var offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  }\n\n  // Update horizontal position data.\n  var scrollDiffX = this._clientX - this._moveDiffX - rect.left;\n  this._left = this._left - this._scrollDiffX + scrollDiffX;\n  this._scrollDiffX = scrollDiffX;\n\n  // Update vertical position data.\n  var scrollDiffY = this._clientY - this._moveDiffY - rect.top;\n  this._top = this._top - this._scrollDiffY + scrollDiffY;\n  this._scrollDiffY = scrollDiffY;\n\n  // Update grid position.\n  this._gridX = this._left - this._containerDiffX;\n  this._gridY = this._top - this._containerDiffY;\n};\n\n/**\n * Apply scroll to dragged item.\n *\n * @private\n */\nItemDrag.prototype._applyScroll = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  this._scrollDiffX = this._scrollDiffY = 0;\n  item._setTranslate(this._left, this._top);\n  this._getGrid()._emit(EVENT_DRAG_SCROLL, item, this._scrollEvent);\n};\n\n/**\n * Drag end handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onEnd = function (event) {\n  var item = this._item;\n  var element = item._element;\n  var grid = this._getGrid();\n  var settings = grid._settings;\n  var release = item._dragRelease;\n\n  // If item is not active, reset drag.\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  // Cancel queued ticks.\n  cancelDragStartTick(item._id);\n  cancelDragMoveTick(item._id);\n  cancelDragScrollTick(item._id);\n\n  // Finish sort procedure (does final overlap check if needed).\n  this._finishSort();\n\n  // Remove scroll listeners.\n  this._unbindScrollListeners();\n\n  // Setup release data.\n  release._containerDiffX = this._containerDiffX;\n  release._containerDiffY = this._containerDiffY;\n\n  // Reset drag data.\n  this._reset();\n\n  // Remove drag class name from element.\n  removeClass(element, settings.itemDraggingClass);\n\n  // Stop auto-scroll.\n  ItemDrag.autoScroller.removeItem(item);\n\n  // Emit dragEnd event.\n  grid._emit(EVENT_DRAG_END, item, event);\n\n  // Finish up the migration process or start the release process.\n  this._isMigrating ? this._finishMigration() : release.start();\n};\n\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Check if an element is an anchor element and open the href url if possible.\n *\n * @param {HTMLElement} element\n */\nfunction openAnchorHref(element) {\n  // Make sure the element is anchor element.\n  if (element.tagName.toLowerCase() !== 'a') return;\n\n  // Get href and make sure it exists.\n  var href = element.getAttribute('href');\n  if (!href) return;\n\n  // Finally let's navigate to the link href.\n  var target = element.getAttribute('target');\n  if (target && target !== '_self') {\n    window.open(href, target);\n  } else {\n    window.location.href = href;\n  }\n}\n\n/**\n * Get current values of the provided styles definition object or array.\n *\n * @param {HTMLElement} element\n * @param {(Object|Array} styles\n * @return {Object}\n */\nfunction getCurrentStyles(element, styles) {\n  var result = {};\n  var prop, i;\n  if (Array.isArray(styles)) {\n    for (i = 0; i < styles.length; i++) {\n      prop = styles[i];\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  } else {\n    for (prop in styles) {\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  }\n  return result;\n}\nvar unprefixRegEx = /^(webkit|moz|ms|o|Webkit|Moz|MS|O)(?=[A-Z])/;\nvar cache = {};\n\n/**\n * Remove any potential vendor prefixes from a property name.\n *\n * @param {String} prop\n * @returns {String}\n */\nfunction getUnprefixedPropName(prop) {\n  var result = cache[prop];\n  if (result) return result;\n  result = prop.replace(unprefixRegEx, '');\n  if (result !== prop) {\n    result = result[0].toLowerCase() + result.slice(1);\n  }\n  cache[prop] = result;\n  return result;\n}\nvar nativeCode = '[native code]';\n\n/**\n * Check if a value (e.g. a method or constructor) is native code. Good for\n * detecting when a polyfill is used and when not.\n *\n * @param {*} feat\n * @returns {Boolean}\n */\nfunction isNative(feat) {\n  var S = window.Symbol;\n  return !!(feat && isFunction(S) && isFunction(S.toString) && S(feat).toString().indexOf(nativeCode) > -1);\n}\n\n/**\n * Set inline styles to an element.\n *\n * @param {HTMLElement} element\n * @param {Object} styles\n */\nfunction setStyles(element, styles) {\n  for (var prop in styles) {\n    element.style[prop] = styles[prop];\n  }\n}\nvar HAS_WEB_ANIMATIONS = !!(Element && isFunction(Element.prototype.animate));\nvar HAS_NATIVE_WEB_ANIMATIONS = !!(Element && isNative(Element.prototype.animate));\n\n/**\n * Item animation handler powered by Web Animations API.\n *\n * @class\n * @param {HTMLElement} element\n */\nfunction Animator(element) {\n  this._element = element;\n  this._animation = null;\n  this._duration = 0;\n  this._easing = '';\n  this._callback = null;\n  this._props = [];\n  this._values = [];\n  this._isDestroyed = false;\n  this._onFinish = this._onFinish.bind(this);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start instance's animation. Automatically stops current animation if it is\n * running.\n *\n * @public\n * @param {Object} propsFrom\n * @param {Object} propsTo\n * @param {Object} [options]\n * @param {Number} [options.duration=300]\n * @param {String} [options.easing='ease']\n * @param {Function} [options.onFinish]\n */\nAnimator.prototype.start = function (propsFrom, propsTo, options) {\n  if (this._isDestroyed) return;\n  var element = this._element;\n  var opts = options || {};\n\n  // If we don't have web animations available let's not animate.\n  if (!HAS_WEB_ANIMATIONS) {\n    setStyles(element, propsTo);\n    this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n    this._onFinish();\n    return;\n  }\n  var animation = this._animation;\n  var currentProps = this._props;\n  var currentValues = this._values;\n  var duration = opts.duration || 300;\n  var easing = opts.easing || 'ease';\n  var cancelAnimation = false;\n  var propName, propCount, propIndex;\n\n  // If we have an existing animation running, let's check if it needs to be\n  // cancelled or if it can continue running.\n  if (animation) {\n    propCount = 0;\n\n    // Cancel animation if duration or easing has changed.\n    if (duration !== this._duration || easing !== this._easing) {\n      cancelAnimation = true;\n    }\n\n    // Check if the requested animation target props and values match with the\n    // current props and values.\n    if (!cancelAnimation) {\n      for (propName in propsTo) {\n        ++propCount;\n        propIndex = currentProps.indexOf(propName);\n        if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {\n          cancelAnimation = true;\n          break;\n        }\n      }\n\n      // Check if the target props count matches current props count. This is\n      // needed for the edge case scenario where target props contain the same\n      // styles as current props, but the current props have some additional\n      // props.\n      if (propCount !== currentProps.length) {\n        cancelAnimation = true;\n      }\n    }\n  }\n\n  // Cancel animation (if required).\n  if (cancelAnimation) animation.cancel();\n\n  // Store animation callback.\n  this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n\n  // If we have a running animation that does not need to be cancelled, let's\n  // call it a day here and let it run.\n  if (animation && !cancelAnimation) return;\n\n  // Store target props and values to instance.\n  currentProps.length = currentValues.length = 0;\n  for (propName in propsTo) {\n    currentProps.push(propName);\n    currentValues.push(propsTo[propName]);\n  }\n\n  // Start the animation. We need to provide unprefixed property names to the\n  // Web Animations polyfill if it is being used. If we have native Web\n  // Animations available we need to provide prefixed properties instead.\n  this._duration = duration;\n  this._easing = easing;\n  this._animation = element.animate([createFrame(propsFrom, HAS_NATIVE_WEB_ANIMATIONS), createFrame(propsTo, HAS_NATIVE_WEB_ANIMATIONS)], {\n    duration: duration,\n    easing: easing\n  });\n  this._animation.onfinish = this._onFinish;\n\n  // Set the end styles. This makes sure that the element stays at the end\n  // values after animation is finished.\n  setStyles(element, propsTo);\n};\n\n/**\n * Stop instance's current animation if running.\n *\n * @public\n */\nAnimator.prototype.stop = function () {\n  if (this._isDestroyed || !this._animation) return;\n  this._animation.cancel();\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n};\n\n/**\n * Read the current values of the element's animated styles from the DOM.\n *\n * @public\n * @return {Object}\n */\nAnimator.prototype.getCurrentStyles = function () {\n  return getCurrentStyles(element, currentProps);\n};\n\n/**\n * Check if the item is being animated currently.\n *\n * @public\n * @return {Boolean}\n */\nAnimator.prototype.isAnimating = function () {\n  return !!this._animation;\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nAnimator.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n  this._element = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Animation end handler.\n *\n * @private\n */\nAnimator.prototype._onFinish = function () {\n  var callback = this._callback;\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n  callback && callback();\n};\n\n/**\n * Private helpers\n * ***************\n */\n\nfunction createFrame(props, prefix) {\n  var frame = {};\n  for (var prop in props) {\n    frame[prefix ? prop : getUnprefixedPropName(prop)] = props[prop];\n  }\n  return frame;\n}\n\n/**\n * Transform translateX and translateY value into CSS transform style\n * property's value.\n *\n * @param {Number} x\n * @param {Number} y\n * @returns {String}\n */\nfunction getTranslateString(x, y) {\n  return 'translateX(' + x + 'px) translateY(' + y + 'px)';\n}\n\n/**\n * Drag placeholder.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDragPlaceholder(item) {\n  this._item = item;\n  this._animation = new Animator();\n  this._element = null;\n  this._className = '';\n  this._didMigrate = false;\n  this._resetAfterLayout = false;\n  this._left = 0;\n  this._top = 0;\n  this._transX = 0;\n  this._transY = 0;\n  this._nextTransX = 0;\n  this._nextTransY = 0;\n\n  // Bind animation handlers.\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n  this._updateDimensions = this._updateDimensions.bind(this);\n\n  // Bind event handlers.\n  this._onLayoutStart = this._onLayoutStart.bind(this);\n  this._onLayoutEnd = this._onLayoutEnd.bind(this);\n  this._onReleaseEnd = this._onReleaseEnd.bind(this);\n  this._onMigrate = this._onMigrate.bind(this);\n  this._onHide = this._onHide.bind(this);\n}\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Update placeholder's dimensions to match the item's dimensions.\n *\n * @private\n */\nItemDragPlaceholder.prototype._updateDimensions = function () {\n  if (!this.isActive()) return;\n  setStyles(this._element, {\n    width: this._item._width + 'px',\n    height: this._item._height + 'px'\n  });\n};\n\n/**\n * Move placeholder to a new position.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} isInstant\n */\nItemDragPlaceholder.prototype._onLayoutStart = function (items, isInstant) {\n  var item = this._item;\n\n  // If the item is not part of the layout anymore reset placeholder.\n  if (items.indexOf(item) === -1) {\n    this.reset();\n    return;\n  }\n  var nextLeft = item._left;\n  var nextTop = item._top;\n  var currentLeft = this._left;\n  var currentTop = this._top;\n\n  // Keep track of item layout position.\n  this._left = nextLeft;\n  this._top = nextTop;\n\n  // If item's position did not change, and the item did not migrate and the\n  // layout is not instant and we can safely skip layout.\n  if (!isInstant && !this._didMigrate && currentLeft === nextLeft && currentTop === nextTop) {\n    return;\n  }\n\n  // Slots data is calculated with item margins added to them so we need to add\n  // item's left and top margin to the slot data to get the placeholder's\n  // next position.\n  var nextX = nextLeft + item._marginLeft;\n  var nextY = nextTop + item._marginTop;\n\n  // Just snap to new position without any animations if no animation is\n  // required or if placeholder moves between grids.\n  var grid = item.getGrid();\n  var animEnabled = !isInstant && grid._settings.layoutDuration > 0;\n  if (!animEnabled || this._didMigrate) {\n    // Cancel potential (queued) layout tick.\n    cancelPlaceholderLayoutTick(item._id);\n\n    // Snap placeholder to correct position.\n    this._element.style[transformProp] = getTranslateString(nextX, nextY);\n    this._animation.stop();\n\n    // Move placeholder inside correct container after migration.\n    if (this._didMigrate) {\n      grid.getElement().appendChild(this._element);\n      this._didMigrate = false;\n    }\n    return;\n  }\n\n  // Start the placeholder's layout animation in the next tick. We do this to\n  // avoid layout thrashing.\n  this._nextTransX = nextX;\n  this._nextTransY = nextY;\n  addPlaceholderLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n\n/**\n * Prepare placeholder for layout animation.\n *\n * @private\n */\nItemDragPlaceholder.prototype._setupAnimation = function () {\n  if (!this.isActive()) return;\n  var translate = getTranslate(this._element);\n  this._transX = translate.x;\n  this._transY = translate.y;\n};\n\n/**\n * Start layout animation.\n *\n * @private\n */\nItemDragPlaceholder.prototype._startAnimation = function () {\n  if (!this.isActive()) return;\n  var animation = this._animation;\n  var currentX = this._transX;\n  var currentY = this._transY;\n  var nextX = this._nextTransX;\n  var nextY = this._nextTransY;\n\n  // If placeholder is already in correct position let's just stop animation\n  // and be done with it.\n  if (currentX === nextX && currentY === nextY) {\n    if (animation.isAnimating()) {\n      this._element.style[transformProp] = getTranslateString(nextX, nextY);\n      animation.stop();\n    }\n    return;\n  }\n\n  // Otherwise let's start the animation.\n  var settings = this._item.getGrid()._settings;\n  var currentStyles = {};\n  var targetStyles = {};\n  currentStyles[transformProp] = getTranslateString(currentX, currentY);\n  targetStyles[transformProp] = getTranslateString(nextX, nextY);\n  animation.start(currentStyles, targetStyles, {\n    duration: settings.layoutDuration,\n    easing: settings.layoutEasing,\n    onFinish: this._onLayoutEnd\n  });\n};\n\n/**\n * Layout end handler.\n *\n * @private\n */\nItemDragPlaceholder.prototype._onLayoutEnd = function () {\n  if (this._resetAfterLayout) {\n    this.reset();\n  }\n};\n\n/**\n * Drag end handler. This handler is called when dragReleaseEnd event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Item} item\n */\nItemDragPlaceholder.prototype._onReleaseEnd = function (item) {\n  if (item._id === this._item._id) {\n    // If the placeholder is not animating anymore we can safely reset it.\n    if (!this._animation.isAnimating()) {\n      this.reset();\n      return;\n    }\n\n    // If the placeholder item is still animating here, let's wait for it to\n    // finish it's animation.\n    this._resetAfterLayout = true;\n  }\n};\n\n/**\n * Migration start handler. This handler is called when beforeSend event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Object} data\n * @param {Item} data.item\n * @param {Grid} data.fromGrid\n * @param {Number} data.fromIndex\n * @param {Grid} data.toGrid\n * @param {Number} data.toIndex\n */\nItemDragPlaceholder.prototype._onMigrate = function (data) {\n  // Make sure we have a matching item.\n  if (data.item !== this._item) return;\n  var grid = this._item.getGrid();\n  var nextGrid = data.toGrid;\n\n  // Unbind listeners from current grid.\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide);\n\n  // Bind listeners to the next grid.\n  nextGrid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  nextGrid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  nextGrid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  nextGrid.on(EVENT_HIDE_START, this._onHide);\n\n  // Mark the item as migrated.\n  this._didMigrate = true;\n};\n\n/**\n * Reset placeholder if the associated item is hidden.\n *\n * @private\n * @param {Item[]} items\n */\nItemDragPlaceholder.prototype._onHide = function (items) {\n  if (items.indexOf(this._item) > -1) this.reset();\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Create placeholder. Note that this method only writes to DOM and does not\n * read anything from DOM so it should not cause any additional layout\n * thrashing when it's called at the end of the drag start procedure.\n *\n * @public\n */\nItemDragPlaceholder.prototype.create = function () {\n  // If we already have placeholder set up we can skip the initiation logic.\n  if (this.isActive()) {\n    this._resetAfterLayout = false;\n    return;\n  }\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation;\n\n  // Keep track of layout position.\n  this._left = item._left;\n  this._top = item._top;\n\n  // Create placeholder element.\n  var element;\n  if (isFunction(settings.dragPlaceholder.createElement)) {\n    element = settings.dragPlaceholder.createElement(item);\n  } else {\n    element = document.createElement('div');\n  }\n  this._element = element;\n\n  // Update element to animation instance.\n  animation._element = element;\n\n  // Add placeholder class to the placeholder element.\n  this._className = settings.itemPlaceholderClass || '';\n  if (this._className) {\n    addClass(element, this._className);\n  }\n\n  // Set initial styles.\n  setStyles(element, {\n    position: 'absolute',\n    left: '0px',\n    top: '0px',\n    width: item._width + 'px',\n    height: item._height + 'px'\n  });\n\n  // Set initial position.\n  element.style[transformProp] = getTranslateString(item._left + item._marginLeft, item._top + item._marginTop);\n\n  // Bind event listeners.\n  grid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.on(EVENT_HIDE_START, this._onHide);\n\n  // onCreate hook.\n  if (isFunction(settings.dragPlaceholder.onCreate)) {\n    settings.dragPlaceholder.onCreate(item, element);\n  }\n\n  // Insert the placeholder element to the grid.\n  grid.getElement().appendChild(element);\n};\n\n/**\n * Reset placeholder data.\n *\n * @public\n */\nItemDragPlaceholder.prototype.reset = function () {\n  if (!this.isActive()) return;\n  var element = this._element;\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation;\n\n  // Reset flag.\n  this._resetAfterLayout = false;\n\n  // Cancel potential (queued) layout tick.\n  cancelPlaceholderLayoutTick(item._id);\n  cancelPlaceholderResizeTick(item._id);\n\n  // Reset animation instance.\n  animation.stop();\n  animation._element = null;\n\n  // Unbind event listeners.\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide);\n\n  // Remove placeholder class from the placeholder element.\n  if (this._className) {\n    removeClass(element, this._className);\n    this._className = '';\n  }\n\n  // Remove element.\n  element.parentNode.removeChild(element);\n  this._element = null;\n\n  // onRemove hook. Note that here we use the current grid's onRemove callback\n  // so if the item has migrated during drag the onRemove method will not be\n  // the originating grid's method.\n  if (isFunction(settings.dragPlaceholder.onRemove)) {\n    settings.dragPlaceholder.onRemove(item, element);\n  }\n};\n\n/**\n * Check if placeholder is currently active (visible).\n *\n * @public\n * @returns {Boolean}\n */\nItemDragPlaceholder.prototype.isActive = function () {\n  return !!this._element;\n};\n\n/**\n * Get placeholder element.\n *\n * @public\n * @returns {?HTMLElement}\n */\nItemDragPlaceholder.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Update placeholder's dimensions to match the item's dimensions. Note that\n * the updating is done asynchronously in the next tick to avoid layout\n * thrashing.\n *\n * @public\n */\nItemDragPlaceholder.prototype.updateDimensions = function () {\n  if (!this.isActive()) return;\n  addPlaceholderResizeTick(this._item._id, this._updateDimensions);\n};\n\n/**\n * Destroy placeholder instance.\n *\n * @public\n */\nItemDragPlaceholder.prototype.destroy = function () {\n  this.reset();\n  this._animation.destroy();\n  this._item = this._animation = null;\n};\n\n/**\n * The release process handler constructor. Although this might seem as proper\n * fit for the drag process this needs to be separated into it's own logic\n * because there might be a scenario where drag is disabled, but the release\n * process still needs to be implemented (dragging from a grid to another).\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDragRelease(item) {\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the release process of an item.\n *\n * @public\n */\nItemDragRelease.prototype.start = function () {\n  if (this._isDestroyed || this._isActive) return;\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  this._isActive = true;\n  addClass(item._element, settings.itemReleasingClass);\n  if (!settings.dragRelease.useDragContainer) {\n    this._placeToGrid();\n  }\n  grid._emit(EVENT_DRAG_RELEASE_START, item);\n\n  // Let's start layout manually _only_ if there is no unfinished layout in\n  // about to finish.\n  if (!grid._nextLayoutData) item._layout.start(false);\n};\n\n/**\n * End the release process of an item. This method can be used to abort an\n * ongoing release process (animation) or finish the release process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the release be aborted? When true, the release end event won't be\n *    emitted. Set to true only when you need to abort the release process\n *    while the item is animating to it's position.\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\nItemDragRelease.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n  var item = this._item;\n  var grid = item.getGrid();\n  if (!abort && (left === undefined || top === undefined)) {\n    left = item._left;\n    top = item._top;\n  }\n  var didReparent = this._placeToGrid(left, top);\n  this._reset(didReparent);\n  if (!abort) grid._emit(EVENT_DRAG_RELEASE_END, item);\n};\nItemDragRelease.prototype.isJustReleased = function () {\n  return this._isActive && this._isPositioningStarted === false;\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemDragRelease.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Move the element back to the grid container element if it does not exist\n * there already.\n *\n * @private\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n * @returns {Boolean}\n *   - Returns `true` if the element was reparented.\n */\nItemDragRelease.prototype._placeToGrid = function (left, top) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var container = item.getGrid()._element;\n  var didReparent = false;\n  if (element.parentNode !== container) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(element);\n      left = translate.x - this._containerDiffX;\n      top = translate.y - this._containerDiffY;\n    }\n    container.appendChild(element);\n    item._setTranslate(left, top);\n    didReparent = true;\n  }\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n  return didReparent;\n};\n\n/**\n * Reset data and remove releasing class.\n *\n * @private\n * @param {Boolean} [needsReflow]\n */\nItemDragRelease.prototype._reset = function (needsReflow) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var releasingClass = item.getGrid()._settings.itemReleasingClass;\n  this._isActive = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n\n  // If the element was just reparented we need to do a forced reflow to remove\n  // the class gracefully.\n  if (releasingClass) {\n    // eslint-disable-next-line\n    if (needsReflow) item._element.clientWidth;\n    removeClass(item._element, releasingClass);\n  }\n};\nvar MIN_ANIMATION_DISTANCE = 2;\n\n/**\n * Layout manager for Item instance, handles the positioning of an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemLayout(item) {\n  var element = item._element;\n  var elementStyle = element.style;\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isInterrupted = false;\n  this._currentStyles = {};\n  this._targetStyles = {};\n  this._nextLeft = 0;\n  this._nextTop = 0;\n  this._offsetLeft = 0;\n  this._offsetTop = 0;\n  this._skipNextAnimation = false;\n  this._animOptions = {\n    onFinish: this._finish.bind(this),\n    duration: 0,\n    easing: 0\n  };\n\n  // Set element's initial position styles.\n  elementStyle.left = '0px';\n  elementStyle.top = '0px';\n  item._setTranslate(0, 0);\n  this._animation = new Animator(element);\n  this._queue = 'layout-' + item._id;\n\n  // Bind animation handlers and finish method.\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start item layout based on it's current data.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemLayout.prototype.start = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var release = item._dragRelease;\n  var gridSettings = item.getGrid()._settings;\n  var isPositioning = this._isActive;\n  var isJustReleased = release.isJustReleased();\n  var animDuration = isJustReleased ? gridSettings.dragRelease.duration : gridSettings.layoutDuration;\n  var animEasing = isJustReleased ? gridSettings.dragRelease.easing : gridSettings.layoutEasing;\n  var animEnabled = !instant && !this._skipNextAnimation && animDuration > 0;\n\n  // If the item is currently positioning cancel potential queued layout tick\n  // and process current layout callback queue with interrupted flag on.\n  if (isPositioning) {\n    cancelLayoutTick(item._id);\n    item._emitter.burst(this._queue, true, item);\n  }\n\n  // Mark release positioning as started.\n  if (isJustReleased) release._isPositioningStarted = true;\n\n  // Push the callback to the callback queue.\n  if (isFunction(onFinish)) {\n    item._emitter.on(this._queue, onFinish);\n  }\n\n  // Reset animation skipping flag.\n  this._skipNextAnimation = false;\n\n  // If no animations are needed, easy peasy!\n  if (!animEnabled) {\n    this._updateOffsets();\n    item._setTranslate(this._nextLeft, this._nextTop);\n    this._animation.stop();\n    this._finish();\n    return;\n  }\n\n  // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n  if (this._animation.isAnimating()) {\n    this._animation._animation.onfinish = null;\n  }\n\n  // Kick off animation to be started in the next tick.\n  this._isActive = true;\n  this._animOptions.easing = animEasing;\n  this._animOptions.duration = animDuration;\n  this._isInterrupted = isPositioning;\n  addLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n\n/**\n * Stop item's position animation if it is currently animating.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n * @param {Number} [left]\n * @param {Number} [top]\n */\nItemLayout.prototype.stop = function (processCallbackQueue, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n  var item = this._item;\n\n  // Cancel animation init.\n  cancelLayoutTick(item._id);\n\n  // Stop animation.\n  if (this._animation.isAnimating()) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(item._element);\n      left = translate.x;\n      top = translate.y;\n    }\n    item._setTranslate(left, top);\n    this._animation.stop();\n  }\n\n  // Remove positioning class.\n  removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n\n  // Reset active state.\n  this._isActive = false;\n\n  // Process callback queue if needed.\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nItemLayout.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  var elementStyle = this._item._element.style;\n  this.stop(true, 0, 0);\n  this._item._emitter.clear(this._queue);\n  this._animation.destroy();\n  elementStyle[transformProp] = '';\n  elementStyle.left = '';\n  elementStyle.top = '';\n  this._item = null;\n  this._currentStyles = null;\n  this._targetStyles = null;\n  this._animOptions = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Calculate and update item's current layout offset data.\n *\n * @private\n */\nItemLayout.prototype._updateOffsets = function () {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease;\n  this._offsetLeft = release._isActive ? release._containerDiffX : migrate._isActive ? migrate._containerDiffX : 0;\n  this._offsetTop = release._isActive ? release._containerDiffY : migrate._isActive ? migrate._containerDiffY : 0;\n  this._nextLeft = this._item._left + this._offsetLeft;\n  this._nextTop = this._item._top + this._offsetTop;\n};\n\n/**\n * Finish item layout procedure.\n *\n * @private\n */\nItemLayout.prototype._finish = function () {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease;\n\n  // Update internal translate values.\n  item._tX = this._nextLeft;\n  item._tY = this._nextTop;\n\n  // Mark the item as inactive and remove positioning classes.\n  if (this._isActive) {\n    this._isActive = false;\n    removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n  }\n\n  // Finish up release and migration.\n  if (release._isActive) release.stop();\n  if (migrate._isActive) migrate.stop();\n\n  // Process the callback queue.\n  item._emitter.burst(this._queue, false, item);\n};\n\n/**\n * Prepare item for layout animation.\n *\n * @private\n */\nItemLayout.prototype._setupAnimation = function () {\n  var item = this._item;\n  if (item._tX === undefined || item._tY === undefined) {\n    var translate = getTranslate(item._element);\n    item._tX = translate.x;\n    item._tY = translate.y;\n  }\n};\n\n/**\n * Start layout animation.\n *\n * @private\n */\nItemLayout.prototype._startAnimation = function () {\n  var item = this._item;\n  var settings = item.getGrid()._settings;\n  var isInstant = this._animOptions.duration <= 0;\n\n  // Let's update the offset data and target styles.\n  this._updateOffsets();\n  var xDiff = Math.abs(item._left - (item._tX - this._offsetLeft));\n  var yDiff = Math.abs(item._top - (item._tY - this._offsetTop));\n\n  // If there is no need for animation or if the item is already in correct\n  // position (or near it) let's finish the process early.\n  if (isInstant || xDiff < MIN_ANIMATION_DISTANCE && yDiff < MIN_ANIMATION_DISTANCE) {\n    if (xDiff || yDiff || this._isInterrupted) {\n      item._setTranslate(this._nextLeft, this._nextTop);\n    }\n    this._animation.stop();\n    this._finish();\n    return;\n  }\n\n  // Set item's positioning class if needed.\n  if (!this._isInterrupted) {\n    addClass(item._element, settings.itemPositioningClass);\n  }\n\n  // Get current/next styles for animation.\n  this._currentStyles[transformProp] = getTranslateString(item._tX, item._tY);\n  this._targetStyles[transformProp] = getTranslateString(this._nextLeft, this._nextTop);\n\n  // Set internal translation values to undefined for the duration of the\n  // animation since they will be changing on each animation frame for the\n  // duration of the animation and tracking them would mean reading the DOM on\n  // each frame, which is pretty darn expensive.\n  item._tX = item._tY = undefined;\n\n  // Start animation.\n  this._animation.start(this._currentStyles, this._targetStyles, this._animOptions);\n};\n\n/**\n * The migrate process handler constructor.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemMigrate(item) {\n  // Private props.\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._container = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the migrate process of an item.\n *\n * @public\n * @param {Grid} targetGrid\n * @param {(HTMLElement|Number|Item)} position\n * @param {HTMLElement} [container]\n */\nItemMigrate.prototype.start = function (targetGrid, position, container) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var isActive = item.isActive();\n  var isVisible = item.isVisible();\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var targetSettings = targetGrid._settings;\n  var targetElement = targetGrid._element;\n  var targetItems = targetGrid._items;\n  var currentIndex = grid._items.indexOf(item);\n  var targetContainer = container || document.body;\n  var targetIndex;\n  var targetItem;\n  var currentContainer;\n  var offsetDiff;\n  var containerDiff;\n  var translate;\n  var translateX;\n  var translateY;\n  var currentVisClass;\n  var nextVisClass;\n\n  // Get target index.\n  if (typeof position === 'number') {\n    targetIndex = normalizeArrayIndex(targetItems, position, 1);\n  } else {\n    targetItem = targetGrid.getItem(position);\n    if (!targetItem) return;\n    targetIndex = targetItems.indexOf(targetItem);\n  }\n\n  // Get current translateX and translateY values if needed.\n  if (item.isPositioning() || this._isActive || item.isReleasing()) {\n    translate = getTranslate(element);\n    translateX = translate.x;\n    translateY = translate.y;\n  }\n\n  // Abort current positioning.\n  if (item.isPositioning()) {\n    item._layout.stop(true, translateX, translateY);\n  }\n\n  // Abort current migration.\n  if (this._isActive) {\n    translateX -= this._containerDiffX;\n    translateY -= this._containerDiffY;\n    this.stop(true, translateX, translateY);\n  }\n\n  // Abort current release.\n  if (item.isReleasing()) {\n    translateX -= item._dragRelease._containerDiffX;\n    translateY -= item._dragRelease._containerDiffY;\n    item._dragRelease.stop(true, translateX, translateY);\n  }\n\n  // Stop current visibility animation.\n  item._visibility.stop(true);\n\n  // Destroy current drag.\n  if (item._drag) item._drag.destroy();\n\n  // Emit beforeSend event.\n  if (grid._hasListeners(EVENT_BEFORE_SEND)) {\n    grid._emit(EVENT_BEFORE_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  }\n\n  // Emit beforeReceive event.\n  if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n    targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  }\n\n  // Update item class.\n  if (settings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, settings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  }\n\n  // Update visibility class.\n  currentVisClass = isVisible ? settings.itemVisibleClass : settings.itemHiddenClass;\n  nextVisClass = isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  }\n\n  // Move item instance from current grid to target grid.\n  grid._items.splice(currentIndex, 1);\n  arrayInsert(targetItems, item, targetIndex);\n\n  // Update item's grid id reference.\n  item._gridId = targetGrid._id;\n\n  // If item is active we need to move the item inside the target container for\n  // the duration of the (potential) animation if it's different than the\n  // current container.\n  if (isActive) {\n    currentContainer = element.parentNode;\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n      if (!translate) {\n        translate = getTranslate(element);\n        translateX = translate.x;\n        translateY = translate.y;\n      }\n      item._setTranslate(translateX + offsetDiff.left, translateY + offsetDiff.top);\n    }\n  }\n  // If item is not active let's just append it to the target grid's element.\n  else {\n    targetElement.appendChild(element);\n  }\n\n  // Update child element's styles to reflect the current visibility state.\n  item._visibility.setStyles(isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\n\n  // Get offset diff for the migration data, if the item is active.\n  if (isActive) {\n    containerDiff = getOffsetDiff(targetContainer, targetElement, true);\n  }\n\n  // Update item's cached dimensions.\n  item._refreshDimensions();\n\n  // Reset item's sort data.\n  item._sortData = null;\n\n  // Create new drag handler.\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n  // Setup migration data.\n  if (isActive) {\n    this._isActive = true;\n    this._container = targetContainer;\n    this._containerDiffX = containerDiff.left;\n    this._containerDiffY = containerDiff.top;\n  } else {\n    this._isActive = false;\n    this._container = null;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n  }\n\n  // Emit send event.\n  if (grid._hasListeners(EVENT_SEND)) {\n    grid._emit(EVENT_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  }\n\n  // Emit receive event.\n  if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n    targetGrid._emit(EVENT_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  }\n};\n\n/**\n * End the migrate process of an item. This method can be used to abort an\n * ongoing migrate process (animation) or finish the migrate process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the migration be aborted?\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\nItemMigrate.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var gridElement = grid._element;\n  var translate;\n  if (this._container !== gridElement) {\n    if (left === undefined || top === undefined) {\n      if (abort) {\n        translate = getTranslate(element);\n        left = translate.x - this._containerDiffX;\n        top = translate.y - this._containerDiffY;\n      } else {\n        left = item._left;\n        top = item._top;\n      }\n    }\n    gridElement.appendChild(element);\n    item._setTranslate(left, top);\n  }\n  this._isActive = false;\n  this._container = null;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemMigrate.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Visibility manager for Item instance, handles visibility of an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemVisibility(item) {\n  var isActive = item._isActive;\n  var element = item._element;\n  var childElement = element.children[0];\n  var settings = item.getGrid()._settings;\n  if (!childElement) {\n    throw new Error('No valid child element found within item element.');\n  }\n  this._item = item;\n  this._isDestroyed = false;\n  this._isHidden = !isActive;\n  this._isHiding = false;\n  this._isShowing = false;\n  this._childElement = childElement;\n  this._currentStyleProps = [];\n  this._animation = new Animator(childElement);\n  this._queue = 'visibility-' + item._id;\n  this._finishShow = this._finishShow.bind(this);\n  this._finishHide = this._finishHide.bind(this);\n  element.style.display = isActive ? '' : 'none';\n  addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass);\n  this.setStyles(isActive ? settings.visibleStyles : settings.hiddenStyles);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Show item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype.show = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  // If item is visible call the callback and be done with it.\n  if (!this._isShowing && !this._isHidden) {\n    callback && callback(false, item);\n    return;\n  }\n\n  // If item is showing and does not need to be shown instantly, let's just\n  // push callback to the callback queue and be done with it.\n  if (this._isShowing && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  }\n\n  // If the item is hiding or hidden process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n  if (!this._isShowing) {\n    item._emitter.burst(this._queue, true, item);\n    removeClass(element, settings.itemHiddenClass);\n    addClass(element, settings.itemVisibleClass);\n    if (!this._isHiding) element.style.display = '';\n  }\n\n  // Push callback to the callback queue.\n  callback && item._emitter.on(this._queue, callback);\n\n  // Update visibility states.\n  this._isShowing = true;\n  this._isHiding = this._isHidden = false;\n\n  // Finally let's start show animation.\n  this._startAnimation(true, instant, this._finishShow);\n};\n\n/**\n * Hide item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype.hide = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  // If item is already hidden call the callback and be done with it.\n  if (!this._isHiding && this._isHidden) {\n    callback && callback(false, item);\n    return;\n  }\n\n  // If item is hiding and does not need to be hidden instantly, let's just\n  // push callback to the callback queue and be done with it.\n  if (this._isHiding && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  }\n\n  // If the item is showing or visible process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n  if (!this._isHiding) {\n    item._emitter.burst(this._queue, true, item);\n    addClass(element, settings.itemHiddenClass);\n    removeClass(element, settings.itemVisibleClass);\n  }\n\n  // Push callback to the callback queue.\n  callback && item._emitter.on(this._queue, callback);\n\n  // Update visibility states.\n  this._isHidden = this._isHiding = true;\n  this._isShowing = false;\n\n  // Finally let's start hide animation.\n  this._startAnimation(false, instant, this._finishHide);\n};\n\n/**\n * Stop current hiding/showing process.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n */\nItemVisibility.prototype.stop = function (processCallbackQueue) {\n  if (this._isDestroyed) return;\n  if (!this._isHiding && !this._isShowing) return;\n  var item = this._item;\n  cancelVisibilityTick(item._id);\n  this._animation.stop();\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n\n/**\n * Reset all existing visibility styles and apply new visibility styles to the\n * visibility element. This method should be used to set styles when there is a\n * chance that the current style properties differ from the new ones (basically\n * on init and on migrations).\n *\n * @public\n * @param {Object} styles\n */\nItemVisibility.prototype.setStyles = function (styles) {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n  this._removeCurrentStyles();\n  for (var prop in styles) {\n    currentStyleProps.push(prop);\n    childElement.style[prop] = styles[prop];\n  }\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nItemVisibility.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  this.stop(true);\n  item._emitter.clear(this._queue);\n  this._animation.destroy();\n  this._removeCurrentStyles();\n  removeClass(element, settings.itemVisibleClass);\n  removeClass(element, settings.itemHiddenClass);\n  element.style.display = '';\n\n  // Reset state.\n  this._isHiding = this._isShowing = false;\n  this._isDestroyed = this._isHidden = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Start visibility animation.\n *\n * @private\n * @param {Boolean} toVisible\n * @param {Boolean} [instant]\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype._startAnimation = function (toVisible, instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var animation = this._animation;\n  var childElement = this._childElement;\n  var settings = item.getGrid()._settings;\n  var targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;\n  var duration = toVisible ? settings.showDuration : settings.hideDuration;\n  var easing = toVisible ? settings.showEasing : settings.hideEasing;\n  var isInstant = instant || duration <= 0;\n  var currentStyles;\n\n  // No target styles? Let's quit early.\n  if (!targetStyles) {\n    onFinish && onFinish();\n    return;\n  }\n\n  // Cancel queued visibility tick.\n  cancelVisibilityTick(item._id);\n\n  // If we need to apply the styles instantly without animation.\n  if (isInstant) {\n    setStyles(childElement, targetStyles);\n    animation.stop();\n    onFinish && onFinish();\n    return;\n  }\n\n  // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n  if (animation.isAnimating()) {\n    animation._animation.onfinish = null;\n  }\n\n  // Start the animation in the next tick (to avoid layout thrashing).\n  addVisibilityTick(item._id, function () {\n    currentStyles = getCurrentStyles(childElement, targetStyles);\n  }, function () {\n    animation.start(currentStyles, targetStyles, {\n      duration: duration,\n      easing: easing,\n      onFinish: onFinish\n    });\n  });\n};\n\n/**\n * Finish show procedure.\n *\n * @private\n */\nItemVisibility.prototype._finishShow = function () {\n  if (this._isHidden) return;\n  this._isShowing = false;\n  this._item._emitter.burst(this._queue, false, this._item);\n};\n\n/**\n * Finish hide procedure.\n *\n * @private\n */\nItemVisibility.prototype._finishHide = function () {\n  if (!this._isHidden) return;\n  var item = this._item;\n  this._isHiding = false;\n  item._layout.stop(true, 0, 0);\n  item._element.style.display = 'none';\n  item._emitter.burst(this._queue, false, item);\n};\n\n/**\n * Remove currently applied visibility related inline style properties.\n *\n * @private\n */\nItemVisibility.prototype._removeCurrentStyles = function () {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n  for (var i = 0; i < currentStyleProps.length; i++) {\n    childElement.style[currentStyleProps[i]] = '';\n  }\n  currentStyleProps.length = 0;\n};\nvar id = 0;\n\n/**\n * Returns a unique numeric id (increments a base value on every call).\n * @returns {Number}\n */\nfunction createUid() {\n  return ++id;\n}\n\n/**\n * Creates a new Item instance for a Grid instance.\n *\n * @class\n * @param {Grid} grid\n * @param {HTMLElement} element\n * @param {Boolean} [isActive]\n */\nfunction Item(grid, element, isActive) {\n  var settings = grid._settings;\n\n  // Store item/element pair to a map (for faster item querying by element).\n  if (ITEM_ELEMENT_MAP) {\n    if (ITEM_ELEMENT_MAP.has(element)) {\n      throw new Error('You can only create one Muuri Item per element!');\n    } else {\n      ITEM_ELEMENT_MAP.set(element, this);\n    }\n  }\n  this._id = createUid();\n  this._gridId = grid._id;\n  this._element = element;\n  this._isDestroyed = false;\n  this._left = 0;\n  this._top = 0;\n  this._width = 0;\n  this._height = 0;\n  this._marginLeft = 0;\n  this._marginRight = 0;\n  this._marginTop = 0;\n  this._marginBottom = 0;\n  this._tX = undefined;\n  this._tY = undefined;\n  this._sortData = null;\n  this._emitter = new Emitter();\n\n  // If the provided item element is not a direct child of the grid container\n  // element, append it to the grid container. Note, we are indeed reading the\n  // DOM here but it's a property that does not cause reflowing.\n  if (element.parentNode !== grid._element) {\n    grid._element.appendChild(element);\n  }\n\n  // Set item class.\n  addClass(element, settings.itemClass);\n\n  // If isActive is not defined, let's try to auto-detect it. Note, we are\n  // indeed reading the DOM here but it's a property that does not cause\n  // reflowing.\n  if (typeof isActive !== 'boolean') {\n    isActive = getStyle(element, 'display') !== 'none';\n  }\n\n  // Set up active state (defines if the item is considered part of the layout\n  // or not).\n  this._isActive = isActive;\n\n  // Setup visibility handler.\n  this._visibility = new ItemVisibility(this);\n\n  // Set up layout handler.\n  this._layout = new ItemLayout(this);\n\n  // Set up migration handler data.\n  this._migrate = new ItemMigrate(this);\n\n  // Set up drag handler.\n  this._drag = settings.dragEnabled ? new ItemDrag(this) : null;\n\n  // Set up release handler. Note that although this is fully linked to dragging\n  // this still needs to be always instantiated to handle migration scenarios\n  // correctly.\n  this._dragRelease = new ItemDragRelease(this);\n\n  // Set up drag placeholder handler. Note that although this is fully linked to\n  // dragging this still needs to be always instantiated to handle migration\n  // scenarios correctly.\n  this._dragPlaceholder = new ItemDragPlaceholder(this);\n\n  // Note! You must call the following methods before you start using the\n  // instance. They are deliberately not called in the end as it would cause\n  // potentially a massive amount of reflows if multiple items were instantiated\n  // in a loop.\n  // this._refreshDimensions();\n  // this._refreshSortData();\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Get the instance grid reference.\n *\n * @public\n * @returns {Grid}\n */\nItem.prototype.getGrid = function () {\n  return GRID_INSTANCES[this._gridId];\n};\n\n/**\n * Get the instance element.\n *\n * @public\n * @returns {HTMLElement}\n */\nItem.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Get instance element's cached width.\n *\n * @public\n * @returns {Number}\n */\nItem.prototype.getWidth = function () {\n  return this._width;\n};\n\n/**\n * Get instance element's cached height.\n *\n * @public\n * @returns {Number}\n */\nItem.prototype.getHeight = function () {\n  return this._height;\n};\n\n/**\n * Get instance element's cached margins.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left, right, top and bottom properties\n *     which indicate the item element's cached margins.\n */\nItem.prototype.getMargin = function () {\n  return {\n    left: this._marginLeft,\n    right: this._marginRight,\n    top: this._marginTop,\n    bottom: this._marginBottom\n  };\n};\n\n/**\n * Get instance element's cached position.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left and top properties which indicate the\n *     item element's cached position in the grid.\n */\nItem.prototype.getPosition = function () {\n  return {\n    left: this._left,\n    top: this._top\n  };\n};\n\n/**\n * Is the item active?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isActive = function () {\n  return this._isActive;\n};\n\n/**\n * Is the item visible?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isVisible = function () {\n  return !!this._visibility && !this._visibility._isHidden;\n};\n\n/**\n * Is the item being animated to visible?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isShowing = function () {\n  return !!(this._visibility && this._visibility._isShowing);\n};\n\n/**\n * Is the item being animated to hidden?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isHiding = function () {\n  return !!(this._visibility && this._visibility._isHiding);\n};\n\n/**\n * Is the item positioning?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isPositioning = function () {\n  return !!(this._layout && this._layout._isActive);\n};\n\n/**\n * Is the item being dragged (or queued for dragging)?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isDragging = function () {\n  return !!(this._drag && this._drag._isActive);\n};\n\n/**\n * Is the item being released?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isReleasing = function () {\n  return !!(this._dragRelease && this._dragRelease._isActive);\n};\n\n/**\n * Is the item destroyed?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isDestroyed = function () {\n  return this._isDestroyed;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Recalculate item's dimensions.\n *\n * @private\n * @param {Boolean} [force=false]\n */\nItem.prototype._refreshDimensions = function (force) {\n  if (this._isDestroyed) return;\n  if (force !== true && this._visibility._isHidden) return;\n  var element = this._element;\n  var dragPlaceholder = this._dragPlaceholder;\n  var rect = element.getBoundingClientRect();\n\n  // Calculate width and height.\n  this._width = rect.width;\n  this._height = rect.height;\n\n  // Calculate margins (ignore negative margins).\n  this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));\n  this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));\n  this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));\n  this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom'));\n\n  // Keep drag placeholder's dimensions synced with the item's.\n  if (dragPlaceholder) dragPlaceholder.updateDimensions();\n};\n\n/**\n * Fetch and store item's sort data.\n *\n * @private\n */\nItem.prototype._refreshSortData = function () {\n  if (this._isDestroyed) return;\n  var data = this._sortData = {};\n  var getters = this.getGrid()._settings.sortData;\n  var prop;\n  for (prop in getters) {\n    data[prop] = getters[prop](this, this._element);\n  }\n};\n\n/**\n * Add item to layout.\n *\n * @private\n */\nItem.prototype._addToLayout = function (left, top) {\n  if (this._isActive === true) return;\n  this._isActive = true;\n  this._left = left || 0;\n  this._top = top || 0;\n};\n\n/**\n * Remove item from layout.\n *\n * @private\n */\nItem.prototype._removeFromLayout = function () {\n  if (this._isActive === false) return;\n  this._isActive = false;\n  this._left = 0;\n  this._top = 0;\n};\n\n/**\n * Check if the layout procedure can be skipped for the item.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\nItem.prototype._canSkipLayout = function (left, top) {\n  return this._left === left && this._top === top && !this._migrate._isActive && !this._layout._skipNextAnimation && !this._dragRelease.isJustReleased();\n};\n\n/**\n * Set the provided left and top arguments as the item element's translate\n * values in the DOM. This method keeps track of the currently applied\n * translate values and skips the update operation if the provided values are\n * identical to the currently applied values. Returns `false` if there was no\n * need for update and `true` if the translate value was updated.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\nItem.prototype._setTranslate = function (left, top) {\n  if (this._tX === left && this._tY === top) return false;\n  this._tX = left;\n  this._tY = top;\n  this._element.style[transformProp] = getTranslateString(left, top);\n  return true;\n};\n\n/**\n * Destroy item instance.\n *\n * @private\n * @param {Boolean} [removeElement=false]\n */\nItem.prototype._destroy = function (removeElement) {\n  if (this._isDestroyed) return;\n  var element = this._element;\n  var grid = this.getGrid();\n  var settings = grid._settings;\n\n  // Destroy handlers.\n  this._dragPlaceholder.destroy();\n  this._dragRelease.destroy();\n  this._migrate.destroy();\n  this._layout.destroy();\n  this._visibility.destroy();\n  if (this._drag) this._drag.destroy();\n\n  // Destroy emitter.\n  this._emitter.destroy();\n\n  // Remove item class.\n  removeClass(element, settings.itemClass);\n\n  // Remove element from DOM.\n  if (removeElement) element.parentNode.removeChild(element);\n\n  // Remove item/element pair from map.\n  if (ITEM_ELEMENT_MAP) ITEM_ELEMENT_MAP.delete(element);\n\n  // Reset state.\n  this._isActive = false;\n  this._isDestroyed = true;\n};\nfunction createPackerProcessor(isWorker) {\n  var FILL_GAPS = 1;\n  var HORIZONTAL = 2;\n  var ALIGN_RIGHT = 4;\n  var ALIGN_BOTTOM = 8;\n  var ROUNDING = 16;\n  var EPS = 0.001;\n  var MIN_SLOT_SIZE = 0.5;\n\n  // Rounds number first to three decimal precision and then floors the result\n  // to two decimal precision.\n  // Math.floor(Math.round(number * 1000) / 10) / 100\n  function roundNumber(number) {\n    return ((number * 1000 + 0.5 << 0) / 10 << 0) / 100;\n  }\n\n  /**\n   * @class\n   */\n  function PackerProcessor() {\n    this.currentRects = [];\n    this.nextRects = [];\n    this.rectTarget = {};\n    this.rectStore = [];\n    this.slotSizes = [];\n    this.rectId = 0;\n    this.slotIndex = -1;\n    this.slotData = {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    };\n    this.sortRectsLeftTop = this.sortRectsLeftTop.bind(this);\n    this.sortRectsTopLeft = this.sortRectsTopLeft.bind(this);\n  }\n\n  /**\n   * Takes a layout object as an argument and computes positions (slots) for the\n   * layout items. Also computes the final width and height of the layout. The\n   * provided layout object's slots array is mutated as well as the width and\n   * height properties.\n   *\n   * @param {Object} layout\n   * @param {Number} layout.width\n   *   - The start (current) width of the layout in pixels.\n   * @param {Number} layout.height\n   *   - The start (current) height of the layout in pixels.\n   * @param {(Item[]|Number[])} layout.items\n   *   - List of Muuri.Item instances or a list of item dimensions\n   *     (e.g [ item1Width, item1Height, item2Width, item2Height, ... ]).\n   * @param {(Array|Float32Array)} layout.slots\n   *   - An Array/Float32Array instance which's length should equal to\n   *     the amount of items times two. The position (width and height) of each\n   *     item will be written into this array.\n   * @param {Number} settings\n   *   - The layout's settings as bitmasks.\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.computeLayout = function (layout, settings) {\n    var items = layout.items;\n    var slots = layout.slots;\n    var fillGaps = !!(settings & FILL_GAPS);\n    var horizontal = !!(settings & HORIZONTAL);\n    var alignRight = !!(settings & ALIGN_RIGHT);\n    var alignBottom = !!(settings & ALIGN_BOTTOM);\n    var rounding = !!(settings & ROUNDING);\n    var isPreProcessed = typeof items[0] === 'number';\n    var i, bump, item, slotWidth, slotHeight, slot;\n\n    // No need to go further if items do not exist.\n    if (!items.length) return layout;\n\n    // Compute slots for the items.\n    bump = isPreProcessed ? 2 : 1;\n    for (i = 0; i < items.length; i += bump) {\n      // If items are pre-processed it means that items array contains only\n      // the raw dimensions of the items. Otherwise we assume it is an array\n      // of normal Muuri items.\n      if (isPreProcessed) {\n        slotWidth = items[i];\n        slotHeight = items[i + 1];\n      } else {\n        item = items[i];\n        slotWidth = item._width + item._marginLeft + item._marginRight;\n        slotHeight = item._height + item._marginTop + item._marginBottom;\n      }\n\n      // If rounding is enabled let's round the item's width and height to\n      // make the layout algorithm a bit more stable. This has a performance\n      // cost so don't use this if not necessary.\n      if (rounding) {\n        slotWidth = roundNumber(slotWidth);\n        slotHeight = roundNumber(slotHeight);\n      }\n\n      // Get slot data.\n      slot = this.computeNextSlot(layout, slotWidth, slotHeight, fillGaps, horizontal);\n\n      // Update layout width/height.\n      if (horizontal) {\n        if (slot.left + slot.width > layout.width) {\n          layout.width = slot.left + slot.width;\n        }\n      } else {\n        if (slot.top + slot.height > layout.height) {\n          layout.height = slot.top + slot.height;\n        }\n      }\n\n      // Add item slot data to layout slots.\n      slots[++this.slotIndex] = slot.left;\n      slots[++this.slotIndex] = slot.top;\n\n      // Store the size too (for later usage) if needed.\n      if (alignRight || alignBottom) {\n        this.slotSizes.push(slot.width, slot.height);\n      }\n    }\n\n    // If the alignment is set to right we need to adjust the results.\n    if (alignRight) {\n      for (i = 0; i < slots.length; i += 2) {\n        slots[i] = layout.width - (slots[i] + this.slotSizes[i]);\n      }\n    }\n\n    // If the alignment is set to bottom we need to adjust the results.\n    if (alignBottom) {\n      for (i = 1; i < slots.length; i += 2) {\n        slots[i] = layout.height - (slots[i] + this.slotSizes[i]);\n      }\n    }\n\n    // Reset stuff.\n    this.slotSizes.length = 0;\n    this.currentRects.length = 0;\n    this.nextRects.length = 0;\n    this.rectStore.length = 0;\n    this.rectId = 0;\n    this.slotIndex = -1;\n    return layout;\n  };\n\n  /**\n   * Calculate next slot in the layout. Returns a slot object with position and\n   * dimensions data. The returned object is reused between calls.\n   *\n   * @param {Object} layout\n   * @param {Number} slotWidth\n   * @param {Number} slotHeight\n   * @param {Boolean} fillGaps\n   * @param {Boolean} horizontal\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.computeNextSlot = function (layout, slotWidth, slotHeight, fillGaps, horizontal) {\n    var slot = this.slotData;\n    var currentRects = this.currentRects;\n    var nextRects = this.nextRects;\n    var ignoreCurrentRects = false;\n    var rect;\n    var rectId;\n    var shards;\n    var i;\n    var j;\n\n    // Reset new slots.\n    nextRects.length = 0;\n\n    // Set item slot initial data.\n    slot.left = null;\n    slot.top = null;\n    slot.width = slotWidth;\n    slot.height = slotHeight;\n\n    // Try to find position for the slot from the existing free spaces in the\n    // layout.\n    for (i = 0; i < currentRects.length; i++) {\n      rectId = currentRects[i];\n      if (!rectId) continue;\n      rect = this.getRect(rectId);\n      if (slot.width <= rect.width + EPS && slot.height <= rect.height + EPS) {\n        slot.left = rect.left;\n        slot.top = rect.top;\n        break;\n      }\n    }\n\n    // If no position was found for the slot let's position the slot to\n    // the bottom left (in vertical mode) or top right (in horizontal mode) of\n    // the layout.\n    if (slot.left === null) {\n      if (horizontal) {\n        slot.left = layout.width;\n        slot.top = 0;\n      } else {\n        slot.left = 0;\n        slot.top = layout.height;\n      }\n\n      // If gaps don't need filling let's throw away all the current free spaces\n      // (currentRects).\n      if (!fillGaps) {\n        ignoreCurrentRects = true;\n      }\n    }\n\n    // In vertical mode, if the slot's bottom overlaps the layout's bottom.\n    if (!horizontal && slot.top + slot.height > layout.height + EPS) {\n      // If slot is not aligned to the left edge, create a new free space to the\n      // left of the slot.\n      if (slot.left > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(0, layout.height, slot.left, Infinity));\n      }\n\n      // If slot is not aligned to the right edge, create a new free space to\n      // the right of the slot.\n      if (slot.left + slot.width < layout.width - MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(slot.left + slot.width, layout.height, layout.width - slot.left - slot.width, Infinity));\n      }\n\n      // Update layout height.\n      layout.height = slot.top + slot.height;\n    }\n\n    // In horizontal mode, if the slot's right overlaps the layout's right edge.\n    if (horizontal && slot.left + slot.width > layout.width + EPS) {\n      // If slot is not aligned to the top, create a new free space above the\n      // slot.\n      if (slot.top > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(layout.width, 0, Infinity, slot.top));\n      }\n\n      // If slot is not aligned to the bottom, create a new free space below\n      // the slot.\n      if (slot.top + slot.height < layout.height - MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(layout.width, slot.top + slot.height, Infinity, layout.height - slot.top - slot.height));\n      }\n\n      // Update layout width.\n      layout.width = slot.left + slot.width;\n    }\n\n    // Clean up the current free spaces making sure none of them overlap with\n    // the slot. Split all overlapping free spaces into smaller shards that do\n    // not overlap with the slot.\n    if (!ignoreCurrentRects) {\n      if (fillGaps) i = 0;\n      for (; i < currentRects.length; i++) {\n        rectId = currentRects[i];\n        if (!rectId) continue;\n        rect = this.getRect(rectId);\n        shards = this.splitRect(rect, slot);\n        for (j = 0; j < shards.length; j++) {\n          rectId = shards[j];\n          rect = this.getRect(rectId);\n          // Make sure that the free space is within the boundaries of the\n          // layout. This routine is critical to the algorithm as it makes sure\n          // that there are no leftover spaces with infinite height/width.\n          // It's also essential that we don't compare values absolutely to each\n          // other but leave a little headroom (EPSILON) to get rid of false\n          // positives.\n          if (horizontal ? rect.left + EPS < layout.width - EPS : rect.top + EPS < layout.height - EPS) {\n            nextRects.push(rectId);\n          }\n        }\n      }\n    }\n\n    // Sanitize and sort all the new free spaces that will be used in the next\n    // iteration. This procedure is critical to make the bin-packing algorithm\n    // work. The free spaces have to be in correct order in the beginning of the\n    // next iteration.\n    if (nextRects.length > 1) {\n      this.purgeRects(nextRects).sort(horizontal ? this.sortRectsLeftTop : this.sortRectsTopLeft);\n    }\n\n    // Finally we need to make sure that `this.currentRects` points to\n    // `nextRects` array as that is used in the next iteration's beginning when\n    // we try to find a space for the next slot.\n    this.currentRects = nextRects;\n    this.nextRects = currentRects;\n    return slot;\n  };\n\n  /**\n   * Add a new rectangle to the rectangle store. Returns the id of the new\n   * rectangle.\n   *\n   * @param {Number} left\n   * @param {Number} top\n   * @param {Number} width\n   * @param {Number} height\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.addRect = function (left, top, width, height) {\n    var rectId = ++this.rectId;\n    this.rectStore[rectId] = left || 0;\n    this.rectStore[++this.rectId] = top || 0;\n    this.rectStore[++this.rectId] = width || 0;\n    this.rectStore[++this.rectId] = height || 0;\n    return rectId;\n  };\n\n  /**\n   * Get rectangle data from the rectangle store by id. Optionally you can\n   * provide a target object where the rectangle data will be written in. By\n   * default an internal object is reused as a target object.\n   *\n   * @param {Number} id\n   * @param {Object} [target]\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.getRect = function (id, target) {\n    if (!target) target = this.rectTarget;\n    target.left = this.rectStore[id] || 0;\n    target.top = this.rectStore[++id] || 0;\n    target.width = this.rectStore[++id] || 0;\n    target.height = this.rectStore[++id] || 0;\n    return target;\n  };\n\n  /**\n   * Punch a hole into a rectangle and return the shards (1-4).\n   *\n   * @param {Object} rect\n   * @param {Object} hole\n   * @returns {Number[]}\n   */\n  PackerProcessor.prototype.splitRect = function () {\n    var shards = [];\n    var width = 0;\n    var height = 0;\n    return function (rect, hole) {\n      // Reset old shards.\n      shards.length = 0;\n\n      // If the slot does not overlap with the hole add slot to the return data\n      // as is. Note that in this case we are eager to keep the slot as is if\n      // possible so we use the EPSILON in favour of that logic.\n      if (rect.left + rect.width <= hole.left + EPS || hole.left + hole.width <= rect.left + EPS || rect.top + rect.height <= hole.top + EPS || hole.top + hole.height <= rect.top + EPS) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, rect.height));\n        return shards;\n      }\n\n      // Left split.\n      width = hole.left - rect.left;\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, width, rect.height));\n      }\n\n      // Right split.\n      width = rect.left + rect.width - (hole.left + hole.width);\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(hole.left + hole.width, rect.top, width, rect.height));\n      }\n\n      // Top split.\n      height = hole.top - rect.top;\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, height));\n      }\n\n      // Bottom split.\n      height = rect.top + rect.height - (hole.top + hole.height);\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, hole.top + hole.height, rect.width, height));\n      }\n      return shards;\n    };\n  }();\n\n  /**\n   * Check if a rectangle is fully within another rectangle.\n   *\n   * @param {Object} a\n   * @param {Object} b\n   * @returns {Boolean}\n   */\n  PackerProcessor.prototype.isRectAWithinRectB = function (a, b) {\n    return a.left + EPS >= b.left && a.top + EPS >= b.top && a.left + a.width - EPS <= b.left + b.width && a.top + a.height - EPS <= b.top + b.height;\n  };\n\n  /**\n   * Loops through an array of rectangle ids and resets all that are fully\n   * within another rectangle in the array. Resetting in this case means that\n   * the rectangle id value is replaced with zero.\n   *\n   * @param {Number[]} rectIds\n   * @returns {Number[]}\n   */\n  PackerProcessor.prototype.purgeRects = function () {\n    var rectA = {};\n    var rectB = {};\n    return function (rectIds) {\n      var i = rectIds.length;\n      var j;\n      while (i--) {\n        j = rectIds.length;\n        if (!rectIds[i]) continue;\n        this.getRect(rectIds[i], rectA);\n        while (j--) {\n          if (!rectIds[j] || i === j) continue;\n          this.getRect(rectIds[j], rectB);\n          if (this.isRectAWithinRectB(rectA, rectB)) {\n            rectIds[i] = 0;\n            break;\n          }\n        }\n      }\n      return rectIds;\n    };\n  }();\n\n  /**\n   * Sort rectangles with top-left gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.sortRectsTopLeft = function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n      return rectA.top < rectB.top && rectA.top + EPS < rectB.top ? -1 : rectA.top > rectB.top && rectA.top - EPS > rectB.top ? 1 : rectA.left < rectB.left && rectA.left + EPS < rectB.left ? -1 : rectA.left > rectB.left && rectA.left - EPS > rectB.left ? 1 : 0;\n    };\n  }();\n\n  /**\n   * Sort rectangles with left-top gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.sortRectsLeftTop = function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n      return rectA.left < rectB.left && rectA.left + EPS < rectB.left ? -1 : rectA.left > rectB.left && rectA.left - EPS < rectB.left ? 1 : rectA.top < rectB.top && rectA.top + EPS < rectB.top ? -1 : rectA.top > rectB.top && rectA.top - EPS > rectB.top ? 1 : 0;\n    };\n  }();\n  if (isWorker) {\n    var PACKET_INDEX_WIDTH = 1;\n    var PACKET_INDEX_HEIGHT = 2;\n    var PACKET_INDEX_OPTIONS = 3;\n    var PACKET_HEADER_SLOTS = 4;\n    var processor = new PackerProcessor();\n    self.onmessage = function (msg) {\n      var data = new Float32Array(msg.data);\n      var items = data.subarray(PACKET_HEADER_SLOTS, data.length);\n      var slots = new Float32Array(items.length);\n      var settings = data[PACKET_INDEX_OPTIONS];\n      var layout = {\n        items: items,\n        slots: slots,\n        width: data[PACKET_INDEX_WIDTH],\n        height: data[PACKET_INDEX_HEIGHT]\n      };\n\n      // Compute the layout (width / height / slots).\n      processor.computeLayout(layout, settings);\n\n      // Copy layout data to the return data.\n      data[PACKET_INDEX_WIDTH] = layout.width;\n      data[PACKET_INDEX_HEIGHT] = layout.height;\n      data.set(layout.slots, PACKET_HEADER_SLOTS);\n\n      // Send layout back to the main thread.\n      postMessage(data.buffer, [data.buffer]);\n    };\n  }\n  return PackerProcessor;\n}\nvar PackerProcessor = createPackerProcessor();\n\n//\n// WORKER UTILS\n//\n\nvar blobUrl = null;\nvar activeWorkers = [];\nfunction createWorkerProcessors(amount, onmessage) {\n  var workers = [];\n  if (amount > 0) {\n    if (!blobUrl) {\n      blobUrl = URL.createObjectURL(new Blob(['(' + createPackerProcessor.toString() + ')(true)'], {\n        type: 'application/javascript'\n      }));\n    }\n    for (var i = 0, worker; i < amount; i++) {\n      worker = new Worker(blobUrl);\n      if (onmessage) worker.onmessage = onmessage;\n      workers.push(worker);\n      activeWorkers.push(worker);\n    }\n  }\n  return workers;\n}\nfunction destroyWorkerProcessors(workers) {\n  var worker;\n  var index;\n  for (var i = 0; i < workers.length; i++) {\n    worker = workers[i];\n    worker.onmessage = null;\n    worker.onerror = null;\n    worker.onmessageerror = null;\n    worker.terminate();\n    index = activeWorkers.indexOf(worker);\n    if (index > -1) activeWorkers.splice(index, 1);\n  }\n  if (blobUrl && !activeWorkers.length) {\n    URL.revokeObjectURL(blobUrl);\n    blobUrl = null;\n  }\n}\nfunction isWorkerProcessorsSupported() {\n  return !!(window.Worker && window.URL && window.Blob);\n}\nvar FILL_GAPS = 1;\nvar HORIZONTAL = 2;\nvar ALIGN_RIGHT = 4;\nvar ALIGN_BOTTOM = 8;\nvar ROUNDING = 16;\nvar PACKET_INDEX_ID = 0;\nvar PACKET_INDEX_WIDTH = 1;\nvar PACKET_INDEX_HEIGHT = 2;\nvar PACKET_INDEX_OPTIONS = 3;\nvar PACKET_HEADER_SLOTS = 4;\n\n/**\n * @class\n * @param {Number} [numWorkers=0]\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps=false]\n * @param {Boolean} [options.horizontal=false]\n * @param {Boolean} [options.alignRight=false]\n * @param {Boolean} [options.alignBottom=false]\n * @param {Boolean} [options.rounding=false]\n */\nfunction Packer(numWorkers, options) {\n  this._options = 0;\n  this._processor = null;\n  this._layoutQueue = [];\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n  this._workers = [];\n  this._onWorkerMessage = this._onWorkerMessage.bind(this);\n\n  // Set initial options.\n  this.setOptions(options);\n\n  // Init the worker(s) or the processor if workers can't be used.\n  numWorkers = typeof numWorkers === 'number' ? Math.max(0, numWorkers) : 0;\n  if (numWorkers && isWorkerProcessorsSupported()) {\n    try {\n      this._workers = createWorkerProcessors(numWorkers, this._onWorkerMessage);\n    } catch (e) {\n      this._processor = new PackerProcessor();\n    }\n  } else {\n    this._processor = new PackerProcessor();\n  }\n}\nPacker.prototype._sendToWorker = function () {\n  if (!this._layoutQueue.length || !this._workers.length) return;\n  var layoutId = this._layoutQueue.shift();\n  var worker = this._workers.pop();\n  var data = this._layoutWorkerData[layoutId];\n  delete this._layoutWorkerData[layoutId];\n  this._layoutWorkers[layoutId] = worker;\n  worker.postMessage(data.buffer, [data.buffer]);\n};\nPacker.prototype._onWorkerMessage = function (msg) {\n  var data = new Float32Array(msg.data);\n  var layoutId = data[PACKET_INDEX_ID];\n  var layout = this._layouts[layoutId];\n  var callback = this._layoutCallbacks[layoutId];\n  var worker = this._layoutWorkers[layoutId];\n  if (layout) delete this._layouts[layoutId];\n  if (callback) delete this._layoutCallbacks[layoutId];\n  if (worker) delete this._layoutWorkers[layoutId];\n  if (layout && callback) {\n    layout.width = data[PACKET_INDEX_WIDTH];\n    layout.height = data[PACKET_INDEX_HEIGHT];\n    layout.slots = data.subarray(PACKET_HEADER_SLOTS, data.length);\n    this._finalizeLayout(layout);\n    callback(layout);\n  }\n  if (worker) {\n    this._workers.push(worker);\n    this._sendToWorker();\n  }\n};\nPacker.prototype._finalizeLayout = function (layout) {\n  var grid = layout._grid;\n  var isHorizontal = layout._settings & HORIZONTAL;\n  var isBorderBox = grid._boxSizing === 'border-box';\n  delete layout._grid;\n  delete layout._settings;\n  layout.styles = {};\n  if (isHorizontal) {\n    layout.styles.width = (isBorderBox ? layout.width + grid._borderLeft + grid._borderRight : layout.width) + 'px';\n  } else {\n    layout.styles.height = (isBorderBox ? layout.height + grid._borderTop + grid._borderBottom : layout.height) + 'px';\n  }\n  return layout;\n};\n\n/**\n * @public\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps]\n * @param {Boolean} [options.horizontal]\n * @param {Boolean} [options.alignRight]\n * @param {Boolean} [options.alignBottom]\n * @param {Boolean} [options.rounding]\n */\nPacker.prototype.setOptions = function (options) {\n  if (!options) return;\n  var fillGaps;\n  if (typeof options.fillGaps === 'boolean') {\n    fillGaps = options.fillGaps ? FILL_GAPS : 0;\n  } else {\n    fillGaps = this._options & FILL_GAPS;\n  }\n  var horizontal;\n  if (typeof options.horizontal === 'boolean') {\n    horizontal = options.horizontal ? HORIZONTAL : 0;\n  } else {\n    horizontal = this._options & HORIZONTAL;\n  }\n  var alignRight;\n  if (typeof options.alignRight === 'boolean') {\n    alignRight = options.alignRight ? ALIGN_RIGHT : 0;\n  } else {\n    alignRight = this._options & ALIGN_RIGHT;\n  }\n  var alignBottom;\n  if (typeof options.alignBottom === 'boolean') {\n    alignBottom = options.alignBottom ? ALIGN_BOTTOM : 0;\n  } else {\n    alignBottom = this._options & ALIGN_BOTTOM;\n  }\n  var rounding;\n  if (typeof options.rounding === 'boolean') {\n    rounding = options.rounding ? ROUNDING : 0;\n  } else {\n    rounding = this._options & ROUNDING;\n  }\n  this._options = fillGaps | horizontal | alignRight | alignBottom | rounding;\n};\n\n/**\n * @public\n * @param {Grid} grid\n * @param {Number} layoutId\n * @param {Item[]} items\n * @param {Number} width\n * @param {Number} height\n * @param {Function} callback\n * @returns {?Function}\n */\nPacker.prototype.createLayout = function (grid, layoutId, items, width, height, callback) {\n  if (this._layouts[layoutId]) {\n    throw new Error('A layout with the provided id is currently being processed.');\n  }\n  var horizontal = this._options & HORIZONTAL;\n  var layout = {\n    id: layoutId,\n    items: items,\n    slots: null,\n    width: horizontal ? 0 : width,\n    height: !horizontal ? 0 : height,\n    // Temporary data, which will be removed before sending the layout data\n    // outside of Packer's context.\n    _grid: grid,\n    _settings: this._options\n  };\n\n  // If there are no items let's call the callback immediately.\n  if (!items.length) {\n    layout.slots = [];\n    this._finalizeLayout(layout);\n    callback(layout);\n    return;\n  }\n\n  // Create layout synchronously if needed.\n  if (this._processor) {\n    layout.slots = window.Float32Array ? new Float32Array(items.length * 2) : new Array(items.length * 2);\n    this._processor.computeLayout(layout, layout._settings);\n    this._finalizeLayout(layout);\n    callback(layout);\n    return;\n  }\n\n  // Worker data.\n  var data = new Float32Array(PACKET_HEADER_SLOTS + items.length * 2);\n\n  // Worker data header.\n  data[PACKET_INDEX_ID] = layoutId;\n  data[PACKET_INDEX_WIDTH] = layout.width;\n  data[PACKET_INDEX_HEIGHT] = layout.height;\n  data[PACKET_INDEX_OPTIONS] = layout._settings;\n\n  // Worker data items.\n  var i, j, item;\n  for (i = 0, j = PACKET_HEADER_SLOTS - 1, item; i < items.length; i++) {\n    item = items[i];\n    data[++j] = item._width + item._marginLeft + item._marginRight;\n    data[++j] = item._height + item._marginTop + item._marginBottom;\n  }\n  this._layoutQueue.push(layoutId);\n  this._layouts[layoutId] = layout;\n  this._layoutCallbacks[layoutId] = callback;\n  this._layoutWorkerData[layoutId] = data;\n  this._sendToWorker();\n  return this.cancelLayout.bind(this, layoutId);\n};\n\n/**\n * @public\n * @param {Number} layoutId\n */\nPacker.prototype.cancelLayout = function (layoutId) {\n  var layout = this._layouts[layoutId];\n  if (!layout) return;\n  delete this._layouts[layoutId];\n  delete this._layoutCallbacks[layoutId];\n  if (this._layoutWorkerData[layoutId]) {\n    delete this._layoutWorkerData[layoutId];\n    var queueIndex = this._layoutQueue.indexOf(layoutId);\n    if (queueIndex > -1) this._layoutQueue.splice(queueIndex, 1);\n  }\n};\n\n/**\n * @public\n */\nPacker.prototype.destroy = function () {\n  // Move all currently used workers back in the workers array.\n  for (var key in this._layoutWorkers) {\n    this._workers.push(this._layoutWorkers[key]);\n  }\n\n  // Destroy all instance's workers.\n  destroyWorkerProcessors(this._workers);\n\n  // Reset data.\n  this._workers.length = 0;\n  this._layoutQueue.length = 0;\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n};\nvar debounceId = 0;\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. The returned function accepts one argument which, when\n * being `true`, cancels the debounce function immediately. When the debounce\n * function is canceled it cannot be invoked again.\n *\n * @param {Function} fn\n * @param {Number} durationMs\n * @returns {Function}\n */\nfunction debounce(fn, durationMs) {\n  var id = ++debounceId;\n  var timer = 0;\n  var lastTime = 0;\n  var isCanceled = false;\n  var tick = function (time) {\n    if (isCanceled) return;\n    if (lastTime) timer -= time - lastTime;\n    lastTime = time;\n    if (timer > 0) {\n      addDebounceTick(id, tick);\n    } else {\n      timer = lastTime = 0;\n      fn();\n    }\n  };\n  return function (cancel) {\n    if (isCanceled) return;\n    if (durationMs <= 0) {\n      if (cancel !== true) fn();\n      return;\n    }\n    if (cancel === true) {\n      isCanceled = true;\n      timer = lastTime = 0;\n      tick = undefined;\n      cancelDebounceTick(id);\n      return;\n    }\n    if (timer <= 0) {\n      timer = durationMs;\n      tick(0);\n    } else {\n      timer = durationMs;\n    }\n  };\n}\nvar htmlCollectionType = '[object HTMLCollection]';\nvar nodeListType = '[object NodeList]';\n\n/**\n * Check if a value is a node list or a html collection.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isNodeList(val) {\n  var type = Object.prototype.toString.call(val);\n  return type === htmlCollectionType || type === nodeListType;\n}\nvar objectType = 'object';\nvar objectToStringType = '[object Object]';\nvar toString = Object.prototype.toString;\n\n/**\n * Check if a value is a plain object.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isPlainObject(val) {\n  return typeof val === objectType && toString.call(val) === objectToStringType;\n}\nfunction noop() {}\n\n/**\n * Converts a value to an array or clones an array.\n *\n * @param {*} val\n * @returns {Array}\n */\nfunction toArray(val) {\n  return isNodeList(val) ? Array.prototype.slice.call(val) : Array.prototype.concat(val);\n}\nvar NUMBER_TYPE = 'number';\nvar STRING_TYPE = 'string';\nvar INSTANT_LAYOUT = 'instant';\nvar layoutId = 0;\n\n/**\n * Creates a new Grid instance.\n *\n * @class\n * @param {(HTMLElement|String)} element\n * @param {Object} [options]\n * @param {(String|HTMLElement[]|NodeList|HTMLCollection)} [options.items=\"*\"]\n * @param {Number} [options.showDuration=300]\n * @param {String} [options.showEasing=\"ease\"]\n * @param {Object} [options.visibleStyles={opacity: \"1\", transform: \"scale(1)\"}]\n * @param {Number} [options.hideDuration=300]\n * @param {String} [options.hideEasing=\"ease\"]\n * @param {Object} [options.hiddenStyles={opacity: \"0\", transform: \"scale(0.5)\"}]\n * @param {(Function|Object)} [options.layout]\n * @param {Boolean} [options.layout.fillGaps=false]\n * @param {Boolean} [options.layout.horizontal=false]\n * @param {Boolean} [options.layout.alignRight=false]\n * @param {Boolean} [options.layout.alignBottom=false]\n * @param {Boolean} [options.layout.rounding=false]\n * @param {(Boolean|Number)} [options.layoutOnResize=150]\n * @param {Boolean} [options.layoutOnInit=true]\n * @param {Number} [options.layoutDuration=300]\n * @param {String} [options.layoutEasing=\"ease\"]\n * @param {?Object} [options.sortData=null]\n * @param {Boolean} [options.dragEnabled=false]\n * @param {?String} [options.dragHandle=null]\n * @param {?HtmlElement} [options.dragContainer=null]\n * @param {?Function} [options.dragStartPredicate]\n * @param {Number} [options.dragStartPredicate.distance=0]\n * @param {Number} [options.dragStartPredicate.delay=0]\n * @param {String} [options.dragAxis=\"xy\"]\n * @param {(Boolean|Function)} [options.dragSort=true]\n * @param {Object} [options.dragSortHeuristics]\n * @param {Number} [options.dragSortHeuristics.sortInterval=100]\n * @param {Number} [options.dragSortHeuristics.minDragDistance=10]\n * @param {Number} [options.dragSortHeuristics.minBounceBackAngle=1]\n * @param {(Function|Object)} [options.dragSortPredicate]\n * @param {Number} [options.dragSortPredicate.threshold=50]\n * @param {String} [options.dragSortPredicate.action=\"move\"]\n * @param {String} [options.dragSortPredicate.migrateAction=\"move\"]\n * @param {Object} [options.dragRelease]\n * @param {Number} [options.dragRelease.duration=300]\n * @param {String} [options.dragRelease.easing=\"ease\"]\n * @param {Boolean} [options.dragRelease.useDragContainer=true]\n * @param {Object} [options.dragCssProps]\n * @param {Object} [options.dragPlaceholder]\n * @param {Boolean} [options.dragPlaceholder.enabled=false]\n * @param {?Function} [options.dragPlaceholder.createElement=null]\n * @param {?Function} [options.dragPlaceholder.onCreate=null]\n * @param {?Function} [options.dragPlaceholder.onRemove=null]\n * @param {Object} [options.dragAutoScroll]\n * @param {(Function|Array)} [options.dragAutoScroll.targets=[]]\n * @param {?Function} [options.dragAutoScroll.handle=null]\n * @param {Number} [options.dragAutoScroll.threshold=50]\n * @param {Number} [options.dragAutoScroll.safeZone=0.2]\n * @param {(Function|Number)} [options.dragAutoScroll.speed]\n * @param {Boolean} [options.dragAutoScroll.sortDuringScroll=true]\n * @param {Boolean} [options.dragAutoScroll.smoothStop=false]\n * @param {?Function} [options.dragAutoScroll.onStart=null]\n * @param {?Function} [options.dragAutoScroll.onStop=null]\n * @param {String} [options.containerClass=\"muuri\"]\n * @param {String} [options.itemClass=\"muuri-item\"]\n * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\n * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\n * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\n * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\n * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\n * @param {String} [options.itemPlaceholderClass=\"muuri-item-placeholder\"]\n */\nfunction Grid(element, options) {\n  // Allow passing element as selector string\n  if (typeof element === STRING_TYPE) {\n    element = document.querySelector(element);\n  }\n\n  // Throw an error if the container element is not body element or does not\n  // exist within the body element.\n  var isElementInDom = element.getRootNode ? element.getRootNode({\n    composed: true\n  }) === document : document.body.contains(element);\n  if (!isElementInDom || element === document.documentElement) {\n    throw new Error('Container element must be an existing DOM element.');\n  }\n\n  // Create instance settings by merging the options with default options.\n  var settings = mergeSettings(Grid.defaultOptions, options);\n  settings.visibleStyles = normalizeStyles(settings.visibleStyles);\n  settings.hiddenStyles = normalizeStyles(settings.hiddenStyles);\n  if (!isFunction(settings.dragSort)) {\n    settings.dragSort = !!settings.dragSort;\n  }\n  this._id = createUid();\n  this._element = element;\n  this._settings = settings;\n  this._isDestroyed = false;\n  this._items = [];\n  this._layout = {\n    id: 0,\n    items: [],\n    slots: []\n  };\n  this._isLayoutFinished = true;\n  this._nextLayoutData = null;\n  this._emitter = new Emitter();\n  this._onLayoutDataReceived = this._onLayoutDataReceived.bind(this);\n\n  // Store grid instance to the grid instances collection.\n  GRID_INSTANCES[this._id] = this;\n\n  // Add container element's class name.\n  addClass(element, settings.containerClass);\n\n  // If layoutOnResize option is a valid number sanitize it and bind the resize\n  // handler.\n  bindLayoutOnResize(this, settings.layoutOnResize);\n\n  // Add initial items.\n  this.add(getInitialGridElements(element, settings.items), {\n    layout: false\n  });\n\n  // Layout on init if necessary.\n  if (settings.layoutOnInit) {\n    this.layout(true);\n  }\n}\n\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @see Item\n */\nGrid.Item = Item;\n\n/**\n * @public\n * @static\n * @see ItemLayout\n */\nGrid.ItemLayout = ItemLayout;\n\n/**\n * @public\n * @static\n * @see ItemVisibility\n */\nGrid.ItemVisibility = ItemVisibility;\n\n/**\n * @public\n * @static\n * @see ItemMigrate\n */\nGrid.ItemMigrate = ItemMigrate;\n\n/**\n * @public\n * @static\n * @see ItemDrag\n */\nGrid.ItemDrag = ItemDrag;\n\n/**\n * @public\n * @static\n * @see ItemDragRelease\n */\nGrid.ItemDragRelease = ItemDragRelease;\n\n/**\n * @public\n * @static\n * @see ItemDragPlaceholder\n */\nGrid.ItemDragPlaceholder = ItemDragPlaceholder;\n\n/**\n * @public\n * @static\n * @see Emitter\n */\nGrid.Emitter = Emitter;\n\n/**\n * @public\n * @static\n * @see Animator\n */\nGrid.Animator = Animator;\n\n/**\n * @public\n * @static\n * @see Dragger\n */\nGrid.Dragger = Dragger;\n\n/**\n * @public\n * @static\n * @see Packer\n */\nGrid.Packer = Packer;\n\n/**\n * @public\n * @static\n * @see AutoScroller\n */\nGrid.AutoScroller = AutoScroller;\n\n/**\n * The default Packer instance used by default for all layouts.\n *\n * @public\n * @static\n * @type {Packer}\n */\nGrid.defaultPacker = new Packer(2);\n\n/**\n * Default options for Grid instance.\n *\n * @public\n * @static\n * @type {Object}\n */\nGrid.defaultOptions = {\n  // Initial item elements\n  items: '*',\n  // Default show animation\n  showDuration: 300,\n  showEasing: 'ease',\n  // Default hide animation\n  hideDuration: 300,\n  hideEasing: 'ease',\n  // Item's visible/hidden state styles\n  visibleStyles: {\n    opacity: '1',\n    transform: 'scale(1)'\n  },\n  hiddenStyles: {\n    opacity: '0',\n    transform: 'scale(0.5)'\n  },\n  // Layout\n  layout: {\n    fillGaps: false,\n    horizontal: false,\n    alignRight: false,\n    alignBottom: false,\n    rounding: false\n  },\n  layoutOnResize: 150,\n  layoutOnInit: true,\n  layoutDuration: 300,\n  layoutEasing: 'ease',\n  // Sorting\n  sortData: null,\n  // Drag & Drop\n  dragEnabled: false,\n  dragContainer: null,\n  dragHandle: null,\n  dragStartPredicate: {\n    distance: 0,\n    delay: 0\n  },\n  dragAxis: 'xy',\n  dragSort: true,\n  dragSortHeuristics: {\n    sortInterval: 100,\n    minDragDistance: 10,\n    minBounceBackAngle: 1\n  },\n  dragSortPredicate: {\n    threshold: 50,\n    action: ACTION_MOVE,\n    migrateAction: ACTION_MOVE\n  },\n  dragRelease: {\n    duration: 300,\n    easing: 'ease',\n    useDragContainer: true\n  },\n  dragCssProps: {\n    touchAction: 'none',\n    userSelect: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0, 0, 0, 0)',\n    touchCallout: 'none',\n    contentZooming: 'none'\n  },\n  dragPlaceholder: {\n    enabled: false,\n    createElement: null,\n    onCreate: null,\n    onRemove: null\n  },\n  dragAutoScroll: {\n    targets: [],\n    handle: null,\n    threshold: 50,\n    safeZone: 0.2,\n    speed: AutoScroller.smoothSpeed(1000, 2000, 2500),\n    sortDuringScroll: true,\n    smoothStop: false,\n    onStart: null,\n    onStop: null\n  },\n  // Classnames\n  containerClass: 'muuri',\n  itemClass: 'muuri-item',\n  itemVisibleClass: 'muuri-item-shown',\n  itemHiddenClass: 'muuri-item-hidden',\n  itemPositioningClass: 'muuri-item-positioning',\n  itemDraggingClass: 'muuri-item-dragging',\n  itemReleasingClass: 'muuri-item-releasing',\n  itemPlaceholderClass: 'muuri-item-placeholder'\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\nGrid.prototype.on = function (event, listener) {\n  this._emitter.on(event, listener);\n  return this;\n};\n\n/**\n * Unbind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\nGrid.prototype.off = function (event, listener) {\n  this._emitter.off(event, listener);\n  return this;\n};\n\n/**\n * Get the container element.\n *\n * @public\n * @returns {HTMLElement}\n */\nGrid.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Get instance's item by element or by index. Target can also be an Item\n * instance in which case the function returns the item if it exists within\n * related Grid instance. If nothing is found with the provided target, null\n * is returned.\n *\n * @private\n * @param {(HtmlElement|Number|Item)} [target]\n * @returns {?Item}\n */\nGrid.prototype.getItem = function (target) {\n  // If no target is specified or the instance is destroyed, return null.\n  if (this._isDestroyed || !target && target !== 0) {\n    return null;\n  }\n\n  // If target is number return the item in that index. If the number is lower\n  // than zero look for the item starting from the end of the items array. For\n  // example -1 for the last item, -2 for the second last item, etc.\n  if (typeof target === NUMBER_TYPE) {\n    return this._items[target > -1 ? target : this._items.length + target] || null;\n  }\n\n  // If the target is an instance of Item return it if it is attached to this\n  // Grid instance, otherwise return null.\n  if (target instanceof Item) {\n    return target._gridId === this._id ? target : null;\n  }\n\n  // In other cases let's assume that the target is an element, so let's try\n  // to find an item that matches the element and return it. If item is not\n  // found return null.\n  if (ITEM_ELEMENT_MAP) {\n    var item = ITEM_ELEMENT_MAP.get(target);\n    return item && item._gridId === this._id ? item : null;\n  } else {\n    for (var i = 0; i < this._items.length; i++) {\n      if (this._items[i]._element === target) {\n        return this._items[i];\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * Get all items. Optionally you can provide specific targets (elements,\n * indices and item instances). All items that are not found are omitted from\n * the returned array.\n *\n * @public\n * @param {(HtmlElement|Number|Item|Array)} [targets]\n * @returns {Item[]}\n */\nGrid.prototype.getItems = function (targets) {\n  // Return all items immediately if no targets were provided or if the\n  // instance is destroyed.\n  if (this._isDestroyed || targets === undefined) {\n    return this._items.slice(0);\n  }\n  var items = [];\n  var i, item;\n  if (Array.isArray(targets) || isNodeList(targets)) {\n    for (i = 0; i < targets.length; i++) {\n      item = this.getItem(targets[i]);\n      if (item) items.push(item);\n    }\n  } else {\n    item = this.getItem(targets);\n    if (item) items.push(item);\n  }\n  return items;\n};\n\n/**\n * Update the cached dimensions of the instance's items. By default all the\n * items are refreshed, but you can also provide an array of target items as the\n * first argument if you want to refresh specific items. Note that all hidden\n * items are not refreshed by default since their \"display\" property is \"none\"\n * and their dimensions are therefore not readable from the DOM. However, if you\n * do want to force update hidden item dimensions too you can provide `true`\n * as the second argument, which makes the elements temporarily visible while\n * their dimensions are being read.\n *\n * @public\n * @param {Item[]} [items]\n * @param {Boolean} [force=false]\n * @returns {Grid}\n */\nGrid.prototype.refreshItems = function (items, force) {\n  if (this._isDestroyed) return this;\n  var targets = items || this._items;\n  var i, item, style, hiddenItemStyles;\n  if (force === true) {\n    hiddenItemStyles = [];\n    for (i = 0; i < targets.length; i++) {\n      item = targets[i];\n      if (!item.isVisible() && !item.isHiding()) {\n        style = item.getElement().style;\n        style.visibility = 'hidden';\n        style.display = '';\n        hiddenItemStyles.push(style);\n      }\n    }\n  }\n  for (i = 0; i < targets.length; i++) {\n    targets[i]._refreshDimensions(force);\n  }\n  if (force === true) {\n    for (i = 0; i < hiddenItemStyles.length; i++) {\n      style = hiddenItemStyles[i];\n      style.visibility = '';\n      style.display = 'none';\n    }\n    hiddenItemStyles.length = 0;\n  }\n  return this;\n};\n\n/**\n * Update the sort data of the instance's items. By default all the items are\n * refreshed, but you can also provide an array of target items if you want to\n * refresh specific items.\n *\n * @public\n * @param {Item[]} [items]\n * @returns {Grid}\n */\nGrid.prototype.refreshSortData = function (items) {\n  if (this._isDestroyed) return this;\n  var targets = items || this._items;\n  for (var i = 0; i < targets.length; i++) {\n    targets[i]._refreshSortData();\n  }\n  return this;\n};\n\n/**\n * Synchronize the item elements to match the order of the items in the DOM.\n * This comes handy if you need to keep the DOM structure matched with the\n * order of the items. Note that if an item's element is not currently a child\n * of the container element (if it is dragged for example) it is ignored and\n * left untouched.\n *\n * @public\n * @returns {Grid}\n */\nGrid.prototype.synchronize = function () {\n  if (this._isDestroyed) return this;\n  var items = this._items;\n  if (!items.length) return this;\n  var fragment;\n  var element;\n  for (var i = 0; i < items.length; i++) {\n    element = items[i]._element;\n    if (element.parentNode === this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  }\n  if (!fragment) return this;\n  this._element.appendChild(fragment);\n  this._emit(EVENT_SYNCHRONIZE);\n  return this;\n};\n\n/**\n * Calculate and apply item positions.\n *\n * @public\n * @param {Boolean} [instant=false]\n * @param {Function} [onFinish]\n * @returns {Grid}\n */\nGrid.prototype.layout = function (instant, onFinish) {\n  if (this._isDestroyed) return this;\n\n  // Cancel unfinished layout algorithm if possible.\n  var unfinishedLayout = this._nextLayoutData;\n  if (unfinishedLayout && isFunction(unfinishedLayout.cancel)) {\n    unfinishedLayout.cancel();\n  }\n\n  // Compute layout id (let's stay in Float32 range).\n  layoutId = layoutId % MAX_SAFE_FLOAT32_INTEGER + 1;\n  var nextLayoutId = layoutId;\n\n  // Store data for next layout.\n  this._nextLayoutData = {\n    id: nextLayoutId,\n    instant: instant,\n    onFinish: onFinish,\n    cancel: null\n  };\n\n  // Collect layout items (all active grid items).\n  var items = this._items;\n  var layoutItems = [];\n  for (var i = 0; i < items.length; i++) {\n    if (items[i]._isActive) layoutItems.push(items[i]);\n  }\n\n  // Compute new layout.\n  this._refreshDimensions();\n  var gridWidth = this._width - this._borderLeft - this._borderRight;\n  var gridHeight = this._height - this._borderTop - this._borderBottom;\n  var layoutSettings = this._settings.layout;\n  var cancelLayout;\n  if (isFunction(layoutSettings)) {\n    cancelLayout = layoutSettings(this, nextLayoutId, layoutItems, gridWidth, gridHeight, this._onLayoutDataReceived);\n  } else {\n    Grid.defaultPacker.setOptions(layoutSettings);\n    cancelLayout = Grid.defaultPacker.createLayout(this, nextLayoutId, layoutItems, gridWidth, gridHeight, this._onLayoutDataReceived);\n  }\n\n  // Store layout cancel method if available.\n  if (isFunction(cancelLayout) && this._nextLayoutData && this._nextLayoutData.id === nextLayoutId) {\n    this._nextLayoutData.cancel = cancelLayout;\n  }\n  return this;\n};\n\n/**\n * Add new items by providing the elements you wish to add to the instance and\n * optionally provide the index where you want the items to be inserted into.\n * All elements that are not already children of the container element will be\n * automatically appended to the container element. If an element has it's CSS\n * display property set to \"none\" it will be marked as inactive during the\n * initiation process. As long as the item is inactive it will not be part of\n * the layout, but it will retain it's index. You can activate items at any\n * point with grid.show() method. This method will automatically call\n * grid.layout() if one or more of the added elements are visible. If only\n * hidden items are added no layout will be called. All the new visible items\n * are positioned without animation during their first layout.\n *\n * @public\n * @param {(HTMLElement|HTMLElement[])} elements\n * @param {Object} [options]\n * @param {Number} [options.index=-1]\n * @param {Boolean} [options.active]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\nGrid.prototype.add = function (elements, options) {\n  if (this._isDestroyed || !elements) return [];\n  var newItems = toArray(elements);\n  if (!newItems.length) return newItems;\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var items = this._items;\n  var needsLayout = false;\n  var fragment;\n  var element;\n  var item;\n  var i;\n\n  // Collect all the elements that are not child of the grid element into a\n  // document fragment.\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n    if (element.parentNode !== this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  }\n\n  // If we have a fragment, let's append it to the grid element. We could just\n  // not do this and the `new Item()` instantiation would handle this for us,\n  // but this way we can add the elements into the DOM a bit faster.\n  if (fragment) {\n    this._element.appendChild(fragment);\n  }\n\n  // Map provided elements into new grid items.\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n    item = newItems[i] = new Item(this, element, opts.active);\n\n    // If the item to be added is active, we need to do a layout. Also, we\n    // need to mark the item with the skipNextAnimation flag to make it\n    // position instantly (without animation) during the next layout. Without\n    // the hack the item would animate to it's new position from the northwest\n    // corner of the grid, which feels a bit buggy (imho).\n    if (item._isActive) {\n      needsLayout = true;\n      item._layout._skipNextAnimation = true;\n    }\n  }\n\n  // Set up the items' initial dimensions and sort data. This needs to be done\n  // in a separate loop to avoid layout thrashing.\n  for (i = 0; i < newItems.length; i++) {\n    item = newItems[i];\n    item._refreshDimensions();\n    item._refreshSortData();\n  }\n\n  // Add the new items to the items collection to correct index.\n  arrayInsert(items, newItems, opts.index);\n\n  // Emit add event.\n  if (this._hasListeners(EVENT_ADD)) {\n    this._emit(EVENT_ADD, newItems.slice(0));\n  }\n\n  // If layout is needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n  return newItems;\n};\n\n/**\n * Remove items from the instance.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.removeElements=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\nGrid.prototype.remove = function (items, options) {\n  if (this._isDestroyed || !items.length) return [];\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var needsLayout = false;\n  var allItems = this.getItems();\n  var targetItems = [];\n  var indices = [];\n  var index;\n  var item;\n  var i;\n\n  // Remove the individual items.\n  for (i = 0; i < items.length; i++) {\n    item = items[i];\n    if (item._isDestroyed) continue;\n    index = this._items.indexOf(item);\n    if (index === -1) continue;\n    if (item._isActive) needsLayout = true;\n    targetItems.push(item);\n    indices.push(allItems.indexOf(item));\n    item._destroy(opts.removeElements);\n    this._items.splice(index, 1);\n  }\n\n  // Emit remove event.\n  if (this._hasListeners(EVENT_REMOVE)) {\n    this._emit(EVENT_REMOVE, targetItems.slice(0), indices);\n  }\n\n  // If layout is needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n  return targetItems;\n};\n\n/**\n * Show specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.show = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, true, options);\n  }\n  return this;\n};\n\n/**\n * Hide specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.hide = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, false, options);\n  }\n  return this;\n};\n\n/**\n * Filter items. Expects at least one argument, a predicate, which should be\n * either a function or a string. The predicate callback is executed for every\n * item in the instance. If the return value of the predicate is truthy the\n * item in question will be shown and otherwise hidden. The predicate callback\n * receives the item instance as it's argument. If the predicate is a string\n * it is considered to be a selector and it is checked against every item\n * element in the instance with the native element.matches() method. All the\n * matching items will be shown and others hidden.\n *\n * @public\n * @param {(Function|String)} predicate\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {FilterCallback} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.filter = function (predicate, options) {\n  if (this._isDestroyed || !this._items.length) return this;\n  var itemsToShow = [];\n  var itemsToHide = [];\n  var isPredicateString = typeof predicate === STRING_TYPE;\n  var isPredicateFn = isFunction(predicate);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var syncWithLayout = opts.syncWithLayout;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var onFinish = isFunction(opts.onFinish) ? opts.onFinish : null;\n  var tryFinishCounter = -1;\n  var tryFinish = noop;\n  var item;\n  var i;\n\n  // If we have onFinish callback, let's create proper tryFinish callback.\n  if (onFinish) {\n    tryFinish = function () {\n      ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));\n    };\n  }\n\n  // Check which items need to be shown and which hidden.\n  if (isPredicateFn || isPredicateString) {\n    for (i = 0; i < this._items.length; i++) {\n      item = this._items[i];\n      if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n        itemsToShow.push(item);\n      } else {\n        itemsToHide.push(item);\n      }\n    }\n  }\n\n  // Show items that need to be shown.\n  if (itemsToShow.length) {\n    this.show(itemsToShow, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false\n    });\n  } else {\n    tryFinish();\n  }\n\n  // Hide items that need to be hidden.\n  if (itemsToHide.length) {\n    this.hide(itemsToHide, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false\n    });\n  } else {\n    tryFinish();\n  }\n\n  // If there are any items to filter.\n  if (itemsToShow.length || itemsToHide.length) {\n    // Emit filter event.\n    if (this._hasListeners(EVENT_FILTER)) {\n      this._emit(EVENT_FILTER, itemsToShow.slice(0), itemsToHide.slice(0));\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n  return this;\n};\n\n/**\n * Sort items. There are three ways to sort the items. The first is simply by\n * providing a function as the comparer which works identically to native\n * array sort. Alternatively you can sort by the sort data you have provided\n * in the instance's options. Just provide the sort data key(s) as a string\n * (separated by space) and the items will be sorted based on the provided\n * sort data keys. Lastly you have the opportunity to provide a presorted\n * array of items which will be used to sync the internal items array in the\n * same order.\n *\n * @public\n * @param {(Function|String|Item[])} comparer\n * @param {Object} [options]\n * @param {Boolean} [options.descending=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.sort = function () {\n  var sortComparer;\n  var isDescending;\n  var origItems;\n  var indexMap;\n  function defaultComparer(a, b) {\n    var result = 0;\n    var criteriaName;\n    var criteriaOrder;\n    var valA;\n    var valB;\n\n    // Loop through the list of sort criteria.\n    for (var i = 0; i < sortComparer.length; i++) {\n      // Get the criteria name, which should match an item's sort data key.\n      criteriaName = sortComparer[i][0];\n      criteriaOrder = sortComparer[i][1];\n\n      // Get items' cached sort values for the criteria. If the item has no sort\n      // data let's update the items sort data (this is a lazy load mechanism).\n      valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];\n      valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName];\n\n      // Sort the items in descending order if defined so explicitly. Otherwise\n      // sort items in ascending order.\n      if (criteriaOrder === 'desc' || !criteriaOrder && isDescending) {\n        result = valB < valA ? -1 : valB > valA ? 1 : 0;\n      } else {\n        result = valA < valB ? -1 : valA > valB ? 1 : 0;\n      }\n\n      // If we have -1 or 1 as the return value, let's return it immediately.\n      if (result) return result;\n    }\n\n    // If values are equal let's compare the item indices to make sure we\n    // have a stable sort. Note that this is not necessary in evergreen browsers\n    // because Array.sort() is nowadays stable. However, in order to guarantee\n    // same results in older browsers we need this.\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n    return result;\n  }\n  function customComparer(a, b) {\n    var result = isDescending ? -sortComparer(a, b) : sortComparer(a, b);\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n    return result;\n  }\n  return function (comparer, options) {\n    if (this._isDestroyed || this._items.length < 2) return this;\n    var items = this._items;\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n\n    // Setup parent scope data.\n    isDescending = !!opts.descending;\n    origItems = items.slice(0);\n    indexMap = null;\n\n    // If function is provided do a native array sort.\n    if (isFunction(comparer)) {\n      sortComparer = comparer;\n      items.sort(customComparer);\n    }\n    // Otherwise if we got a string, let's sort by the sort data as provided in\n    // the instance's options.\n    else if (typeof comparer === STRING_TYPE) {\n      sortComparer = comparer.trim().split(' ').filter(function (val) {\n        return val;\n      }).map(function (val) {\n        return val.split(':');\n      });\n      items.sort(defaultComparer);\n    }\n    // Otherwise if we got an array, let's assume it's a presorted array of the\n    // items and order the items based on it. Here we blindly trust that the\n    // presorted array consists of the same item instances as the current\n    // `gird._items` array.\n    else if (Array.isArray(comparer)) {\n      items.length = 0;\n      items.push.apply(items, comparer);\n    }\n    // Otherwise let's throw an error.\n    else {\n      sortComparer = isDescending = origItems = indexMap = null;\n      throw new Error('Invalid comparer argument provided.');\n    }\n\n    // Emit sort event.\n    if (this._hasListeners(EVENT_SORT)) {\n      this._emit(EVENT_SORT, items.slice(0), origItems);\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n\n    // Reset data (to avoid mem leaks).\n    sortComparer = isDescending = origItems = indexMap = null;\n    return this;\n  };\n}();\n\n/**\n * Move item to another index or in place of another item.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {String} [options.action=\"move\"]\n *   - Accepts either \"move\" or \"swap\".\n *   - \"move\" moves the item in place of the other item.\n *   - \"swap\" swaps the position of the items.\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.move = function (item, position, options) {\n  if (this._isDestroyed || this._items.length < 2) return this;\n  var items = this._items;\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var isSwap = opts.action === ACTION_SWAP;\n  var action = isSwap ? ACTION_SWAP : ACTION_MOVE;\n  var fromItem = this.getItem(item);\n  var toItem = this.getItem(position);\n  var fromIndex;\n  var toIndex;\n\n  // Make sure the items exist and are not the same.\n  if (fromItem && toItem && fromItem !== toItem) {\n    // Get the indices of the items.\n    fromIndex = items.indexOf(fromItem);\n    toIndex = items.indexOf(toItem);\n\n    // Do the move/swap.\n    if (isSwap) {\n      arraySwap(items, fromIndex, toIndex);\n    } else {\n      arrayMove(items, fromIndex, toIndex);\n    }\n\n    // Emit move event.\n    if (this._hasListeners(EVENT_MOVE)) {\n      this._emit(EVENT_MOVE, {\n        item: fromItem,\n        fromIndex: fromIndex,\n        toIndex: toIndex,\n        action: action\n      });\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n  return this;\n};\n\n/**\n * Send item to another Grid instance.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {Grid} targetGrid\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {HTMLElement} [options.appendTo=document.body]\n * @param {(Boolean|Function|String)} [options.layoutSender=true]\n * @param {(Boolean|Function|String)} [options.layoutReceiver=true]\n * @returns {Grid}\n */\nGrid.prototype.send = function (item, targetGrid, position, options) {\n  if (this._isDestroyed || targetGrid._isDestroyed || this === targetGrid) return this;\n\n  // Make sure we have a valid target item.\n  item = this.getItem(item);\n  if (!item) return this;\n  var opts = options || {};\n  var container = opts.appendTo || document.body;\n  var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n  var layoutReceiver = opts.layoutReceiver ? opts.layoutReceiver : opts.layoutReceiver === undefined;\n\n  // Start the migration process.\n  item._migrate.start(targetGrid, position, container);\n\n  // If migration was started successfully and the item is active, let's layout\n  // the grids.\n  if (item._migrate._isActive && item._isActive) {\n    if (layoutSender) {\n      this.layout(layoutSender === INSTANT_LAYOUT, isFunction(layoutSender) ? layoutSender : undefined);\n    }\n    if (layoutReceiver) {\n      targetGrid.layout(layoutReceiver === INSTANT_LAYOUT, isFunction(layoutReceiver) ? layoutReceiver : undefined);\n    }\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n *\n * @public\n * @param {Boolean} [removeElements=false]\n * @returns {Grid}\n */\nGrid.prototype.destroy = function (removeElements) {\n  if (this._isDestroyed) return this;\n  var container = this._element;\n  var items = this._items.slice(0);\n  var layoutStyles = this._layout && this._layout.styles || {};\n  var i, prop;\n\n  // Unbind window resize event listener.\n  unbindLayoutOnResize(this);\n\n  // Destroy items.\n  for (i = 0; i < items.length; i++) items[i]._destroy(removeElements);\n  this._items.length = 0;\n\n  // Restore container.\n  removeClass(container, this._settings.containerClass);\n  for (prop in layoutStyles) container.style[prop] = '';\n\n  // Emit destroy event and unbind all events.\n  this._emit(EVENT_DESTROY);\n  this._emitter.destroy();\n\n  // Remove reference from the grid instances collection.\n  delete GRID_INSTANCES[this._id];\n\n  // Flag instance as destroyed.\n  this._isDestroyed = true;\n  return this;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Emit a grid event.\n *\n * @private\n * @param {String} event\n * @param {...*} [arg]\n */\nGrid.prototype._emit = function () {\n  if (this._isDestroyed) return;\n  this._emitter.emit.apply(this._emitter, arguments);\n};\n\n/**\n * Check if there are any events listeners for an event.\n *\n * @private\n * @param {String} event\n * @returns {Boolean}\n */\nGrid.prototype._hasListeners = function (event) {\n  if (this._isDestroyed) return false;\n  return this._emitter.countListeners(event) > 0;\n};\n\n/**\n * Update container's width, height and offsets.\n *\n * @private\n */\nGrid.prototype._updateBoundingRect = function () {\n  var element = this._element;\n  var rect = element.getBoundingClientRect();\n  this._width = rect.width;\n  this._height = rect.height;\n  this._left = rect.left;\n  this._top = rect.top;\n  this._right = rect.right;\n  this._bottom = rect.bottom;\n};\n\n/**\n * Update container's border sizes.\n *\n * @private\n * @param {Boolean} left\n * @param {Boolean} right\n * @param {Boolean} top\n * @param {Boolean} bottom\n */\nGrid.prototype._updateBorders = function (left, right, top, bottom) {\n  var element = this._element;\n  if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');\n  if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');\n  if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');\n  if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');\n};\n\n/**\n * Refresh all of container's internal dimensions and offsets.\n *\n * @private\n */\nGrid.prototype._refreshDimensions = function () {\n  this._updateBoundingRect();\n  this._updateBorders(1, 1, 1, 1);\n  this._boxSizing = getStyle(this._element, 'box-sizing');\n};\n\n/**\n * Calculate and apply item positions.\n *\n * @private\n * @param {Object} layout\n */\nGrid.prototype._onLayoutDataReceived = function () {\n  var itemsToLayout = [];\n  return function (layout) {\n    if (this._isDestroyed || !this._nextLayoutData || this._nextLayoutData.id !== layout.id) return;\n    var grid = this;\n    var instant = this._nextLayoutData.instant;\n    var onFinish = this._nextLayoutData.onFinish;\n    var numItems = layout.items.length;\n    var counter = numItems;\n    var item;\n    var left;\n    var top;\n    var i;\n\n    // Reset next layout data.\n    this._nextLayoutData = null;\n    if (!this._isLayoutFinished && this._hasListeners(EVENT_LAYOUT_ABORT)) {\n      this._emit(EVENT_LAYOUT_ABORT, this._layout.items.slice(0));\n    }\n\n    // Update the layout reference.\n    this._layout = layout;\n\n    // Update the item positions and collect all items that need to be laid\n    // out. It is critical that we update the item position _before_ the\n    // layoutStart event as the new data might be needed in the callback.\n    itemsToLayout.length = 0;\n    for (i = 0; i < numItems; i++) {\n      item = layout.items[i];\n\n      // Make sure we have a matching item.\n      if (!item) {\n        --counter;\n        continue;\n      }\n\n      // Get the item's new left and top values.\n      left = layout.slots[i * 2];\n      top = layout.slots[i * 2 + 1];\n\n      // Let's skip the layout process if we can. Possibly avoids a lot of DOM\n      // operations which saves us some CPU cycles.\n      if (item._canSkipLayout(left, top)) {\n        --counter;\n        continue;\n      }\n\n      // Update the item's position.\n      item._left = left;\n      item._top = top;\n\n      // Only active non-dragged items need to be moved.\n      if (item.isActive() && !item.isDragging()) {\n        itemsToLayout.push(item);\n      } else {\n        --counter;\n      }\n    }\n\n    // Set layout styles to the grid element.\n    if (layout.styles) {\n      setStyles(this._element, layout.styles);\n    }\n\n    // layoutStart event is intentionally emitted after the container element's\n    // dimensions are set, because otherwise there would be no hook for reacting\n    // to container dimension changes.\n    if (this._hasListeners(EVENT_LAYOUT_START)) {\n      this._emit(EVENT_LAYOUT_START, layout.items.slice(0), instant === true);\n      // Let's make sure that the current layout process has not been overridden\n      // in the layoutStart event, and if so, let's stop processing the aborted\n      // layout.\n      if (this._layout.id !== layout.id) return;\n    }\n    var tryFinish = function () {\n      if (--counter > 0) return;\n      var hasLayoutChanged = grid._layout.id !== layout.id;\n      var callback = isFunction(instant) ? instant : onFinish;\n      if (!hasLayoutChanged) {\n        grid._isLayoutFinished = true;\n      }\n      if (isFunction(callback)) {\n        callback(layout.items.slice(0), hasLayoutChanged);\n      }\n      if (!hasLayoutChanged && grid._hasListeners(EVENT_LAYOUT_END)) {\n        grid._emit(EVENT_LAYOUT_END, layout.items.slice(0));\n      }\n    };\n    if (!itemsToLayout.length) {\n      tryFinish();\n      return this;\n    }\n    this._isLayoutFinished = false;\n    for (i = 0; i < itemsToLayout.length; i++) {\n      if (this._layout.id !== layout.id) break;\n      itemsToLayout[i]._layout.start(instant === true, tryFinish);\n    }\n    if (this._layout.id === layout.id) {\n      itemsToLayout.length = 0;\n    }\n    return this;\n  };\n}();\n\n/**\n * Show or hide Grid instance's items.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} toVisible\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n */\nGrid.prototype._setItemsVisibility = function (items, toVisible, options) {\n  var grid = this;\n  var targetItems = items.slice(0);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var callback = opts.onFinish;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var counter = targetItems.length;\n  var startEvent = toVisible ? EVENT_SHOW_START : EVENT_HIDE_START;\n  var endEvent = toVisible ? EVENT_SHOW_END : EVENT_HIDE_END;\n  var method = toVisible ? 'show' : 'hide';\n  var needsLayout = false;\n  var completedItems = [];\n  var hiddenItems = [];\n  var item;\n  var i;\n\n  // If there are no items call the callback, but don't emit any events.\n  if (!counter) {\n    if (isFunction(callback)) callback(targetItems);\n    return;\n  }\n\n  // Prepare the items.\n  for (i = 0; i < targetItems.length; i++) {\n    item = targetItems[i];\n\n    // If inactive item is shown or active item is hidden we need to do\n    // layout.\n    if (toVisible && !item._isActive || !toVisible && item._isActive) {\n      needsLayout = true;\n    }\n\n    // If inactive item is shown we also need to do a little hack to make the\n    // item not animate it's next positioning (layout).\n    item._layout._skipNextAnimation = !!(toVisible && !item._isActive);\n\n    // If a hidden item is being shown we need to refresh the item's\n    // dimensions.\n    if (toVisible && item._visibility._isHidden) {\n      hiddenItems.push(item);\n    }\n\n    // Add item to layout or remove it from layout.\n    if (toVisible) {\n      item._addToLayout();\n    } else {\n      item._removeFromLayout();\n    }\n  }\n\n  // Force refresh the dimensions of all hidden items.\n  if (hiddenItems.length) {\n    this.refreshItems(hiddenItems, true);\n    hiddenItems.length = 0;\n  }\n\n  // Show the items in sync with the next layout.\n  function triggerVisibilityChange() {\n    if (needsLayout && opts.syncWithLayout !== false) {\n      grid.off(EVENT_LAYOUT_START, triggerVisibilityChange);\n    }\n    if (grid._hasListeners(startEvent)) {\n      grid._emit(startEvent, targetItems.slice(0));\n    }\n    for (i = 0; i < targetItems.length; i++) {\n      // Make sure the item is still in the original grid. There is a chance\n      // that the item starts migrating before tiggerVisibilityChange is called.\n      if (targetItems[i]._gridId !== grid._id) {\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n        continue;\n      }\n      targetItems[i]._visibility[method](isInstant, function (interrupted, item) {\n        // If the current item's animation was not interrupted add it to the\n        // completedItems array.\n        if (!interrupted) completedItems.push(item);\n\n        // If all items have finished their animations call the callback\n        // and emit showEnd/hideEnd event.\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n      });\n    }\n  }\n\n  // Trigger the visibility change, either async with layout or instantly.\n  if (needsLayout && opts.syncWithLayout !== false) {\n    this.on(EVENT_LAYOUT_START, triggerVisibilityChange);\n  } else {\n    triggerVisibilityChange();\n  }\n\n  // Trigger layout if needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n};\n\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Merge default settings with user settings. The returned object is a new\n * object with merged values. The merging is a deep merge meaning that all\n * objects and arrays within the provided settings objects will be also merged\n * so that modifying the values of the settings object will have no effect on\n * the returned object.\n *\n * @param {Object} defaultSettings\n * @param {Object} [userSettings]\n * @returns {Object} Returns a new object.\n */\nfunction mergeSettings(defaultSettings, userSettings) {\n  // Create a fresh copy of default settings.\n  var settings = mergeObjects({}, defaultSettings);\n\n  // Merge user settings to default settings.\n  if (userSettings) {\n    settings = mergeObjects(settings, userSettings);\n  }\n\n  // Handle visible/hidden styles manually so that the whole object is\n  // overridden instead of the props.\n\n  if (userSettings && userSettings.visibleStyles) {\n    settings.visibleStyles = userSettings.visibleStyles;\n  } else if (defaultSettings && defaultSettings.visibleStyles) {\n    settings.visibleStyles = defaultSettings.visibleStyles;\n  }\n  if (userSettings && userSettings.hiddenStyles) {\n    settings.hiddenStyles = userSettings.hiddenStyles;\n  } else if (defaultSettings && defaultSettings.hiddenStyles) {\n    settings.hiddenStyles = defaultSettings.hiddenStyles;\n  }\n  return settings;\n}\n\n/**\n * Merge two objects recursively (deep merge). The source object's properties\n * are merged to the target object.\n *\n * @param {Object} target\n *   - The target object.\n * @param {Object} source\n *   - The source object.\n * @returns {Object} Returns the target object.\n */\nfunction mergeObjects(target, source) {\n  var sourceKeys = Object.keys(source);\n  var length = sourceKeys.length;\n  var isSourceObject;\n  var propName;\n  var i;\n  for (i = 0; i < length; i++) {\n    propName = sourceKeys[i];\n    isSourceObject = isPlainObject(source[propName]);\n\n    // If target and source values are both objects, merge the objects and\n    // assign the merged value to the target property.\n    if (isPlainObject(target[propName]) && isSourceObject) {\n      target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);\n      continue;\n    }\n\n    // If source's value is object and target's is not let's clone the object as\n    // the target's value.\n    if (isSourceObject) {\n      target[propName] = mergeObjects({}, source[propName]);\n      continue;\n    }\n\n    // If source's value is an array let's clone the array as the target's\n    // value.\n    if (Array.isArray(source[propName])) {\n      target[propName] = source[propName].slice(0);\n      continue;\n    }\n\n    // In all other cases let's just directly assign the source's value as the\n    // target's value.\n    target[propName] = source[propName];\n  }\n  return target;\n}\n\n/**\n * Collect and return initial items for grid.\n *\n * @param {HTMLElement} gridElement\n * @param {?(HTMLElement[]|NodeList|HtmlCollection|String)} elements\n * @returns {(HTMLElement[]|NodeList|HtmlCollection)}\n */\nfunction getInitialGridElements(gridElement, elements) {\n  // If we have a wildcard selector let's return all the children.\n  if (elements === '*') {\n    return gridElement.children;\n  }\n\n  // If we have some more specific selector, let's filter the elements.\n  if (typeof elements === STRING_TYPE) {\n    var result = [];\n    var children = gridElement.children;\n    for (var i = 0; i < children.length; i++) {\n      if (elementMatches(children[i], elements)) {\n        result.push(children[i]);\n      }\n    }\n    return result;\n  }\n\n  // If we have an array of elements or a node list.\n  if (Array.isArray(elements) || isNodeList(elements)) {\n    return elements;\n  }\n\n  // Otherwise just return an empty array.\n  return [];\n}\n\n/**\n * Bind grid's resize handler to window.\n *\n * @param {Grid} grid\n * @param {(Number|Boolean)} delay\n */\nfunction bindLayoutOnResize(grid, delay) {\n  if (typeof delay !== NUMBER_TYPE) {\n    delay = delay === true ? 0 : -1;\n  }\n  if (delay >= 0) {\n    grid._resizeHandler = debounce(function () {\n      grid.refreshItems().layout();\n    }, delay);\n    window.addEventListener('resize', grid._resizeHandler);\n  }\n}\n\n/**\n * Unbind grid's resize handler from window.\n *\n * @param {Grid} grid\n */\nfunction unbindLayoutOnResize(grid) {\n  if (grid._resizeHandler) {\n    grid._resizeHandler(true);\n    window.removeEventListener('resize', grid._resizeHandler);\n    grid._resizeHandler = null;\n  }\n}\n\n/**\n * Normalize style declaration object, returns a normalized (new) styles object\n * (prefixed properties and invalid properties removed).\n *\n * @param {Object} styles\n * @returns {Object}\n */\nfunction normalizeStyles(styles) {\n  var normalized = {};\n  var docElemStyle = document.documentElement.style;\n  var prop, prefixedProp;\n\n  // Normalize visible styles (prefix and remove invalid).\n  for (prop in styles) {\n    if (!styles[prop]) continue;\n    prefixedProp = getPrefixedPropName(docElemStyle, prop);\n    if (!prefixedProp) continue;\n    normalized[prefixedProp] = styles[prop];\n  }\n  return normalized;\n}\n\n/**\n * Create index map from items.\n *\n * @param {Item[]} items\n * @returns {Object}\n */\nfunction createIndexMap(items) {\n  var result = {};\n  for (var i = 0; i < items.length; i++) {\n    result[items[i]._id] = i;\n  }\n  return result;\n}\n\n/**\n * Sort comparer function for items' index map.\n *\n * @param {Object} indexMap\n * @param {Item} itemA\n * @param {Item} itemB\n * @returns {Number}\n */\nfunction compareIndexMap(indexMap, itemA, itemB) {\n  var indexA = indexMap[itemA._id];\n  var indexB = indexMap[itemB._id];\n  return indexA - indexB;\n}\nexport default Grid;","map":{"version":3,"names":["GRID_INSTANCES","ITEM_ELEMENT_MAP","Map","ACTION_SWAP","ACTION_MOVE","EVENT_SYNCHRONIZE","EVENT_LAYOUT_START","EVENT_LAYOUT_END","EVENT_LAYOUT_ABORT","EVENT_ADD","EVENT_REMOVE","EVENT_SHOW_START","EVENT_SHOW_END","EVENT_HIDE_START","EVENT_HIDE_END","EVENT_FILTER","EVENT_SORT","EVENT_MOVE","EVENT_SEND","EVENT_BEFORE_SEND","EVENT_RECEIVE","EVENT_BEFORE_RECEIVE","EVENT_DRAG_INIT","EVENT_DRAG_START","EVENT_DRAG_MOVE","EVENT_DRAG_SCROLL","EVENT_DRAG_END","EVENT_DRAG_RELEASE_START","EVENT_DRAG_RELEASE_END","EVENT_DESTROY","HAS_TOUCH_EVENTS","window","HAS_POINTER_EVENTS","PointerEvent","HAS_MS_POINTER_EVENTS","navigator","msPointerEnabled","MAX_SAFE_FLOAT32_INTEGER","Emitter","_events","_queue","_counter","_clearOnEmit","prototype","on","event","listener","listeners","push","off","length","index","indexOf","splice","clear","emit","queue","startIndex","argsLength","arguments","args","apply","shift","i","endIndex","burst","countListeners","destroy","pointerout","waitDuration","EdgeHack","dragger","_dragger","_timeout","_outEvent","_isActive","_addBehaviour","bind","_removeBehaviour","_onTimeout","_resetData","_onStart","_onOut","addEventListener","removeEventListener","clearTimeout","e","pointerType","_getTrackedTouch","setTimeout","isActive","_onCancel","vendorPrefixes","cache$2","getPrefixedPropName","style","prop","prefixedProp","camelProp","toUpperCase","slice","hasPassiveEvents","isPassiveEventsSupported","passiveOpts","Object","defineProperty","get","ua","userAgent","toLowerCase","isEdge","isIE","isFirefox","isAndroid","listenerOptions","passive","taProp","taPropPrefixed","document","documentElement","taDefaultValue","Dragger","element","cssProps","_element","_emitter","_isDestroyed","_cssProps","_touchAction","_pointerId","_startTime","_startX","_startY","_currentX","_currentY","_onMove","_onEnd","_edgeHack","setCssProps","setTouchAction","_preventDefault","_inputEvents","start","_pointerEvents","move","cancel","end","_msPointerEvents","_touchEvents","_mouseEvents","_emitterEvents","_activeInstances","preventDefault","cancelable","_activateInstance","instance","_bindListeners","_deactivateInstance","_unbindListeners","_getEventPointerId","pointerId","changedTouches","identifier","_getTouchById","id","_reset","_createEvent","type","touch","srcEvent","distance","getDistance","deltaX","getDeltaX","deltaY","getDeltaY","deltaTime","getDeltaTime","isFirst","isFinal","touches","screenX","screenY","clientX","clientY","pageX","pageY","target","_emit","Date","now","value","newProps","currentProps","x","y","Math","sqrt","eventName","dt","raf","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","callback","Ticker","numLanes","_nextStep","_lanes","_stepQueue","_stepCallbacks","_step","TickerLane","time","lanes","stepQueue","stepCallbacks","j","laneQueue","laneCallbacks","laneIndices","callbacks","indices","add","laneIndex","remove","undefined","LAYOUT_READ","LAYOUT_WRITE","VISIBILITY_READ","VISIBILITY_WRITE","DRAG_START_READ","DRAG_START_WRITE","DRAG_MOVE_READ","DRAG_MOVE_WRITE","DRAG_SCROLL_READ","DRAG_SCROLL_WRITE","DRAG_SORT_READ","PLACEHOLDER_LAYOUT_READ","PLACEHOLDER_LAYOUT_WRITE","PLACEHOLDER_RESIZE_WRITE","AUTO_SCROLL_READ","AUTO_SCROLL_WRITE","DEBOUNCE_READ","LANE_READ","LANE_READ_TAIL","LANE_WRITE","ticker","addLayoutTick","itemId","read","write","cancelLayoutTick","addVisibilityTick","cancelVisibilityTick","addDragStartTick","cancelDragStartTick","addDragMoveTick","cancelDragMoveTick","addDragScrollTick","cancelDragScrollTick","addDragSortTick","cancelDragSortTick","addPlaceholderLayoutTick","cancelPlaceholderLayoutTick","addPlaceholderResizeTick","cancelPlaceholderResizeTick","addAutoScrollTick","cancelAutoScrollTick","addDebounceTick","debounceId","cancelDebounceTick","AXIS_X","AXIS_Y","FORWARD","BACKWARD","LEFT","RIGHT","UP","DOWN","functionType","isFunction","val","cache$1","WeakMap","getStyle","styles","getComputedStyle","set","getPropertyValue","getStyleAsFloat","el","parseFloat","DOC_ELEM","BODY","body","THRESHOLD_DATA","offset","getScrollElement","getScrollLeft","pageXOffset","scrollLeft","getScrollTop","pageYOffset","scrollTop","getScrollLeftMax","scrollWidth","clientWidth","getScrollTopMax","scrollHeight","clientHeight","getContentRect","result","width","height","left","right","top","bottom","bcr","getBoundingClientRect","borderLeft","clientLeft","borderTop","clientTop","getItemAutoScrollSettings","item","_drag","_getGrid","_settings","dragAutoScroll","prepareItemScrollSync","_prepareScroll","applyItemScrollSync","drag","_scrollDiffX","_scrollDiffY","_setTranslate","_left","_top","computeThreshold","threshold","safeZone","itemSize","targetSize","min","max","ScrollRequest","reset","onStop","isEnding","direction","maxValue","speed","duration","action","hasReachedEnd","computeCurrentScrollValue","computeNextScrollValue","delta","nextValue","computeSpeed","data","tick","onStart","sort","ScrollAction","requestX","requestY","addRequest","request","removeRequest","computeScrollValues","scroll","scrollTo","Pool","createItem","releaseItem","pool","pick","pop","release","isOverlapping","a","b","getIntersectionArea","getIntersectionScore","area","maxArea","RECT_1","RECT_2","AutoScroller","_isTicking","_tickTime","_tickDeltaTime","_items","_actions","_requests","_requestOverlapCheck","_dragPositions","_dragDirections","_overlapCheckInterval","_requestPool","_actionPool","_readTick","_writeTick","smoothSpeed","maxSpeed","acceleration","deceleration","targetSpeed","factor","currentSpeed","nextSpeed","pointerHandle","pointerSize","rect","size","w","h","pX","pY","_updateRequests","_updateActions","_applyActions","_startTicking","_stopTicking","_getItemHandleRect","handle","itemDrag","ev","_dragMoveEvent","_dragStartEvent","_clientX","_clientY","_width","_height","_requestItemScroll","axis","reqMap","_id","_cancelItemScroll","_checkItemOverlap","checkX","checkY","settings","targets","dragDirections","dragDirectionX","dragDirectionY","itemRect","testRect","testElement","testAxisX","testAxisY","testScore","testPriority","testThreshold","testDirection","testDistance","testMaxScrollX","testMaxScrollY","xElement","xPriority","Infinity","xThreshold","xScore","xDirection","xDistance","xMaxScroll","yElement","yPriority","yThreshold","yScore","yDirection","yDistance","yMaxScroll","priority","_updateScrollRequest","scrollRequest","targetCount","testIsAxisX","testScroll","testMaxScroll","smoothStop","items","requestsX","requestsY","reqX","reqY","checkTime","needsCheck","_requestAction","actions","isAxisX","requests","_updateDragDirection","dragPositions","x1","y1","x2","y2","addItem","updateItem","removeItem","isItemScrollingX","isItemScrollingY","isItemScrolling","ElProto","Element","matchesFn","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","elementMatches","selector","call","addClass","className","classList","tempArray","numberType","arrayInsert","array","concat","normalizeArrayIndex","sizeOffset","maxIndex","arrayMove","fromIndex","toIndex","from","to","arraySwap","withIndex","indexA","indexB","temp","transformProp","styleNameRegEx","prefixRegex","msPrefixRegex","getStyleName","property","styleName","replace","transformStyle","transformNone$1","displayInline","displayNone","displayStyle","isTransformed","transform","display","getContainingBlock","doc","res","parentElement","offsetA","offsetB","offsetDiff","getOffset","offsetData","self","getOffsetDiff","elemA","elemB","compareContainingBlocks","isScrollableOverflow","isScrollable","getScrollableAncestors","getRootNode","DocumentFragment","host","parentNode","translateValue","transformNone","rxMat3d","rxMatTx","rxMat3dTx","rxNextItem","getTranslate","isMat3d","test","tX","tY","removeClass","trim","IS_IOS","platform","maxTouchPoints","START_PREDICATE_INACTIVE","START_PREDICATE_PENDING","START_PREDICATE_RESOLVED","SCROLL_LISTENER_OPTIONS","ItemDrag","grid","getGrid","_item","_gridId","_isMigrating","_startPredicate","dragStartPredicate","defaultStartPredicate","_startPredicateState","_startPredicateResult","_isSortNeeded","_sortTimer","_blockedSortIndex","_sortX1","_sortX2","_sortY1","_sortY2","_preStartCheck","_preEndCheck","_onScroll","_prepareStart","_applyStart","_prepareMove","_applyMove","_applyScroll","_handleSort","_handleSortDelayed","_handle","dragHandle","querySelector","dragCssProps","autoScroller","options","button","isTrusted","defaultPrevented","_finishStartPredicate","predicate","_startPredicateData","config","delay","delayTimer","_resolveStartPredicate","_forceResolveStartPredicate","_resetStartPredicate","defaultSortPredicate","targetRect","returnData","gridsArray","minThreshold","maxThreshold","getTargetGrid","rootGrid","dragSort","bestScore","gridScore","grids","container","containerRect","Array","isArray","_updateBoundingRect","innerWidth","_right","innerHeight","_bottom","sortThreshold","sortAction","migrateAction","isMigration","gridOffsetLeft","gridOffsetTop","matchScore","matchIndex","hasValidTargets","score","_gridX","_marginLeft","_gridY","_marginTop","_updateBorders","_borderLeft","_borderTop","stop","_finishMigration","_cancelSort","_isStarted","_unbindScrollListeners","draggingClass","itemDraggingClass","appendChild","force","_container","_containingBlock","_dragPrevMoveEvent","_scrollEvent","_scrollers","_moveDiffX","_moveDiffY","_containerDiffX","_containerDiffY","_bindScrollListeners","gridContainer","dragContainer","scrollers","gridScrollers","isClick","abs","openAnchorHref","_resetHeuristics","_checkHeuristics","dragSortHeuristics","minDist","minDragDistance","diffX","diffY","canCheckBounceBack","minBounceBackAngle","angle","atan2","prevAngle","deltaAngle","sin","cos","sortDuringScroll","shouldSort","sortInterval","_checkOverlap","_finishSort","isSortEnabled","needsFinalCheck","currentGrid","currentIndex","targetGrid","targetIndex","targetItem","dragSortPredicate","_hasListeners","layout","fromGrid","toGrid","_sortData","send","appendTo","layoutSender","layoutReceiver","_dragRelease","targetGridElement","targetSettings","targetContainer","currentSettings","currentContainer","currentVisClass","itemVisibleClass","itemHiddenClass","nextVisClass","translate","itemClass","_refreshDimensions","dragEnabled","_visibility","setStyles","visibleStyles","hiddenStyles","isResolved","containingBlock","elementRect","hasDragContainer","migrate","_migrate","isPositioning","_layout","isReleasing","dragPlaceholder","enabled","_dragPlaceholder","create","dragAxis","nextEvent","prevEvent","moveDiffX","moveDiffY","scrollDiffX","scrollDiffY","tagName","href","getAttribute","open","location","getCurrentStyles","unprefixRegEx","cache","getUnprefixedPropName","nativeCode","isNative","feat","S","Symbol","toString","HAS_WEB_ANIMATIONS","animate","HAS_NATIVE_WEB_ANIMATIONS","Animator","_animation","_duration","_easing","_callback","_props","_values","_onFinish","propsFrom","propsTo","opts","onFinish","animation","currentValues","easing","cancelAnimation","propName","propCount","propIndex","createFrame","onfinish","isAnimating","props","prefix","frame","getTranslateString","ItemDragPlaceholder","_className","_didMigrate","_resetAfterLayout","_transX","_transY","_nextTransX","_nextTransY","_setupAnimation","_startAnimation","_updateDimensions","_onLayoutStart","_onLayoutEnd","_onReleaseEnd","_onMigrate","_onHide","isInstant","nextLeft","nextTop","currentLeft","currentTop","nextX","nextY","animEnabled","layoutDuration","getElement","currentX","currentY","currentStyles","targetStyles","layoutEasing","nextGrid","createElement","itemPlaceholderClass","position","onCreate","removeChild","onRemove","updateDimensions","ItemDragRelease","_isPositioningStarted","itemReleasingClass","dragRelease","useDragContainer","_placeToGrid","_nextLayoutData","abort","didReparent","isJustReleased","needsReflow","releasingClass","MIN_ANIMATION_DISTANCE","ItemLayout","elementStyle","_isInterrupted","_currentStyles","_targetStyles","_nextLeft","_nextTop","_offsetLeft","_offsetTop","_skipNextAnimation","_animOptions","_finish","instant","gridSettings","animDuration","animEasing","_updateOffsets","processCallbackQueue","itemPositioningClass","_tX","_tY","xDiff","yDiff","ItemMigrate","isVisible","targetElement","targetItems","containerDiff","translateX","translateY","getItem","gridElement","ItemVisibility","childElement","children","Error","_isHidden","_isHiding","_isShowing","_childElement","_currentStyleProps","_finishShow","_finishHide","show","hide","currentStyleProps","_removeCurrentStyles","toVisible","showDuration","hideDuration","showEasing","hideEasing","createUid","Item","has","_marginRight","_marginBottom","getWidth","getHeight","getMargin","getPosition","isShowing","isHiding","isDragging","isDestroyed","_refreshSortData","getters","sortData","_addToLayout","_removeFromLayout","_canSkipLayout","_destroy","removeElement","delete","createPackerProcessor","isWorker","FILL_GAPS","HORIZONTAL","ALIGN_RIGHT","ALIGN_BOTTOM","ROUNDING","EPS","MIN_SLOT_SIZE","roundNumber","number","PackerProcessor","currentRects","nextRects","rectTarget","rectStore","slotSizes","rectId","slotIndex","slotData","sortRectsLeftTop","sortRectsTopLeft","computeLayout","slots","fillGaps","horizontal","alignRight","alignBottom","rounding","isPreProcessed","bump","slotWidth","slotHeight","slot","computeNextSlot","ignoreCurrentRects","shards","getRect","addRect","splitRect","purgeRects","hole","isRectAWithinRectB","rectA","rectB","rectIds","aId","bId","PACKET_INDEX_WIDTH","PACKET_INDEX_HEIGHT","PACKET_INDEX_OPTIONS","PACKET_HEADER_SLOTS","processor","onmessage","msg","Float32Array","subarray","postMessage","buffer","blobUrl","activeWorkers","createWorkerProcessors","amount","workers","URL","createObjectURL","Blob","worker","Worker","destroyWorkerProcessors","onerror","onmessageerror","terminate","revokeObjectURL","isWorkerProcessorsSupported","PACKET_INDEX_ID","Packer","numWorkers","_options","_processor","_layoutQueue","_layouts","_layoutCallbacks","_layoutWorkers","_layoutWorkerData","_workers","_onWorkerMessage","setOptions","_sendToWorker","layoutId","_finalizeLayout","_grid","isHorizontal","isBorderBox","_boxSizing","_borderRight","_borderBottom","createLayout","cancelLayout","queueIndex","key","debounce","fn","durationMs","timer","lastTime","isCanceled","htmlCollectionType","nodeListType","isNodeList","objectType","objectToStringType","isPlainObject","noop","toArray","NUMBER_TYPE","STRING_TYPE","INSTANT_LAYOUT","Grid","isElementInDom","composed","contains","mergeSettings","defaultOptions","normalizeStyles","_isLayoutFinished","_onLayoutDataReceived","containerClass","bindLayoutOnResize","layoutOnResize","getInitialGridElements","layoutOnInit","defaultPacker","opacity","touchAction","userSelect","userDrag","tapHighlightColor","touchCallout","contentZooming","getItems","refreshItems","hiddenItemStyles","visibility","refreshSortData","synchronize","fragment","createDocumentFragment","unfinishedLayout","nextLayoutId","layoutItems","gridWidth","gridHeight","layoutSettings","elements","newItems","needsLayout","active","allItems","removeElements","_setItemsVisibility","filter","itemsToShow","itemsToHide","isPredicateString","isPredicateFn","syncWithLayout","tryFinishCounter","tryFinish","sortComparer","isDescending","origItems","indexMap","defaultComparer","criteriaName","criteriaOrder","valA","valB","createIndexMap","compareIndexMap","customComparer","comparer","descending","split","map","isSwap","fromItem","toItem","layoutStyles","unbindLayoutOnResize","itemsToLayout","numItems","counter","hasLayoutChanged","startEvent","endEvent","method","completedItems","hiddenItems","triggerVisibilityChange","interrupted","defaultSettings","userSettings","mergeObjects","source","sourceKeys","keys","isSourceObject","_resizeHandler","normalized","docElemStyle","itemA","itemB"],"sources":["C:/Users/ericg/OneDrive/Bureau/Pro/Code/Projet-2-SpotCast/2023-02-js-btz-spotcast/node_modules/muuri/dist/muuri.module.js"],"sourcesContent":["/**\n* Muuri v0.9.5\n* https://muuri.dev/\n* Copyright (c) 2015-present, Haltu Oy\n* Released under the MIT license\n* https://github.com/haltu/muuri/blob/master/LICENSE.md\n* @license MIT\n*\n* Muuri Packer\n* Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri Ticker / Muuri Emitter / Muuri Dragger\n* Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri AutoScroller\n* Copyright (c) 2019-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*/\n\nvar GRID_INSTANCES = {};\nvar ITEM_ELEMENT_MAP = typeof Map === 'function' ? new Map() : null;\n\nvar ACTION_SWAP = 'swap';\nvar ACTION_MOVE = 'move';\n\nvar EVENT_SYNCHRONIZE = 'synchronize';\nvar EVENT_LAYOUT_START = 'layoutStart';\nvar EVENT_LAYOUT_END = 'layoutEnd';\nvar EVENT_LAYOUT_ABORT = 'layoutAbort';\nvar EVENT_ADD = 'add';\nvar EVENT_REMOVE = 'remove';\nvar EVENT_SHOW_START = 'showStart';\nvar EVENT_SHOW_END = 'showEnd';\nvar EVENT_HIDE_START = 'hideStart';\nvar EVENT_HIDE_END = 'hideEnd';\nvar EVENT_FILTER = 'filter';\nvar EVENT_SORT = 'sort';\nvar EVENT_MOVE = 'move';\nvar EVENT_SEND = 'send';\nvar EVENT_BEFORE_SEND = 'beforeSend';\nvar EVENT_RECEIVE = 'receive';\nvar EVENT_BEFORE_RECEIVE = 'beforeReceive';\nvar EVENT_DRAG_INIT = 'dragInit';\nvar EVENT_DRAG_START = 'dragStart';\nvar EVENT_DRAG_MOVE = 'dragMove';\nvar EVENT_DRAG_SCROLL = 'dragScroll';\nvar EVENT_DRAG_END = 'dragEnd';\nvar EVENT_DRAG_RELEASE_START = 'dragReleaseStart';\nvar EVENT_DRAG_RELEASE_END = 'dragReleaseEnd';\nvar EVENT_DESTROY = 'destroy';\n\nvar HAS_TOUCH_EVENTS = 'ontouchstart' in window;\nvar HAS_POINTER_EVENTS = !!window.PointerEvent;\nvar HAS_MS_POINTER_EVENTS = !!window.navigator.msPointerEnabled;\n\nvar MAX_SAFE_FLOAT32_INTEGER = 16777216;\n\n/**\n * Event emitter constructor.\n *\n * @class\n */\nfunction Emitter() {\n  this._events = {};\n  this._queue = [];\n  this._counter = 0;\n  this._clearOnEmit = false;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\nEmitter.prototype.on = function (event, listener) {\n  if (!this._events || !event || !listener) return this;\n\n  // Get listeners queue and create it if it does not exist.\n  var listeners = this._events[event];\n  if (!listeners) listeners = this._events[event] = [];\n\n  // Add the listener to the queue.\n  listeners.push(listener);\n\n  return this;\n};\n\n/**\n * Unbind all event listeners that match the provided listener function.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\nEmitter.prototype.off = function (event, listener) {\n  if (!this._events || !event || !listener) return this;\n\n  // Get listeners and return immediately if none is found.\n  var listeners = this._events[event];\n  if (!listeners || !listeners.length) return this;\n\n  // Remove all matching listeners.\n  var index;\n  while ((index = listeners.indexOf(listener)) !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  return this;\n};\n\n/**\n * Unbind all listeners of the provided event.\n *\n * @public\n * @param {String} event\n * @returns {Emitter}\n */\nEmitter.prototype.clear = function (event) {\n  if (!this._events || !event) return this;\n\n  var listeners = this._events[event];\n  if (listeners) {\n    listeners.length = 0;\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Emit all listeners in a specified event with the provided arguments.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\nEmitter.prototype.emit = function (event) {\n  if (!this._events || !event) {\n    this._clearOnEmit = false;\n    return this;\n  }\n\n  // Get event listeners and quit early if there's no listeners.\n  var listeners = this._events[event];\n  if (!listeners || !listeners.length) {\n    this._clearOnEmit = false;\n    return this;\n  }\n\n  var queue = this._queue;\n  var startIndex = queue.length;\n  var argsLength = arguments.length - 1;\n  var args;\n\n  // If we have more than 3 arguments let's put the arguments in an array and\n  // apply it to the listeners.\n  if (argsLength > 3) {\n    args = [];\n    args.push.apply(args, arguments);\n    args.shift();\n  }\n\n  // Add the current listeners to the callback queue before we process them.\n  // This is necessary to guarantee that all of the listeners are called in\n  // correct order even if new event listeners are removed/added during\n  // processing and/or events are emitted during processing.\n  queue.push.apply(queue, listeners);\n\n  // Reset the event's listeners if need be.\n  if (this._clearOnEmit) {\n    listeners.length = 0;\n    this._clearOnEmit = false;\n  }\n\n  // Increment queue counter. This is needed for the scenarios where emit is\n  // triggered while the queue is already processing. We need to keep track of\n  // how many \"queue processors\" there are active so that we can safely reset\n  // the queue in the end when the last queue processor is finished.\n  ++this._counter;\n\n  // Process the queue (the specific part of it for this emit).\n  var i = startIndex;\n  var endIndex = queue.length;\n  for (; i < endIndex; i++) {\n    // prettier-ignore\n    argsLength === 0 ? queue[i]() :\n    argsLength === 1 ? queue[i](arguments[1]) :\n    argsLength === 2 ? queue[i](arguments[1], arguments[2]) :\n    argsLength === 3 ? queue[i](arguments[1], arguments[2], arguments[3]) :\n                       queue[i].apply(null, args);\n\n    // Stop processing if the emitter is destroyed.\n    if (!this._events) return this;\n  }\n\n  // Decrement queue process counter.\n  --this._counter;\n\n  // Reset the queue if there are no more queue processes running.\n  if (!this._counter) queue.length = 0;\n\n  return this;\n};\n\n/**\n * Emit all listeners in a specified event with the provided arguments and\n * remove the event's listeners just before calling the them. This method allows\n * the emitter to serve as a queue where all listeners are called only once.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\nEmitter.prototype.burst = function () {\n  if (!this._events) return this;\n  this._clearOnEmit = true;\n  this.emit.apply(this, arguments);\n  return this;\n};\n\n/**\n * Check how many listeners there are for a specific event.\n *\n * @public\n * @param {String} event\n * @returns {Boolean}\n */\nEmitter.prototype.countListeners = function (event) {\n  if (!this._events) return 0;\n  var listeners = this._events[event];\n  return listeners ? listeners.length : 0;\n};\n\n/**\n * Destroy emitter instance. Basically just removes all bound listeners.\n *\n * @public\n * @returns {Emitter}\n */\nEmitter.prototype.destroy = function () {\n  if (!this._events) return this;\n  this._queue.length = this._counter = 0;\n  this._events = null;\n  return this;\n};\n\nvar pointerout = HAS_POINTER_EVENTS ? 'pointerout' : HAS_MS_POINTER_EVENTS ? 'MSPointerOut' : '';\nvar waitDuration = 100;\n\n/**\n * If you happen to use Edge or IE on a touch capable device there is a\n * a specific case where pointercancel and pointerend events are never emitted,\n * even though one them should always be emitted when you release your finger\n * from the screen. The bug appears specifically when Muuri shifts the dragged\n * element's position in the DOM after pointerdown event, IE and Edge don't like\n * that behaviour and quite often forget to emit the pointerend/pointercancel\n * event. But, they do emit pointerout event so we utilize that here.\n * Specifically, if there has been no pointermove event within 100 milliseconds\n * since the last pointerout event we force cancel the drag operation. This hack\n * works surprisingly well 99% of the time. There is that 1% chance there still\n * that dragged items get stuck but it is what it is.\n *\n * @class\n * @param {Dragger} dragger\n */\nfunction EdgeHack(dragger) {\n  if (!pointerout) return;\n\n  this._dragger = dragger;\n  this._timeout = null;\n  this._outEvent = null;\n  this._isActive = false;\n\n  this._addBehaviour = this._addBehaviour.bind(this);\n  this._removeBehaviour = this._removeBehaviour.bind(this);\n  this._onTimeout = this._onTimeout.bind(this);\n  this._resetData = this._resetData.bind(this);\n  this._onStart = this._onStart.bind(this);\n  this._onOut = this._onOut.bind(this);\n\n  this._dragger.on('start', this._onStart);\n}\n\n/**\n * @private\n */\nEdgeHack.prototype._addBehaviour = function () {\n  if (this._isActive) return;\n  this._isActive = true;\n  this._dragger.on('move', this._resetData);\n  this._dragger.on('cancel', this._removeBehaviour);\n  this._dragger.on('end', this._removeBehaviour);\n  window.addEventListener(pointerout, this._onOut);\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._removeBehaviour = function () {\n  if (!this._isActive) return;\n  this._dragger.off('move', this._resetData);\n  this._dragger.off('cancel', this._removeBehaviour);\n  this._dragger.off('end', this._removeBehaviour);\n  window.removeEventListener(pointerout, this._onOut);\n  this._resetData();\n  this._isActive = false;\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._resetData = function () {\n  window.clearTimeout(this._timeout);\n  this._timeout = null;\n  this._outEvent = null;\n};\n\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nEdgeHack.prototype._onStart = function (e) {\n  if (e.pointerType === 'mouse') return;\n  this._addBehaviour();\n};\n\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nEdgeHack.prototype._onOut = function (e) {\n  if (!this._dragger._getTrackedTouch(e)) return;\n  this._resetData();\n  this._outEvent = e;\n  this._timeout = window.setTimeout(this._onTimeout, waitDuration);\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._onTimeout = function () {\n  var e = this._outEvent;\n  this._resetData();\n  if (this._dragger.isActive()) this._dragger._onCancel(e);\n};\n\n/**\n * @public\n */\nEdgeHack.prototype.destroy = function () {\n  if (!pointerout) return;\n  this._dragger.off('start', this._onStart);\n  this._removeBehaviour();\n};\n\n// Playing it safe here, test all potential prefixes capitalized and lowercase.\nvar vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o', 'Webkit', 'Moz', 'MS', 'O'];\nvar cache$2 = {};\n\n/**\n * Get prefixed CSS property name when given a non-prefixed CSS property name.\n * Returns null if the property is not supported at all.\n *\n * @param {CSSStyleDeclaration} style\n * @param {String} prop\n * @returns {String}\n */\nfunction getPrefixedPropName(style, prop) {\n  var prefixedProp = cache$2[prop] || '';\n  if (prefixedProp) return prefixedProp;\n\n  var camelProp = prop[0].toUpperCase() + prop.slice(1);\n  var i = 0;\n  while (i < vendorPrefixes.length) {\n    prefixedProp = vendorPrefixes[i] ? vendorPrefixes[i] + camelProp : prop;\n    if (prefixedProp in style) {\n      cache$2[prop] = prefixedProp;\n      return prefixedProp;\n    }\n    ++i;\n  }\n\n  return '';\n}\n\n/**\n * Check if passive events are supported.\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n *\n * @returns {Boolean}\n */\nfunction hasPassiveEvents() {\n  var isPassiveEventsSupported = false;\n\n  try {\n    var passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        isPassiveEventsSupported = true;\n      },\n    });\n    window.addEventListener('testPassive', null, passiveOpts);\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n\n  return isPassiveEventsSupported;\n}\n\nvar ua = window.navigator.userAgent.toLowerCase();\nvar isEdge = ua.indexOf('edge') > -1;\nvar isIE = ua.indexOf('trident') > -1;\nvar isFirefox = ua.indexOf('firefox') > -1;\nvar isAndroid = ua.indexOf('android') > -1;\n\nvar listenerOptions = hasPassiveEvents() ? { passive: true } : false;\n\nvar taProp = 'touchAction';\nvar taPropPrefixed = getPrefixedPropName(document.documentElement.style, taProp);\nvar taDefaultValue = 'auto';\n\n/**\n * Creates a new Dragger instance for an element.\n *\n * @public\n * @class\n * @param {HTMLElement} element\n * @param {Object} [cssProps]\n */\nfunction Dragger(element, cssProps) {\n  this._element = element;\n  this._emitter = new Emitter();\n  this._isDestroyed = false;\n  this._cssProps = {};\n  this._touchAction = '';\n  this._isActive = false;\n\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n\n  this._onStart = this._onStart.bind(this);\n  this._onMove = this._onMove.bind(this);\n  this._onCancel = this._onCancel.bind(this);\n  this._onEnd = this._onEnd.bind(this);\n\n  // Can't believe had to build a freaking class for a hack!\n  this._edgeHack = null;\n  if ((isEdge || isIE) && (HAS_POINTER_EVENTS || HAS_MS_POINTER_EVENTS)) {\n    this._edgeHack = new EdgeHack(this);\n  }\n\n  // Apply initial CSS props.\n  this.setCssProps(cssProps);\n\n  // If touch action was not provided with initial CSS props let's assume it's\n  // auto.\n  if (!this._touchAction) {\n    this.setTouchAction(taDefaultValue);\n  }\n\n  // Prevent native link/image dragging for the item and it's children.\n  element.addEventListener('dragstart', Dragger._preventDefault, false);\n\n  // Listen to start event.\n  element.addEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n}\n\n/**\n * Protected properties\n * ********************\n */\n\nDragger._pointerEvents = {\n  start: 'pointerdown',\n  move: 'pointermove',\n  cancel: 'pointercancel',\n  end: 'pointerup',\n};\n\nDragger._msPointerEvents = {\n  start: 'MSPointerDown',\n  move: 'MSPointerMove',\n  cancel: 'MSPointerCancel',\n  end: 'MSPointerUp',\n};\n\nDragger._touchEvents = {\n  start: 'touchstart',\n  move: 'touchmove',\n  cancel: 'touchcancel',\n  end: 'touchend',\n};\n\nDragger._mouseEvents = {\n  start: 'mousedown',\n  move: 'mousemove',\n  cancel: '',\n  end: 'mouseup',\n};\n\nDragger._inputEvents = (function () {\n  if (HAS_TOUCH_EVENTS) return Dragger._touchEvents;\n  if (HAS_POINTER_EVENTS) return Dragger._pointerEvents;\n  if (HAS_MS_POINTER_EVENTS) return Dragger._msPointerEvents;\n  return Dragger._mouseEvents;\n})();\n\nDragger._emitter = new Emitter();\n\nDragger._emitterEvents = {\n  start: 'start',\n  move: 'move',\n  end: 'end',\n  cancel: 'cancel',\n};\n\nDragger._activeInstances = [];\n\n/**\n * Protected static methods\n * ************************\n */\n\nDragger._preventDefault = function (e) {\n  if (e.preventDefault && e.cancelable !== false) e.preventDefault();\n};\n\nDragger._activateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n  if (index > -1) return;\n\n  Dragger._activeInstances.push(instance);\n  Dragger._emitter.on(Dragger._emitterEvents.move, instance._onMove);\n  Dragger._emitter.on(Dragger._emitterEvents.cancel, instance._onCancel);\n  Dragger._emitter.on(Dragger._emitterEvents.end, instance._onEnd);\n\n  if (Dragger._activeInstances.length === 1) {\n    Dragger._bindListeners();\n  }\n};\n\nDragger._deactivateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n  if (index === -1) return;\n\n  Dragger._activeInstances.splice(index, 1);\n  Dragger._emitter.off(Dragger._emitterEvents.move, instance._onMove);\n  Dragger._emitter.off(Dragger._emitterEvents.cancel, instance._onCancel);\n  Dragger._emitter.off(Dragger._emitterEvents.end, instance._onEnd);\n\n  if (!Dragger._activeInstances.length) {\n    Dragger._unbindListeners();\n  }\n};\n\nDragger._bindListeners = function () {\n  window.addEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.addEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n  if (Dragger._inputEvents.cancel) {\n    window.addEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\n\nDragger._unbindListeners = function () {\n  window.removeEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.removeEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n  if (Dragger._inputEvents.cancel) {\n    window.removeEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\n\nDragger._getEventPointerId = function (event) {\n  // If we have pointer id available let's use it.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId;\n  }\n\n  // For touch events let's get the first changed touch's identifier.\n  if (event.changedTouches) {\n    return event.changedTouches[0] ? event.changedTouches[0].identifier : null;\n  }\n\n  // For mouse/other events let's provide a static id.\n  return 1;\n};\n\nDragger._getTouchById = function (event, id) {\n  // If we have a pointer event return the whole event if there's a match, and\n  // null otherwise.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId === id ? event : null;\n  }\n\n  // For touch events let's check if there's a changed touch object that matches\n  // the pointerId in which case return the touch object.\n  if (event.changedTouches) {\n    for (var i = 0; i < event.changedTouches.length; i++) {\n      if (event.changedTouches[i].identifier === id) {\n        return event.changedTouches[i];\n      }\n    }\n    return null;\n  }\n\n  // For mouse/other events let's assume there's only one pointer and just\n  // return the event.\n  return event;\n};\n\nDragger._onMove = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.move, e);\n};\n\nDragger._onCancel = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.cancel, e);\n};\n\nDragger._onEnd = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.end, e);\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Reset current drag operation (if any).\n *\n * @private\n */\nDragger.prototype._reset = function () {\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n  this._isActive = false;\n  Dragger._deactivateInstance(this);\n};\n\n/**\n * Create a custom dragger event from a raw event.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {Object}\n */\nDragger.prototype._createEvent = function (type, e) {\n  var touch = this._getTrackedTouch(e);\n  return {\n    // Hammer.js compatibility interface.\n    type: type,\n    srcEvent: e,\n    distance: this.getDistance(),\n    deltaX: this.getDeltaX(),\n    deltaY: this.getDeltaY(),\n    deltaTime: type === Dragger._emitterEvents.start ? 0 : this.getDeltaTime(),\n    isFirst: type === Dragger._emitterEvents.start,\n    isFinal: type === Dragger._emitterEvents.end || type === Dragger._emitterEvents.cancel,\n    pointerType: e.pointerType || (e.touches ? 'touch' : 'mouse'),\n    // Partial Touch API interface.\n    identifier: this._pointerId,\n    screenX: touch.screenX,\n    screenY: touch.screenY,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    target: touch.target,\n  };\n};\n\n/**\n * Emit a raw event as dragger event internally.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._emit = function (type, e) {\n  this._emitter.emit(type, this._createEvent(type, e));\n};\n\n/**\n * If the provided event is a PointerEvent this method will return it if it has\n * the same pointerId as the instance. If the provided event is a TouchEvent\n * this method will try to look for a Touch instance in the changedTouches that\n * has an identifier matching this instance's pointerId. If the provided event\n * is a MouseEvent (or just any other event than PointerEvent or TouchEvent)\n * it will be returned immediately.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {?(Touch|PointerEvent|MouseEvent)}\n */\nDragger.prototype._getTrackedTouch = function (e) {\n  if (this._pointerId === null) return null;\n  return Dragger._getTouchById(e, this._pointerId);\n};\n\n/**\n * Handler for start event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onStart = function (e) {\n  if (this._isDestroyed) return;\n\n  // If pointer id is already assigned let's return early.\n  if (this._pointerId !== null) return;\n\n  // Get (and set) pointer id.\n  this._pointerId = Dragger._getEventPointerId(e);\n  if (this._pointerId === null) return;\n\n  // Setup initial data and emit start event.\n  var touch = this._getTrackedTouch(e);\n  this._startX = this._currentX = touch.clientX;\n  this._startY = this._currentY = touch.clientY;\n  this._startTime = Date.now();\n  this._isActive = true;\n  this._emit(Dragger._emitterEvents.start, e);\n\n  // If the drag procedure was not reset within the start procedure let's\n  // activate the instance (start listening to move/cancel/end events).\n  if (this._isActive) {\n    Dragger._activateInstance(this);\n  }\n};\n\n/**\n * Handler for move event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onMove = function (e) {\n  var touch = this._getTrackedTouch(e);\n  if (!touch) return;\n  this._currentX = touch.clientX;\n  this._currentY = touch.clientY;\n  this._emit(Dragger._emitterEvents.move, e);\n};\n\n/**\n * Handler for cancel event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onCancel = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n  this._emit(Dragger._emitterEvents.cancel, e);\n  this._reset();\n};\n\n/**\n * Handler for end event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onEnd = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n  this._emit(Dragger._emitterEvents.end, e);\n  this._reset();\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Check if the element is being dragged at the moment.\n *\n * @public\n * @returns {Boolean}\n */\nDragger.prototype.isActive = function () {\n  return this._isActive;\n};\n\n/**\n * Set element's touch-action CSS property.\n *\n * @public\n * @param {String} value\n */\nDragger.prototype.setTouchAction = function (value) {\n  // Store unmodified touch action value (we trust user input here).\n  this._touchAction = value;\n\n  // Set touch-action style.\n  if (taPropPrefixed) {\n    this._cssProps[taPropPrefixed] = '';\n    this._element.style[taPropPrefixed] = value;\n  }\n\n  // If we have an unsupported touch-action value let's add a special listener\n  // that prevents default action on touch start event. A dirty hack, but best\n  // we can do for now. The other options would be to somehow polyfill the\n  // unsupported touch action behavior with custom heuristics which sounds like\n  // a can of worms. We do a special exception here for Firefox Android which's\n  // touch-action does not work properly if the dragged element is moved in the\n  // the DOM tree on touchstart.\n  if (HAS_TOUCH_EVENTS) {\n    this._element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n    if (this._element.style[taPropPrefixed] !== value || (isFirefox && isAndroid)) {\n      this._element.addEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n    }\n  }\n};\n\n/**\n * Update element's CSS properties. Accepts an object with camel cased style\n * props with value pairs as it's first argument.\n *\n * @public\n * @param {Object} [newProps]\n */\nDragger.prototype.setCssProps = function (newProps) {\n  if (!newProps) return;\n\n  var currentProps = this._cssProps;\n  var element = this._element;\n  var prop;\n  var prefixedProp;\n\n  // Reset current props.\n  for (prop in currentProps) {\n    element.style[prop] = currentProps[prop];\n    delete currentProps[prop];\n  }\n\n  // Set new props.\n  for (prop in newProps) {\n    // Make sure we have a value for the prop.\n    if (!newProps[prop]) continue;\n\n    // Special handling for touch-action.\n    if (prop === taProp) {\n      this.setTouchAction(newProps[prop]);\n      continue;\n    }\n\n    // Get prefixed prop and skip if it does not exist.\n    prefixedProp = getPrefixedPropName(element.style, prop);\n    if (!prefixedProp) continue;\n\n    // Store the prop and add the style.\n    currentProps[prefixedProp] = '';\n    element.style[prefixedProp] = newProps[prop];\n  }\n};\n\n/**\n * How much the pointer has moved on x-axis from start position, in pixels.\n * Positive value indicates movement from left to right.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaX = function () {\n  return this._currentX - this._startX;\n};\n\n/**\n * How much the pointer has moved on y-axis from start position, in pixels.\n * Positive value indicates movement from top to bottom.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaY = function () {\n  return this._currentY - this._startY;\n};\n\n/**\n * How far (in pixels) has pointer moved from start position.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDistance = function () {\n  var x = this.getDeltaX();\n  var y = this.getDeltaY();\n  return Math.sqrt(x * x + y * y);\n};\n\n/**\n * How long has pointer been dragged.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaTime = function () {\n  return this._startTime ? Date.now() - this._startTime : 0;\n};\n\n/**\n * Bind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\nDragger.prototype.on = function (eventName, listener) {\n  this._emitter.on(eventName, listener);\n};\n\n/**\n * Unbind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\nDragger.prototype.off = function (eventName, listener) {\n  this._emitter.off(eventName, listener);\n};\n\n/**\n * Destroy the instance and unbind all drag event listeners.\n *\n * @public\n */\nDragger.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var element = this._element;\n\n  if (this._edgeHack) this._edgeHack.destroy();\n\n  // Reset data and deactivate the instance.\n  this._reset();\n\n  // Destroy emitter.\n  this._emitter.destroy();\n\n  // Unbind event handlers.\n  element.removeEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n  element.removeEventListener('dragstart', Dragger._preventDefault, false);\n  element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n\n  // Reset styles.\n  for (var prop in this._cssProps) {\n    element.style[prop] = this._cssProps[prop];\n    delete this._cssProps[prop];\n  }\n\n  // Reset data.\n  this._element = null;\n\n  // Mark as destroyed.\n  this._isDestroyed = true;\n};\n\nvar dt = 1000 / 60;\n\nvar raf = (\n  window.requestAnimationFrame ||\n  window.webkitRequestAnimationFrame ||\n  window.mozRequestAnimationFrame ||\n  window.msRequestAnimationFrame ||\n  function (callback) {\n    return this.setTimeout(function () {\n      callback(Date.now());\n    }, dt);\n  }\n).bind(window);\n\n/**\n * A ticker system for handling DOM reads and writes in an efficient way.\n *\n * @class\n */\nfunction Ticker(numLanes) {\n  this._nextStep = null;\n  this._lanes = [];\n  this._stepQueue = [];\n  this._stepCallbacks = {};\n  this._step = this._step.bind(this);\n  for (var i = 0; i < numLanes; i++) {\n    this._lanes.push(new TickerLane());\n  }\n}\n\nTicker.prototype._step = function (time) {\n  var lanes = this._lanes;\n  var stepQueue = this._stepQueue;\n  var stepCallbacks = this._stepCallbacks;\n  var i, j, id, laneQueue, laneCallbacks, laneIndices;\n\n  this._nextStep = null;\n\n  for (i = 0; i < lanes.length; i++) {\n    laneQueue = lanes[i].queue;\n    laneCallbacks = lanes[i].callbacks;\n    laneIndices = lanes[i].indices;\n    for (j = 0; j < laneQueue.length; j++) {\n      id = laneQueue[j];\n      if (!id) continue;\n      stepQueue.push(id);\n      stepCallbacks[id] = laneCallbacks[id];\n      delete laneCallbacks[id];\n      delete laneIndices[id];\n    }\n    laneQueue.length = 0;\n  }\n\n  for (i = 0; i < stepQueue.length; i++) {\n    id = stepQueue[i];\n    if (stepCallbacks[id]) stepCallbacks[id](time);\n    delete stepCallbacks[id];\n  }\n\n  stepQueue.length = 0;\n};\n\nTicker.prototype.add = function (laneIndex, id, callback) {\n  this._lanes[laneIndex].add(id, callback);\n  if (!this._nextStep) this._nextStep = raf(this._step);\n};\n\nTicker.prototype.remove = function (laneIndex, id) {\n  this._lanes[laneIndex].remove(id);\n};\n\n/**\n * A lane for ticker.\n *\n * @class\n */\nfunction TickerLane() {\n  this.queue = [];\n  this.indices = {};\n  this.callbacks = {};\n}\n\nTickerLane.prototype.add = function (id, callback) {\n  var index = this.indices[id];\n  if (index !== undefined) this.queue[index] = undefined;\n  this.queue.push(id);\n  this.callbacks[id] = callback;\n  this.indices[id] = this.queue.length - 1;\n};\n\nTickerLane.prototype.remove = function (id) {\n  var index = this.indices[id];\n  if (index === undefined) return;\n  this.queue[index] = undefined;\n  delete this.callbacks[id];\n  delete this.indices[id];\n};\n\nvar LAYOUT_READ = 'layoutRead';\nvar LAYOUT_WRITE = 'layoutWrite';\nvar VISIBILITY_READ = 'visibilityRead';\nvar VISIBILITY_WRITE = 'visibilityWrite';\nvar DRAG_START_READ = 'dragStartRead';\nvar DRAG_START_WRITE = 'dragStartWrite';\nvar DRAG_MOVE_READ = 'dragMoveRead';\nvar DRAG_MOVE_WRITE = 'dragMoveWrite';\nvar DRAG_SCROLL_READ = 'dragScrollRead';\nvar DRAG_SCROLL_WRITE = 'dragScrollWrite';\nvar DRAG_SORT_READ = 'dragSortRead';\nvar PLACEHOLDER_LAYOUT_READ = 'placeholderLayoutRead';\nvar PLACEHOLDER_LAYOUT_WRITE = 'placeholderLayoutWrite';\nvar PLACEHOLDER_RESIZE_WRITE = 'placeholderResizeWrite';\nvar AUTO_SCROLL_READ = 'autoScrollRead';\nvar AUTO_SCROLL_WRITE = 'autoScrollWrite';\nvar DEBOUNCE_READ = 'debounceRead';\n\nvar LANE_READ = 0;\nvar LANE_READ_TAIL = 1;\nvar LANE_WRITE = 2;\n\nvar ticker = new Ticker(3);\n\nfunction addLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, LAYOUT_WRITE + itemId, write);\n}\n\nfunction cancelLayoutTick(itemId) {\n  ticker.remove(LANE_READ, LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, LAYOUT_WRITE + itemId);\n}\n\nfunction addVisibilityTick(itemId, read, write) {\n  ticker.add(LANE_READ, VISIBILITY_READ + itemId, read);\n  ticker.add(LANE_WRITE, VISIBILITY_WRITE + itemId, write);\n}\n\nfunction cancelVisibilityTick(itemId) {\n  ticker.remove(LANE_READ, VISIBILITY_READ + itemId);\n  ticker.remove(LANE_WRITE, VISIBILITY_WRITE + itemId);\n}\n\nfunction addDragStartTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_START_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_START_WRITE + itemId, write);\n}\n\nfunction cancelDragStartTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_START_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_START_WRITE + itemId);\n}\n\nfunction addDragMoveTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_MOVE_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_MOVE_WRITE + itemId, write);\n}\n\nfunction cancelDragMoveTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_MOVE_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_MOVE_WRITE + itemId);\n}\n\nfunction addDragScrollTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_SCROLL_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_SCROLL_WRITE + itemId, write);\n}\n\nfunction cancelDragScrollTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_SCROLL_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_SCROLL_WRITE + itemId);\n}\n\nfunction addDragSortTick(itemId, read) {\n  ticker.add(LANE_READ_TAIL, DRAG_SORT_READ + itemId, read);\n}\n\nfunction cancelDragSortTick(itemId) {\n  ticker.remove(LANE_READ_TAIL, DRAG_SORT_READ + itemId);\n}\n\nfunction addPlaceholderLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId, write);\n}\n\nfunction cancelPlaceholderLayoutTick(itemId) {\n  ticker.remove(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId);\n}\n\nfunction addPlaceholderResizeTick(itemId, write) {\n  ticker.add(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId, write);\n}\n\nfunction cancelPlaceholderResizeTick(itemId) {\n  ticker.remove(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId);\n}\n\nfunction addAutoScrollTick(read, write) {\n  ticker.add(LANE_READ, AUTO_SCROLL_READ, read);\n  ticker.add(LANE_WRITE, AUTO_SCROLL_WRITE, write);\n}\n\nfunction cancelAutoScrollTick() {\n  ticker.remove(LANE_READ, AUTO_SCROLL_READ);\n  ticker.remove(LANE_WRITE, AUTO_SCROLL_WRITE);\n}\n\nfunction addDebounceTick(debounceId, read) {\n  ticker.add(LANE_READ, DEBOUNCE_READ + debounceId, read);\n}\n\nfunction cancelDebounceTick(debounceId) {\n  ticker.remove(LANE_READ, DEBOUNCE_READ + debounceId);\n}\n\nvar AXIS_X = 1;\nvar AXIS_Y = 2;\nvar FORWARD = 4;\nvar BACKWARD = 8;\nvar LEFT = AXIS_X | BACKWARD;\nvar RIGHT = AXIS_X | FORWARD;\nvar UP = AXIS_Y | BACKWARD;\nvar DOWN = AXIS_Y | FORWARD;\n\nvar functionType = 'function';\n\n/**\n * Check if a value is a function.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isFunction(val) {\n  return typeof val === functionType;\n}\n\nvar cache$1 = typeof WeakMap === 'function' ? new WeakMap() : null;\n\n/**\n * Returns the computed value of an element's style property as a string.\n *\n * @param {HTMLElement} element\n * @param {String} style\n * @returns {String}\n */\nfunction getStyle(element, style) {\n  var styles = cache$1 && cache$1.get(element);\n\n  if (!styles) {\n    styles = window.getComputedStyle(element, null);\n    if (cache$1) cache$1.set(element, styles);\n  }\n\n  return styles.getPropertyValue(style);\n}\n\n/**\n * Returns the computed value of an element's style property transformed into\n * a float value.\n *\n * @param {HTMLElement} el\n * @param {String} style\n * @returns {Number}\n */\nfunction getStyleAsFloat(el, style) {\n  return parseFloat(getStyle(el, style)) || 0;\n}\n\nvar DOC_ELEM = document.documentElement;\nvar BODY = document.body;\nvar THRESHOLD_DATA = { value: 0, offset: 0 };\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {HTMLElement|Window}\n */\nfunction getScrollElement(element) {\n  if (element === window || element === DOC_ELEM || element === BODY) {\n    return window;\n  } else {\n    return element;\n  }\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollLeft(element) {\n  return element === window ? element.pageXOffset : element.scrollLeft;\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollTop(element) {\n  return element === window ? element.pageYOffset : element.scrollTop;\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollLeftMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollWidth - DOC_ELEM.clientWidth;\n  } else {\n    return element.scrollWidth - element.clientWidth;\n  }\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollTopMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollHeight - DOC_ELEM.clientHeight;\n  } else {\n    return element.scrollHeight - element.clientHeight;\n  }\n}\n\n/**\n * Get window's or element's client rectangle data relative to the element's\n * content dimensions (includes inner size + padding, excludes scrollbars,\n * borders and margins).\n *\n * @param {HTMLElement|Window} element\n * @returns {Rectangle}\n */\nfunction getContentRect(element, result) {\n  result = result || {};\n\n  if (element === window) {\n    result.width = DOC_ELEM.clientWidth;\n    result.height = DOC_ELEM.clientHeight;\n    result.left = 0;\n    result.right = result.width;\n    result.top = 0;\n    result.bottom = result.height;\n  } else {\n    var bcr = element.getBoundingClientRect();\n    var borderLeft = element.clientLeft || getStyleAsFloat(element, 'border-left-width');\n    var borderTop = element.clientTop || getStyleAsFloat(element, 'border-top-width');\n    result.width = element.clientWidth;\n    result.height = element.clientHeight;\n    result.left = bcr.left + borderLeft;\n    result.right = result.left + result.width;\n    result.top = bcr.top + borderTop;\n    result.bottom = result.top + result.height;\n  }\n\n  return result;\n}\n\n/**\n * @param {Item} item\n * @returns {Object}\n */\nfunction getItemAutoScrollSettings(item) {\n  return item._drag._getGrid()._settings.dragAutoScroll;\n}\n\n/**\n * @param {Item} item\n */\nfunction prepareItemScrollSync(item) {\n  if (!item._drag) return;\n  item._drag._prepareScroll();\n}\n\n/**\n * @param {Item} item\n */\nfunction applyItemScrollSync(item) {\n  if (!item._drag || !item._isActive) return;\n  var drag = item._drag;\n  drag._scrollDiffX = drag._scrollDiffY = 0;\n  item._setTranslate(drag._left, drag._top);\n}\n\n/**\n * Compute threshold value and edge offset.\n *\n * @param {Number} threshold\n * @param {Number} safeZone\n * @param {Number} itemSize\n * @param {Number} targetSize\n * @returns {Object}\n */\nfunction computeThreshold(threshold, safeZone, itemSize, targetSize) {\n  THRESHOLD_DATA.value = Math.min(targetSize / 2, threshold);\n  THRESHOLD_DATA.offset =\n    Math.max(0, itemSize + THRESHOLD_DATA.value * 2 + targetSize * safeZone - targetSize) / 2;\n  return THRESHOLD_DATA;\n}\n\nfunction ScrollRequest() {\n  this.reset();\n}\n\nScrollRequest.prototype.reset = function () {\n  if (this.isActive) this.onStop();\n  this.item = null;\n  this.element = null;\n  this.isActive = false;\n  this.isEnding = false;\n  this.direction = null;\n  this.value = null;\n  this.maxValue = 0;\n  this.threshold = 0;\n  this.distance = 0;\n  this.speed = 0;\n  this.duration = 0;\n  this.action = null;\n};\n\nScrollRequest.prototype.hasReachedEnd = function () {\n  return FORWARD & this.direction ? this.value >= this.maxValue : this.value <= 0;\n};\n\nScrollRequest.prototype.computeCurrentScrollValue = function () {\n  if (this.value === null) {\n    return AXIS_X & this.direction ? getScrollLeft(this.element) : getScrollTop(this.element);\n  }\n  return Math.max(0, Math.min(this.value, this.maxValue));\n};\n\nScrollRequest.prototype.computeNextScrollValue = function (deltaTime) {\n  var delta = this.speed * (deltaTime / 1000);\n  var nextValue = FORWARD & this.direction ? this.value + delta : this.value - delta;\n  return Math.max(0, Math.min(nextValue, this.maxValue));\n};\n\nScrollRequest.prototype.computeSpeed = (function () {\n  var data = {\n    direction: null,\n    threshold: 0,\n    distance: 0,\n    value: 0,\n    maxValue: 0,\n    deltaTime: 0,\n    duration: 0,\n    isEnding: false,\n  };\n\n  return function (deltaTime) {\n    var item = this.item;\n    var speed = getItemAutoScrollSettings(item).speed;\n\n    if (isFunction(speed)) {\n      data.direction = this.direction;\n      data.threshold = this.threshold;\n      data.distance = this.distance;\n      data.value = this.value;\n      data.maxValue = this.maxValue;\n      data.duration = this.duration;\n      data.speed = this.speed;\n      data.deltaTime = deltaTime;\n      data.isEnding = this.isEnding;\n      return speed(item, this.element, data);\n    } else {\n      return speed;\n    }\n  };\n})();\n\nScrollRequest.prototype.tick = function (deltaTime) {\n  if (!this.isActive) {\n    this.isActive = true;\n    this.onStart();\n  }\n  this.value = this.computeCurrentScrollValue();\n  this.speed = this.computeSpeed(deltaTime);\n  this.value = this.computeNextScrollValue(deltaTime);\n  this.duration += deltaTime;\n  return this.value;\n};\n\nScrollRequest.prototype.onStart = function () {\n  var item = this.item;\n  var onStart = getItemAutoScrollSettings(item).onStart;\n  if (isFunction(onStart)) onStart(item, this.element, this.direction);\n};\n\nScrollRequest.prototype.onStop = function () {\n  var item = this.item;\n  var onStop = getItemAutoScrollSettings(item).onStop;\n  if (isFunction(onStop)) onStop(item, this.element, this.direction);\n  // Manually nudge sort to happen. There's a good chance that the item is still\n  // after the scroll stops which means that the next sort will be triggered\n  // only after the item is moved or it's parent scrolled.\n  if (item._drag) item._drag.sort();\n};\n\nfunction ScrollAction() {\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n}\n\nScrollAction.prototype.reset = function () {\n  if (this.requestX) this.requestX.action = null;\n  if (this.requestY) this.requestY.action = null;\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n};\n\nScrollAction.prototype.addRequest = function (request) {\n  if (AXIS_X & request.direction) {\n    this.removeRequest(this.requestX);\n    this.requestX = request;\n  } else {\n    this.removeRequest(this.requestY);\n    this.requestY = request;\n  }\n  request.action = this;\n};\n\nScrollAction.prototype.removeRequest = function (request) {\n  if (!request) return;\n  if (this.requestX === request) {\n    this.requestX = null;\n    request.action = null;\n  } else if (this.requestY === request) {\n    this.requestY = null;\n    request.action = null;\n  }\n};\n\nScrollAction.prototype.computeScrollValues = function () {\n  this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n  this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n};\n\nScrollAction.prototype.scroll = function () {\n  var element = this.element;\n  if (!element) return;\n\n  if (element.scrollTo) {\n    element.scrollTo(this.scrollLeft, this.scrollTop);\n  } else {\n    element.scrollLeft = this.scrollLeft;\n    element.scrollTop = this.scrollTop;\n  }\n};\n\nfunction Pool(createItem, releaseItem) {\n  this.pool = [];\n  this.createItem = createItem;\n  this.releaseItem = releaseItem;\n}\n\nPool.prototype.pick = function () {\n  return this.pool.pop() || this.createItem();\n};\n\nPool.prototype.release = function (item) {\n  this.releaseItem(item);\n  if (this.pool.indexOf(item) !== -1) return;\n  this.pool.push(item);\n};\n\nPool.prototype.reset = function () {\n  this.pool.length = 0;\n};\n\n/**\n * Check if two rectangles are overlapping.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction isOverlapping(a, b) {\n  return !(\n    a.left + a.width <= b.left ||\n    b.left + b.width <= a.left ||\n    a.top + a.height <= b.top ||\n    b.top + b.height <= a.top\n  );\n}\n\n/**\n * Calculate intersection area between two rectangle.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction getIntersectionArea(a, b) {\n  if (!isOverlapping(a, b)) return 0;\n  var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n  var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n  return width * height;\n}\n\n/**\n * Calculate how many percent the intersection area of two rectangles is from\n * the maximum potential intersection area between the rectangles.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction getIntersectionScore(a, b) {\n  var area = getIntersectionArea(a, b);\n  if (!area) return 0;\n  var maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n  return (area / maxArea) * 100;\n}\n\nvar RECT_1 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\n\nvar RECT_2 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\n\nfunction AutoScroller() {\n  this._isDestroyed = false;\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  this._items = [];\n  this._actions = [];\n  this._requests = {};\n  this._requests[AXIS_X] = {};\n  this._requests[AXIS_Y] = {};\n  this._requestOverlapCheck = {};\n  this._dragPositions = {};\n  this._dragDirections = {};\n  this._overlapCheckInterval = 150;\n\n  this._requestPool = new Pool(\n    function () {\n      return new ScrollRequest();\n    },\n    function (request) {\n      request.reset();\n    }\n  );\n\n  this._actionPool = new Pool(\n    function () {\n      return new ScrollAction();\n    },\n    function (action) {\n      action.reset();\n    }\n  );\n\n  this._readTick = this._readTick.bind(this);\n  this._writeTick = this._writeTick.bind(this);\n}\n\nAutoScroller.AXIS_X = AXIS_X;\nAutoScroller.AXIS_Y = AXIS_Y;\nAutoScroller.FORWARD = FORWARD;\nAutoScroller.BACKWARD = BACKWARD;\nAutoScroller.LEFT = LEFT;\nAutoScroller.RIGHT = RIGHT;\nAutoScroller.UP = UP;\nAutoScroller.DOWN = DOWN;\n\nAutoScroller.smoothSpeed = function (maxSpeed, acceleration, deceleration) {\n  return function (item, element, data) {\n    var targetSpeed = 0;\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        var factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = (maxSpeed / data.threshold) * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n\n    var currentSpeed = data.speed;\n    var nextSpeed = targetSpeed;\n\n    if (currentSpeed === targetSpeed) {\n      return nextSpeed;\n    }\n\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n};\n\nAutoScroller.pointerHandle = function (pointerSize) {\n  var rect = { left: 0, top: 0, width: 0, height: 0 };\n  var size = pointerSize || 1;\n  return function (item, x, y, w, h, pX, pY) {\n    rect.left = pX - size * 0.5;\n    rect.top = pY - size * 0.5;\n    rect.width = size;\n    rect.height = size;\n    return rect;\n  };\n};\n\nAutoScroller.prototype._readTick = function (time) {\n  if (this._isDestroyed) return;\n  if (time && this._tickTime) {\n    this._tickDeltaTime = time - this._tickTime;\n    this._tickTime = time;\n    this._updateRequests();\n    this._updateActions();\n  } else {\n    this._tickTime = time;\n    this._tickDeltaTime = 0;\n  }\n};\n\nAutoScroller.prototype._writeTick = function () {\n  if (this._isDestroyed) return;\n  this._applyActions();\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\n\nAutoScroller.prototype._startTicking = function () {\n  this._isTicking = true;\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\n\nAutoScroller.prototype._stopTicking = function () {\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  cancelAutoScrollTick();\n};\n\nAutoScroller.prototype._getItemHandleRect = function (item, handle, rect) {\n  var itemDrag = item._drag;\n\n  if (handle) {\n    var ev = itemDrag._dragMoveEvent || itemDrag._dragStartEvent;\n    var data = handle(\n      item,\n      itemDrag._clientX,\n      itemDrag._clientY,\n      item._width,\n      item._height,\n      ev.clientX,\n      ev.clientY\n    );\n    rect.left = data.left;\n    rect.top = data.top;\n    rect.width = data.width;\n    rect.height = data.height;\n  } else {\n    rect.left = itemDrag._clientX;\n    rect.top = itemDrag._clientY;\n    rect.width = item._width;\n    rect.height = item._height;\n  }\n\n  rect.right = rect.left + rect.width;\n  rect.bottom = rect.top + rect.height;\n\n  return rect;\n};\n\nAutoScroller.prototype._requestItemScroll = function (\n  item,\n  axis,\n  element,\n  direction,\n  threshold,\n  distance,\n  maxValue\n) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n\n  if (request) {\n    if (request.element !== element || request.direction !== direction) {\n      request.reset();\n    }\n  } else {\n    request = this._requestPool.pick();\n  }\n\n  request.item = item;\n  request.element = element;\n  request.direction = direction;\n  request.threshold = threshold;\n  request.distance = distance;\n  request.maxValue = maxValue;\n  reqMap[item._id] = request;\n};\n\nAutoScroller.prototype._cancelItemScroll = function (item, axis) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n  if (!request) return;\n  if (request.action) request.action.removeRequest(request);\n  this._requestPool.release(request);\n  delete reqMap[item._id];\n};\n\nAutoScroller.prototype._checkItemOverlap = function (item, checkX, checkY) {\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n\n  if (!targets || !targets.length) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n\n  var dragDirections = this._dragDirections[item._id];\n  var dragDirectionX = dragDirections[0];\n  var dragDirectionY = dragDirections[1];\n\n  if (!dragDirectionX && !dragDirectionY) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n  var testRect = RECT_2;\n\n  var target = null;\n  var testElement = null;\n  var testAxisX = true;\n  var testAxisY = true;\n  var testScore = 0;\n  var testPriority = 0;\n  var testThreshold = null;\n  var testDirection = null;\n  var testDistance = 0;\n  var testMaxScrollX = 0;\n  var testMaxScrollY = 0;\n\n  var xElement = null;\n  var xPriority = -Infinity;\n  var xThreshold = 0;\n  var xScore = 0;\n  var xDirection = null;\n  var xDistance = 0;\n  var xMaxScroll = 0;\n\n  var yElement = null;\n  var yPriority = -Infinity;\n  var yThreshold = 0;\n  var yScore = 0;\n  var yDirection = null;\n  var yDistance = 0;\n  var yMaxScroll = 0;\n\n  for (var i = 0; i < targets.length; i++) {\n    target = targets[i];\n    testAxisX = checkX && dragDirectionX && target.axis !== AXIS_Y;\n    testAxisY = checkY && dragDirectionY && target.axis !== AXIS_X;\n    testPriority = target.priority || 0;\n\n    // Ignore this item if it's x-axis and y-axis priority is lower than\n    // the currently matching item's.\n    if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n      continue;\n    }\n\n    testElement = getScrollElement(target.element || target);\n    testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n    testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1;\n\n    // Ignore this item if there is no possibility to scroll.\n    if (!testMaxScrollX && !testMaxScrollY) continue;\n\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect);\n\n    // Ignore this item if it's not overlapping at all with the dragged item.\n    if (testScore <= 0) continue;\n\n    // Test x-axis.\n    if (\n      testAxisX &&\n      testPriority >= xPriority &&\n      testMaxScrollX > 0 &&\n      (testPriority > xPriority || testScore > xScore)\n    ) {\n      testDirection = null;\n      testThreshold = computeThreshold(\n        typeof target.threshold === 'number' ? target.threshold : threshold,\n        safeZone,\n        itemRect.width,\n        testRect.width\n      );\n      if (dragDirectionX === RIGHT) {\n        testDistance = testRect.right + testThreshold.offset - itemRect.right;\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) < testMaxScrollX) {\n          testDirection = RIGHT;\n        }\n      } else if (dragDirectionX === LEFT) {\n        testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) > 0) {\n          testDirection = LEFT;\n        }\n      }\n\n      if (testDirection !== null) {\n        xElement = testElement;\n        xPriority = testPriority;\n        xThreshold = testThreshold.value;\n        xScore = testScore;\n        xDirection = testDirection;\n        xDistance = testDistance;\n        xMaxScroll = testMaxScrollX;\n      }\n    }\n\n    // Test y-axis.\n    if (\n      testAxisY &&\n      testPriority >= yPriority &&\n      testMaxScrollY > 0 &&\n      (testPriority > yPriority || testScore > yScore)\n    ) {\n      testDirection = null;\n      testThreshold = computeThreshold(\n        typeof target.threshold === 'number' ? target.threshold : threshold,\n        safeZone,\n        itemRect.height,\n        testRect.height\n      );\n      if (dragDirectionY === DOWN) {\n        testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) < testMaxScrollY) {\n          testDirection = DOWN;\n        }\n      } else if (dragDirectionY === UP) {\n        testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) > 0) {\n          testDirection = UP;\n        }\n      }\n\n      if (testDirection !== null) {\n        yElement = testElement;\n        yPriority = testPriority;\n        yThreshold = testThreshold.value;\n        yScore = testScore;\n        yDirection = testDirection;\n        yDistance = testDistance;\n        yMaxScroll = testMaxScrollY;\n      }\n    }\n  }\n\n  // Request or cancel x-axis scroll.\n  if (checkX) {\n    if (xElement) {\n      this._requestItemScroll(\n        item,\n        AXIS_X,\n        xElement,\n        xDirection,\n        xThreshold,\n        xDistance,\n        xMaxScroll\n      );\n    } else {\n      this._cancelItemScroll(item, AXIS_X);\n    }\n  }\n\n  // Request or cancel y-axis scroll.\n  if (checkY) {\n    if (yElement) {\n      this._requestItemScroll(\n        item,\n        AXIS_Y,\n        yElement,\n        yDirection,\n        yThreshold,\n        yDistance,\n        yMaxScroll\n      );\n    } else {\n      this._cancelItemScroll(item, AXIS_Y);\n    }\n  }\n};\n\nAutoScroller.prototype._updateScrollRequest = function (scrollRequest) {\n  var item = scrollRequest.item;\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var targetCount = (targets && targets.length) || 0;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n  var testRect = RECT_2;\n  var target = null;\n  var testElement = null;\n  var testIsAxisX = false;\n  var testScore = null;\n  var testThreshold = null;\n  var testDistance = null;\n  var testScroll = null;\n  var testMaxScroll = null;\n  var hasReachedEnd = null;\n\n  for (var i = 0; i < targetCount; i++) {\n    target = targets[i];\n\n    // Make sure we have a matching element.\n    testElement = getScrollElement(target.element || target);\n    if (testElement !== scrollRequest.element) continue;\n\n    // Make sure we have a matching axis.\n    testIsAxisX = !!(AXIS_X & scrollRequest.direction);\n    if (testIsAxisX) {\n      if (target.axis === AXIS_Y) continue;\n    } else {\n      if (target.axis === AXIS_X) continue;\n    }\n\n    // Stop scrolling if there is no room to scroll anymore.\n    testMaxScroll = testIsAxisX ? getScrollLeftMax(testElement) : getScrollTopMax(testElement);\n    if (testMaxScroll <= 0) {\n      break;\n    }\n\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect);\n\n    // Stop scrolling if dragged item is not overlapping with the scroll\n    // element anymore.\n    if (testScore <= 0) {\n      break;\n    }\n\n    // Compute threshold and edge offset.\n    testThreshold = computeThreshold(\n      typeof target.threshold === 'number' ? target.threshold : threshold,\n      safeZone,\n      testIsAxisX ? itemRect.width : itemRect.height,\n      testIsAxisX ? testRect.width : testRect.height\n    );\n\n    // Compute distance (based on current direction).\n    if (scrollRequest.direction === LEFT) {\n      testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n    } else if (scrollRequest.direction === RIGHT) {\n      testDistance = testRect.right + testThreshold.offset - itemRect.right;\n    } else if (scrollRequest.direction === UP) {\n      testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n    } else {\n      testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n    }\n\n    // Stop scrolling if threshold is not exceeded.\n    if (testDistance > testThreshold.value) {\n      break;\n    }\n\n    // Stop scrolling if we have reached the end of the scroll value.\n    testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n    hasReachedEnd =\n      FORWARD & scrollRequest.direction ? testScroll >= testMaxScroll : testScroll <= 0;\n    if (hasReachedEnd) {\n      break;\n    }\n\n    // Scrolling can continue, let's update the values.\n    scrollRequest.maxValue = testMaxScroll;\n    scrollRequest.threshold = testThreshold.value;\n    scrollRequest.distance = testDistance;\n    scrollRequest.isEnding = false;\n    return true;\n  }\n\n  // Before we end the request, let's see if we need to stop the scrolling\n  // smoothly or immediately.\n  if (settings.smoothStop === true && scrollRequest.speed > 0) {\n    if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n    scrollRequest.isEnding = hasReachedEnd ? false : true;\n  } else {\n    scrollRequest.isEnding = false;\n  }\n\n  return scrollRequest.isEnding;\n};\n\nAutoScroller.prototype._updateRequests = function () {\n  var items = this._items;\n  var requestsX = this._requests[AXIS_X];\n  var requestsY = this._requests[AXIS_Y];\n  var item, reqX, reqY, checkTime, needsCheck, checkX, checkY;\n\n  for (var i = 0; i < items.length; i++) {\n    item = items[i];\n    checkTime = this._requestOverlapCheck[item._id];\n    needsCheck = checkTime > 0 && this._tickTime - checkTime > this._overlapCheckInterval;\n\n    checkX = true;\n    reqX = requestsX[item._id];\n    if (reqX && reqX.isActive) {\n      checkX = !this._updateScrollRequest(reqX);\n      if (checkX) {\n        needsCheck = true;\n        this._cancelItemScroll(item, AXIS_X);\n      }\n    }\n\n    checkY = true;\n    reqY = requestsY[item._id];\n    if (reqY && reqY.isActive) {\n      checkY = !this._updateScrollRequest(reqY);\n      if (checkY) {\n        needsCheck = true;\n        this._cancelItemScroll(item, AXIS_Y);\n      }\n    }\n\n    if (needsCheck) {\n      this._requestOverlapCheck[item._id] = 0;\n      this._checkItemOverlap(item, checkX, checkY);\n    }\n  }\n};\n\nAutoScroller.prototype._requestAction = function (request, axis) {\n  var actions = this._actions;\n  var isAxisX = axis === AXIS_X;\n  var action = null;\n\n  for (var i = 0; i < actions.length; i++) {\n    action = actions[i];\n\n    // If the action's request does not match the request's -> skip.\n    if (request.element !== action.element) {\n      action = null;\n      continue;\n    }\n\n    // If the request and action share the same element, but the request slot\n    // for the requested axis is already reserved let's ignore and cancel this\n    // request.\n    if (isAxisX ? action.requestX : action.requestY) {\n      this._cancelItemScroll(request.item, axis);\n      return;\n    }\n\n    // Seems like we have found our action, let's break the loop.\n    break;\n  }\n\n  if (!action) action = this._actionPool.pick();\n  action.element = request.element;\n  action.addRequest(request);\n\n  request.tick(this._tickDeltaTime);\n  actions.push(action);\n};\n\nAutoScroller.prototype._updateActions = function () {\n  var items = this._items;\n  var requests = this._requests;\n  var actions = this._actions;\n  var itemId;\n  var reqX;\n  var reqY;\n  var i;\n\n  // Generate actions.\n  for (i = 0; i < items.length; i++) {\n    itemId = items[i]._id;\n    reqX = requests[AXIS_X][itemId];\n    reqY = requests[AXIS_Y][itemId];\n    if (reqX) this._requestAction(reqX, AXIS_X);\n    if (reqY) this._requestAction(reqY, AXIS_Y);\n  }\n\n  // Compute actions' scroll values.\n  for (i = 0; i < actions.length; i++) {\n    actions[i].computeScrollValues();\n  }\n};\n\nAutoScroller.prototype._applyActions = function () {\n  var actions = this._actions;\n  var items = this._items;\n  var i;\n\n  // No actions -> no scrolling.\n  if (!actions.length) return;\n\n  // Scroll all the required elements.\n  for (i = 0; i < actions.length; i++) {\n    actions[i].scroll();\n    this._actionPool.release(actions[i]);\n  }\n\n  // Reset actions.\n  actions.length = 0;\n\n  // Sync the item position immediately after all the auto-scrolling business is\n  // finished. Without this procedure the items will jitter during auto-scroll\n  // (in some cases at least) since the drag scroll handler is async (bound to\n  // raf tick). Note that this procedure should not emit any dragScroll events,\n  // because otherwise they would be emitted twice for the same event.\n  for (i = 0; i < items.length; i++) prepareItemScrollSync(items[i]);\n  for (i = 0; i < items.length; i++) applyItemScrollSync(items[i]);\n};\n\nAutoScroller.prototype._updateDragDirection = function (item) {\n  var dragPositions = this._dragPositions[item._id];\n  var dragDirections = this._dragDirections[item._id];\n  var x1 = item._drag._left;\n  var y1 = item._drag._top;\n  if (dragPositions.length) {\n    var x2 = dragPositions[0];\n    var y2 = dragPositions[1];\n    dragDirections[0] = x1 > x2 ? RIGHT : x1 < x2 ? LEFT : dragDirections[0] || 0;\n    dragDirections[1] = y1 > y2 ? DOWN : y1 < y2 ? UP : dragDirections[1] || 0;\n  }\n  dragPositions[0] = x1;\n  dragPositions[1] = y1;\n};\n\nAutoScroller.prototype.addItem = function (item) {\n  if (this._isDestroyed) return;\n  var index = this._items.indexOf(item);\n  if (index === -1) {\n    this._items.push(item);\n    this._requestOverlapCheck[item._id] = this._tickTime;\n    this._dragDirections[item._id] = [0, 0];\n    this._dragPositions[item._id] = [];\n    if (!this._isTicking) this._startTicking();\n  }\n};\n\nAutoScroller.prototype.updateItem = function (item) {\n  if (this._isDestroyed) return;\n\n  // Make sure the item still exists in the auto-scroller.\n  if (!this._dragDirections[item._id]) return;\n\n  this._updateDragDirection(item);\n  if (!this._requestOverlapCheck[item._id]) {\n    this._requestOverlapCheck[item._id] = this._tickTime;\n  }\n};\n\nAutoScroller.prototype.removeItem = function (item) {\n  if (this._isDestroyed) return;\n\n  var index = this._items.indexOf(item);\n  if (index === -1) return;\n\n  var itemId = item._id;\n\n  var reqX = this._requests[AXIS_X][itemId];\n  if (reqX) {\n    this._cancelItemScroll(item, AXIS_X);\n    delete this._requests[AXIS_X][itemId];\n  }\n\n  var reqY = this._requests[AXIS_Y][itemId];\n  if (reqY) {\n    this._cancelItemScroll(item, AXIS_Y);\n    delete this._requests[AXIS_Y][itemId];\n  }\n\n  delete this._requestOverlapCheck[itemId];\n  delete this._dragPositions[itemId];\n  delete this._dragDirections[itemId];\n  this._items.splice(index, 1);\n\n  if (this._isTicking && !this._items.length) {\n    this._stopTicking();\n  }\n};\n\nAutoScroller.prototype.isItemScrollingX = function (item) {\n  var reqX = this._requests[AXIS_X][item._id];\n  return !!(reqX && reqX.isActive);\n};\n\nAutoScroller.prototype.isItemScrollingY = function (item) {\n  var reqY = this._requests[AXIS_Y][item._id];\n  return !!(reqY && reqY.isActive);\n};\n\nAutoScroller.prototype.isItemScrolling = function (item) {\n  return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n};\n\nAutoScroller.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var items = this._items.slice(0);\n  for (var i = 0; i < items.length; i++) {\n    this.removeItem(items[i]);\n  }\n\n  this._actions.length = 0;\n  this._requestPool.reset();\n  this._actionPool.reset();\n\n  this._isDestroyed = true;\n};\n\nvar ElProto = window.Element.prototype;\nvar matchesFn =\n  ElProto.matches ||\n  ElProto.matchesSelector ||\n  ElProto.webkitMatchesSelector ||\n  ElProto.mozMatchesSelector ||\n  ElProto.msMatchesSelector ||\n  ElProto.oMatchesSelector ||\n  function () {\n    return false;\n  };\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {Element} el\n * @param {String} selector\n * @returns {Boolean}\n */\nfunction elementMatches(el, selector) {\n  return matchesFn.call(el, selector);\n}\n\n/**\n * Add class to an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\nfunction addClass(element, className) {\n  if (!className) return;\n\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (!elementMatches(element, '.' + className)) {\n      element.className += ' ' + className;\n    }\n  }\n}\n\nvar tempArray = [];\nvar numberType = 'number';\n\n/**\n * Insert an item or an array of items to array to a specified index. Mutates\n * the array. The index can be negative in which case the items will be added\n * to the end of the array.\n *\n * @param {Array} array\n * @param {*} items\n * @param {Number} [index=-1]\n */\nfunction arrayInsert(array, items, index) {\n  var startIndex = typeof index === numberType ? index : -1;\n  if (startIndex < 0) startIndex = array.length - startIndex + 1;\n\n  array.splice.apply(array, tempArray.concat(startIndex, 0, items));\n  tempArray.length = 0;\n}\n\n/**\n * Normalize array index. Basically this function makes sure that the provided\n * array index is within the bounds of the provided array and also transforms\n * negative index to the matching positive index. The third (optional) argument\n * allows you to define offset for array's length in case you are adding items\n * to the array or removing items from the array.\n *\n * @param {Array} array\n * @param {Number} index\n * @param {Number} [sizeOffset]\n */\nfunction normalizeArrayIndex(array, index, sizeOffset) {\n  var maxIndex = Math.max(0, array.length - 1 + (sizeOffset || 0));\n  return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;\n}\n\n/**\n * Move array item to another index.\n *\n * @param {Array} array\n * @param {Number} fromIndex\n *   - Index (positive or negative) of the item that will be moved.\n * @param {Number} toIndex\n *   - Index (positive or negative) where the item should be moved to.\n */\nfunction arrayMove(array, fromIndex, toIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return;\n\n  // Normalize the indices.\n  var from = normalizeArrayIndex(array, fromIndex);\n  var to = normalizeArrayIndex(array, toIndex);\n\n  // Add target item to the new position.\n  if (from !== to) {\n    array.splice(to, 0, array.splice(from, 1)[0]);\n  }\n}\n\n/**\n * Swap array items.\n *\n * @param {Array} array\n * @param {Number} index\n *   - Index (positive or negative) of the item that will be swapped.\n * @param {Number} withIndex\n *   - Index (positive or negative) of the other item that will be swapped.\n */\nfunction arraySwap(array, index, withIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return;\n\n  // Normalize the indices.\n  var indexA = normalizeArrayIndex(array, index);\n  var indexB = normalizeArrayIndex(array, withIndex);\n  var temp;\n\n  // Swap the items.\n  if (indexA !== indexB) {\n    temp = array[indexA];\n    array[indexA] = array[indexB];\n    array[indexB] = temp;\n  }\n}\n\nvar transformProp = getPrefixedPropName(document.documentElement.style, 'transform') || 'transform';\n\nvar styleNameRegEx = /([A-Z])/g;\nvar prefixRegex = /^(webkit-|moz-|ms-|o-)/;\nvar msPrefixRegex = /^(-m-s-)/;\n\n/**\n * Transforms a camel case style property to kebab case style property. Handles\n * vendor prefixed properties elegantly as well, e.g. \"WebkitTransform\" and\n * \"webkitTransform\" are both transformed into \"-webkit-transform\".\n *\n * @param {String} property\n * @returns {String}\n */\nfunction getStyleName(property) {\n  // Initial slicing, turns \"fooBarProp\" into \"foo-bar-prop\".\n  var styleName = property.replace(styleNameRegEx, '-$1').toLowerCase();\n\n  // Handle properties that start with \"webkit\", \"moz\", \"ms\" or \"o\" prefix (we\n  // need to add an extra '-' to the beginnig).\n  styleName = styleName.replace(prefixRegex, '-$1');\n\n  // Handle properties that start with \"MS\" prefix (we need to transform the\n  // \"-m-s-\" into \"-ms-\").\n  styleName = styleName.replace(msPrefixRegex, '-ms-');\n\n  return styleName;\n}\n\nvar transformStyle = getStyleName(transformProp);\n\nvar transformNone$1 = 'none';\nvar displayInline = 'inline';\nvar displayNone = 'none';\nvar displayStyle = 'display';\n\n/**\n * Returns true if element is transformed, false if not. In practice the\n * element's display value must be anything else than \"none\" or \"inline\" as\n * well as have a valid transform value applied in order to be counted as a\n * transformed element.\n *\n * Borrowed from Mezr (v0.6.1):\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\nfunction isTransformed(element) {\n  var transform = getStyle(element, transformStyle);\n  if (!transform || transform === transformNone$1) return false;\n\n  var display = getStyle(element, displayStyle);\n  if (display === displayInline || display === displayNone) return false;\n\n  return true;\n}\n\n/**\n * Returns an absolute positioned element's containing block, which is\n * considered to be the closest ancestor element that the target element's\n * positioning is relative to. Disclaimer: this only works as intended for\n * absolute positioned elements.\n *\n * @param {HTMLElement} element\n * @returns {(Document|Element)}\n */\nfunction getContainingBlock(element) {\n  // As long as the containing block is an element, static and not\n  // transformed, try to get the element's parent element and fallback to\n  // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n  var doc = document;\n  var res = element || doc;\n  while (res && res !== doc && getStyle(res, 'position') === 'static' && !isTransformed(res)) {\n    res = res.parentElement || doc;\n  }\n  return res;\n}\n\nvar offsetA = {};\nvar offsetB = {};\nvar offsetDiff = {};\n\n/**\n * Returns the element's document offset, which in practice means the vertical\n * and horizontal distance between the element's northwest corner and the\n * document's northwest corner. Note that this function always returns the same\n * object so be sure to read the data from it instead using it as a reference.\n *\n * @param {(Document|Element|Window)} element\n * @param {Object} [offsetData]\n *   - Optional data object where the offset data will be inserted to. If not\n *     provided a new object will be created for the return data.\n * @returns {Object}\n */\nfunction getOffset(element, offsetData) {\n  var offset = offsetData || {};\n  var rect;\n\n  // Set up return data.\n  offset.left = 0;\n  offset.top = 0;\n\n  // Document's offsets are always 0.\n  if (element === document) return offset;\n\n  // Add viewport scroll left/top to the respective offsets.\n  offset.left = window.pageXOffset || 0;\n  offset.top = window.pageYOffset || 0;\n\n  // Window's offsets are the viewport scroll left/top values.\n  if (element.self === window.self) return offset;\n\n  // Add element's client rects to the offsets.\n  rect = element.getBoundingClientRect();\n  offset.left += rect.left;\n  offset.top += rect.top;\n\n  // Exclude element's borders from the offset.\n  offset.left += getStyleAsFloat(element, 'border-left-width');\n  offset.top += getStyleAsFloat(element, 'border-top-width');\n\n  return offset;\n}\n\n/**\n * Calculate the offset difference two elements.\n *\n * @param {HTMLElement} elemA\n * @param {HTMLElement} elemB\n * @param {Boolean} [compareContainingBlocks=false]\n *   - When this is set to true the containing blocks of the provided elements\n *     will be used for calculating the difference. Otherwise the provided\n *     elements will be compared directly.\n * @returns {Object}\n */\nfunction getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n  offsetDiff.left = 0;\n  offsetDiff.top = 0;\n\n  // If elements are same let's return early.\n  if (elemA === elemB) return offsetDiff;\n\n  // Compare containing blocks if necessary.\n  if (compareContainingBlocks) {\n    elemA = getContainingBlock(elemA);\n    elemB = getContainingBlock(elemB);\n\n    // If containing blocks are identical, let's return early.\n    if (elemA === elemB) return offsetDiff;\n  }\n\n  // Finally, let's calculate the offset diff.\n  getOffset(elemA, offsetA);\n  getOffset(elemB, offsetB);\n  offsetDiff.left = offsetB.left - offsetA.left;\n  offsetDiff.top = offsetB.top - offsetA.top;\n\n  return offsetDiff;\n}\n\n/**\n * Check if overflow style value is scrollable.\n *\n * @param {String} value\n * @returns {Boolean}\n */\nfunction isScrollableOverflow(value) {\n  return value === 'auto' || value === 'scroll' || value === 'overlay';\n}\n\n/**\n * Check if an element is scrollable.\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\nfunction isScrollable(element) {\n  return (\n    isScrollableOverflow(getStyle(element, 'overflow')) ||\n    isScrollableOverflow(getStyle(element, 'overflow-x')) ||\n    isScrollableOverflow(getStyle(element, 'overflow-y'))\n  );\n}\n\n/**\n * Collect element's ancestors that are potentially scrollable elements. The\n * provided element is also also included in the check, meaning that if it is\n * scrollable it is added to the result array.\n *\n * @param {HTMLElement} element\n * @param {Array} [result]\n * @returns {Array}\n */\nfunction getScrollableAncestors(element, result) {\n  result = result || [];\n\n  // Find scroll parents.\n  while (element && element !== document) {\n    // If element is inside ShadowDOM let's get it's host node from the real\n    // DOM and continue looping.\n    if (element.getRootNode && element instanceof DocumentFragment) {\n      element = element.getRootNode().host;\n      continue;\n    }\n\n    // If element is scrollable let's add it to the scrollable list.\n    if (isScrollable(element)) {\n      result.push(element);\n    }\n\n    element = element.parentNode;\n  }\n\n  // Always add window to the results.\n  result.push(window);\n\n  return result;\n}\n\nvar translateValue = {};\nvar transformNone = 'none';\nvar rxMat3d = /^matrix3d/;\nvar rxMatTx = /([^,]*,){4}/;\nvar rxMat3dTx = /([^,]*,){12}/;\nvar rxNextItem = /[^,]*,/;\n\n/**\n * Returns the element's computed translateX and translateY values as a floats.\n * The returned object is always the same object and updated every time this\n * function is called.\n *\n * @param {HTMLElement} element\n * @returns {Object}\n */\nfunction getTranslate(element) {\n  translateValue.x = 0;\n  translateValue.y = 0;\n\n  var transform = getStyle(element, transformStyle);\n  if (!transform || transform === transformNone) {\n    return translateValue;\n  }\n\n  // Transform style can be in either matrix3d(...) or matrix(...).\n  var isMat3d = rxMat3d.test(transform);\n  var tX = transform.replace(isMat3d ? rxMat3dTx : rxMatTx, '');\n  var tY = tX.replace(rxNextItem, '');\n\n  translateValue.x = parseFloat(tX) || 0;\n  translateValue.y = parseFloat(tY) || 0;\n\n  return translateValue;\n}\n\n/**\n * Remove class from an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\nfunction removeClass(element, className) {\n  if (!className) return;\n\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    if (elementMatches(element, '.' + className)) {\n      element.className = (' ' + element.className + ' ')\n        .replace(' ' + className + ' ', ' ')\n        .trim();\n    }\n  }\n}\n\nvar IS_IOS =\n  /^(iPad|iPhone|iPod)/.test(window.navigator.platform) ||\n  (/^Mac/.test(window.navigator.platform) && window.navigator.maxTouchPoints > 1);\nvar START_PREDICATE_INACTIVE = 0;\nvar START_PREDICATE_PENDING = 1;\nvar START_PREDICATE_RESOLVED = 2;\nvar SCROLL_LISTENER_OPTIONS = hasPassiveEvents() ? { passive: true } : false;\n\n/**\n * Bind touch interaction to an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDrag(item) {\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  this._item = item;\n  this._gridId = grid._id;\n  this._isDestroyed = false;\n  this._isMigrating = false;\n\n  // Start predicate data.\n  this._startPredicate = isFunction(settings.dragStartPredicate)\n    ? settings.dragStartPredicate\n    : ItemDrag.defaultStartPredicate;\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n  this._startPredicateResult = undefined;\n\n  // Data for drag sort predicate heuristics.\n  this._isSortNeeded = false;\n  this._sortTimer = undefined;\n  this._blockedSortIndex = null;\n  this._sortX1 = 0;\n  this._sortX2 = 0;\n  this._sortY1 = 0;\n  this._sortY2 = 0;\n\n  // Setup item's initial drag data.\n  this._reset();\n\n  // Bind the methods that needs binding.\n  this._preStartCheck = this._preStartCheck.bind(this);\n  this._preEndCheck = this._preEndCheck.bind(this);\n  this._onScroll = this._onScroll.bind(this);\n  this._prepareStart = this._prepareStart.bind(this);\n  this._applyStart = this._applyStart.bind(this);\n  this._prepareMove = this._prepareMove.bind(this);\n  this._applyMove = this._applyMove.bind(this);\n  this._prepareScroll = this._prepareScroll.bind(this);\n  this._applyScroll = this._applyScroll.bind(this);\n  this._handleSort = this._handleSort.bind(this);\n  this._handleSortDelayed = this._handleSortDelayed.bind(this);\n\n  // Get drag handle element.\n  this._handle = (settings.dragHandle && element.querySelector(settings.dragHandle)) || element;\n\n  // Init dragger.\n  this._dragger = new Dragger(this._handle, settings.dragCssProps);\n  this._dragger.on('start', this._preStartCheck);\n  this._dragger.on('move', this._preStartCheck);\n  this._dragger.on('cancel', this._preEndCheck);\n  this._dragger.on('end', this._preEndCheck);\n}\n\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @type {AutoScroller}\n */\nItemDrag.autoScroller = new AutoScroller();\n\n/**\n * Public static methods\n * *********************\n */\n\n/**\n * Default drag start predicate handler that handles anchor elements\n * gracefully. The return value of this function defines if the drag is\n * started, rejected or pending. When true is returned the dragging is started\n * and when false is returned the dragging is rejected. If nothing is returned\n * the predicate will be called again on the next drag movement.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} event\n * @param {Object} [options]\n *   - An optional options object which can be used to pass the predicate\n *     it's options manually. By default the predicate retrieves the options\n *     from the grid's settings.\n * @returns {(Boolean|undefined)}\n */\nItemDrag.defaultStartPredicate = function (item, event, options) {\n  var drag = item._drag;\n\n  // Make sure left button is pressed on mouse.\n  if (event.isFirst && event.srcEvent.button) {\n    return false;\n  }\n\n  // If the start event is trusted, non-cancelable and it's default action has\n  // not been prevented it is in most cases a sign that the gesture would be\n  // cancelled anyways right after it has started (e.g. starting drag while\n  // the page is scrolling).\n  if (\n    !IS_IOS &&\n    event.isFirst &&\n    event.srcEvent.isTrusted === true &&\n    event.srcEvent.defaultPrevented === false &&\n    event.srcEvent.cancelable === false\n  ) {\n    return false;\n  }\n\n  // Final event logic. At this stage return value does not matter anymore,\n  // the predicate is either resolved or it's not and there's nothing to do\n  // about it. Here we just reset data and if the item element is a link\n  // we follow it (if there has only been slight movement).\n  if (event.isFinal) {\n    drag._finishStartPredicate(event);\n    return;\n  }\n\n  // Setup predicate data from options if not already set.\n  var predicate = drag._startPredicateData;\n  if (!predicate) {\n    var config = options || drag._getGrid()._settings.dragStartPredicate || {};\n    drag._startPredicateData = predicate = {\n      distance: Math.max(config.distance, 0) || 0,\n      delay: Math.max(config.delay, 0) || 0,\n    };\n  }\n\n  // If delay is defined let's keep track of the latest event and initiate\n  // delay if it has not been done yet.\n  if (predicate.delay) {\n    predicate.event = event;\n    if (!predicate.delayTimer) {\n      predicate.delayTimer = window.setTimeout(function () {\n        predicate.delay = 0;\n        if (drag._resolveStartPredicate(predicate.event)) {\n          drag._forceResolveStartPredicate(predicate.event);\n          drag._resetStartPredicate();\n        }\n      }, predicate.delay);\n    }\n  }\n\n  return drag._resolveStartPredicate(event);\n};\n\n/**\n * Default drag sort predicate.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} [options]\n * @param {Number} [options.threshold=50]\n * @param {String} [options.action='move']\n * @returns {?Object}\n *   - Returns `null` if no valid index was found. Otherwise returns drag sort\n *     command.\n */\nItemDrag.defaultSortPredicate = (function () {\n  var itemRect = {};\n  var targetRect = {};\n  var returnData = {};\n  var gridsArray = [];\n  var minThreshold = 1;\n  var maxThreshold = 100;\n\n  function getTargetGrid(item, rootGrid, threshold) {\n    var target = null;\n    var dragSort = rootGrid._settings.dragSort;\n    var bestScore = -1;\n    var gridScore;\n    var grids;\n    var grid;\n    var container;\n    var containerRect;\n    var left;\n    var top;\n    var right;\n    var bottom;\n    var i;\n\n    // Get potential target grids.\n    if (dragSort === true) {\n      gridsArray[0] = rootGrid;\n      grids = gridsArray;\n    } else if (isFunction(dragSort)) {\n      grids = dragSort.call(rootGrid, item);\n    }\n\n    // Return immediately if there are no grids.\n    if (!grids || !Array.isArray(grids) || !grids.length) {\n      return target;\n    }\n\n    // Loop through the grids and get the best match.\n    for (i = 0; i < grids.length; i++) {\n      grid = grids[i];\n\n      // Filter out all destroyed grids.\n      if (grid._isDestroyed) continue;\n\n      // Compute the grid's client rect an clamp the initial boundaries to\n      // viewport dimensions.\n      grid._updateBoundingRect();\n      left = Math.max(0, grid._left);\n      top = Math.max(0, grid._top);\n      right = Math.min(window.innerWidth, grid._right);\n      bottom = Math.min(window.innerHeight, grid._bottom);\n\n      // The grid might be inside one or more elements that clip it's visibility\n      // (e.g overflow scroll/hidden) so we want to find out the visible portion\n      // of the grid in the viewport and use that in our calculations.\n      container = grid._element.parentNode;\n      while (\n        container &&\n        container !== document &&\n        container !== document.documentElement &&\n        container !== document.body\n      ) {\n        if (container.getRootNode && container instanceof DocumentFragment) {\n          container = container.getRootNode().host;\n          continue;\n        }\n\n        if (getStyle(container, 'overflow') !== 'visible') {\n          containerRect = container.getBoundingClientRect();\n          left = Math.max(left, containerRect.left);\n          top = Math.max(top, containerRect.top);\n          right = Math.min(right, containerRect.right);\n          bottom = Math.min(bottom, containerRect.bottom);\n        }\n\n        if (getStyle(container, 'position') === 'fixed') {\n          break;\n        }\n\n        container = container.parentNode;\n      }\n\n      // No need to go further if target rect does not have visible area.\n      if (left >= right || top >= bottom) continue;\n\n      // Check how much dragged element overlaps the container element.\n      targetRect.left = left;\n      targetRect.top = top;\n      targetRect.width = right - left;\n      targetRect.height = bottom - top;\n      gridScore = getIntersectionScore(itemRect, targetRect);\n\n      // Check if this grid is the best match so far.\n      if (gridScore > threshold && gridScore > bestScore) {\n        bestScore = gridScore;\n        target = grid;\n      }\n    }\n\n    // Always reset grids array.\n    gridsArray.length = 0;\n\n    return target;\n  }\n\n  return function (item, options) {\n    var drag = item._drag;\n    var rootGrid = drag._getGrid();\n\n    // Get drag sort predicate settings.\n    var sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;\n    var sortAction = options && options.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n    var migrateAction =\n      options && options.migrateAction === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n\n    // Sort threshold must be a positive number capped to a max value of 100. If\n    // that's not the case this function will not work correctly. So let's clamp\n    // the threshold just in case.\n    sortThreshold = Math.min(Math.max(sortThreshold, minThreshold), maxThreshold);\n\n    // Populate item rect data.\n    itemRect.width = item._width;\n    itemRect.height = item._height;\n    itemRect.left = drag._clientX;\n    itemRect.top = drag._clientY;\n\n    // Calculate the target grid.\n    var grid = getTargetGrid(item, rootGrid, sortThreshold);\n\n    // Return early if we found no grid container element that overlaps the\n    // dragged item enough.\n    if (!grid) return null;\n\n    var isMigration = item.getGrid() !== grid;\n    var gridOffsetLeft = 0;\n    var gridOffsetTop = 0;\n    var matchScore = 0;\n    var matchIndex = -1;\n    var hasValidTargets = false;\n    var target;\n    var score;\n    var i;\n\n    // If item is moved within it's originating grid adjust item's left and\n    // top props. Otherwise if item is moved to/within another grid get the\n    // container element's offset (from the element's content edge).\n    if (grid === rootGrid) {\n      itemRect.left = drag._gridX + item._marginLeft;\n      itemRect.top = drag._gridY + item._marginTop;\n    } else {\n      grid._updateBorders(1, 0, 1, 0);\n      gridOffsetLeft = grid._left + grid._borderLeft;\n      gridOffsetTop = grid._top + grid._borderTop;\n    }\n\n    // Loop through the target grid items and try to find the best match.\n    for (i = 0; i < grid._items.length; i++) {\n      target = grid._items[i];\n\n      // If the target item is not active or the target item is the dragged\n      // item let's skip to the next item.\n      if (!target._isActive || target === item) {\n        continue;\n      }\n\n      // Mark the grid as having valid target items.\n      hasValidTargets = true;\n\n      // Calculate the target's overlap score with the dragged item.\n      targetRect.width = target._width;\n      targetRect.height = target._height;\n      targetRect.left = target._left + target._marginLeft + gridOffsetLeft;\n      targetRect.top = target._top + target._marginTop + gridOffsetTop;\n      score = getIntersectionScore(itemRect, targetRect);\n\n      // Update best match index and score if the target's overlap score with\n      // the dragged item is higher than the current best match score.\n      if (score > matchScore) {\n        matchIndex = i;\n        matchScore = score;\n      }\n    }\n\n    // If there is no valid match and the dragged item is being moved into\n    // another grid we need to do some guess work here. If there simply are no\n    // valid targets (which means that the dragged item will be the only active\n    // item in the new grid) we can just add it as the first item. If we have\n    // valid items in the new grid and the dragged item is overlapping one or\n    // more of the items in the new grid let's make an exception with the\n    // threshold and just pick the item which the dragged item is overlapping\n    // most. However, if the dragged item is not overlapping any of the valid\n    // items in the new grid let's position it as the last item in the grid.\n    if (isMigration && matchScore < sortThreshold) {\n      matchIndex = hasValidTargets ? matchIndex : 0;\n      matchScore = sortThreshold;\n    }\n\n    // Check if the best match overlaps enough to justify a placement switch.\n    if (matchScore >= sortThreshold) {\n      returnData.grid = grid;\n      returnData.index = matchIndex;\n      returnData.action = isMigration ? migrateAction : sortAction;\n      return returnData;\n    }\n\n    return null;\n  };\n})();\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Abort dragging and reset drag data.\n *\n * @public\n */\nItemDrag.prototype.stop = function () {\n  if (!this._isActive) return;\n\n  // If the item is being dropped into another grid, finish it up and return\n  // immediately.\n  if (this._isMigrating) {\n    this._finishMigration();\n    return;\n  }\n\n  var item = this._item;\n  var itemId = item._id;\n\n  // Stop auto-scroll.\n  ItemDrag.autoScroller.removeItem(item);\n\n  // Cancel queued ticks.\n  cancelDragStartTick(itemId);\n  cancelDragMoveTick(itemId);\n  cancelDragScrollTick(itemId);\n\n  // Cancel sort procedure.\n  this._cancelSort();\n\n  if (this._isStarted) {\n    // Remove scroll listeners.\n    this._unbindScrollListeners();\n\n    var element = item._element;\n    var grid = this._getGrid();\n    var draggingClass = grid._settings.itemDraggingClass;\n\n    // Append item element to the container if it's not it's child. Also make\n    // sure the translate values are adjusted to account for the DOM shift.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n      item._setTranslate(this._gridX, this._gridY);\n\n      // We need to do forced reflow to make sure the dragging class is removed\n      // gracefully.\n      // eslint-disable-next-line\n      if (draggingClass) element.clientWidth;\n    }\n\n    // Remove dragging class.\n    removeClass(element, draggingClass);\n  }\n\n  // Reset drag data.\n  this._reset();\n};\n\n/**\n * Manually trigger drag sort. This is only needed for special edge cases where\n * e.g. you have disabled sort and want to trigger a sort right after enabling\n * it (and don't want to wait for the next move/scroll event).\n *\n * @private\n * @param {Boolean} [force=false]\n */\nItemDrag.prototype.sort = function (force) {\n  var item = this._item;\n  if (this._isActive && item._isActive && this._dragMoveEvent) {\n    if (force === true) {\n      this._handleSort();\n    } else {\n      addDragSortTick(item._id, this._handleSort);\n    }\n  }\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemDrag.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n  this._dragger.destroy();\n  ItemDrag.autoScroller.removeItem(this._item);\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Get Grid instance.\n *\n * @private\n * @returns {?Grid}\n */\nItemDrag.prototype._getGrid = function () {\n  return GRID_INSTANCES[this._gridId] || null;\n};\n\n/**\n * Setup/reset drag data.\n *\n * @private\n */\nItemDrag.prototype._reset = function () {\n  this._isActive = false;\n  this._isStarted = false;\n\n  // The dragged item's container element.\n  this._container = null;\n\n  // The dragged item's containing block.\n  this._containingBlock = null;\n\n  // Drag/scroll event data.\n  this._dragStartEvent = null;\n  this._dragMoveEvent = null;\n  this._dragPrevMoveEvent = null;\n  this._scrollEvent = null;\n\n  // All the elements which need to be listened for scroll events during\n  // dragging.\n  this._scrollers = [];\n\n  // The current translateX/translateY position.\n  this._left = 0;\n  this._top = 0;\n\n  // Dragged element's current position within the grid.\n  this._gridX = 0;\n  this._gridY = 0;\n\n  // Dragged element's current offset from window's northwest corner. Does\n  // not account for element's margins.\n  this._clientX = 0;\n  this._clientY = 0;\n\n  // Keep track of the clientX/Y diff for scrolling.\n  this._scrollDiffX = 0;\n  this._scrollDiffY = 0;\n\n  // Keep track of the clientX/Y diff for moving.\n  this._moveDiffX = 0;\n  this._moveDiffY = 0;\n\n  // Offset difference between the dragged element's temporary drag\n  // container and it's original container.\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n\n/**\n * Bind drag scroll handlers to all scrollable ancestor elements of the\n * dragged element and the drag container element.\n *\n * @private\n */\nItemDrag.prototype._bindScrollListeners = function () {\n  var gridContainer = this._getGrid()._element;\n  var dragContainer = this._container;\n  var scrollers = this._scrollers;\n  var gridScrollers;\n  var i;\n\n  // Get dragged element's scrolling parents.\n  scrollers.length = 0;\n  getScrollableAncestors(this._item._element.parentNode, scrollers);\n\n  // If drag container is defined and it's not the same element as grid\n  // container then we need to add the grid container and it's scroll parents\n  // to the elements which are going to be listener for scroll events.\n  if (dragContainer !== gridContainer) {\n    gridScrollers = [];\n    getScrollableAncestors(gridContainer, gridScrollers);\n    for (i = 0; i < gridScrollers.length; i++) {\n      if (scrollers.indexOf(gridScrollers[i]) < 0) {\n        scrollers.push(gridScrollers[i]);\n      }\n    }\n  }\n\n  // Bind scroll listeners.\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n};\n\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n */\nItemDrag.prototype._unbindScrollListeners = function () {\n  var scrollers = this._scrollers;\n  var i;\n\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n\n  scrollers.length = 0;\n};\n\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n * @param {Object} event\n * @returns {Boolean}\n */\nItemDrag.prototype._resolveStartPredicate = function (event) {\n  var predicate = this._startPredicateData;\n  if (event.distance < predicate.distance || predicate.delay) return;\n  this._resetStartPredicate();\n  return true;\n};\n\n/**\n * Forcefully resolve drag start predicate.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._forceResolveStartPredicate = function (event) {\n  if (!this._isDestroyed && this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateState = START_PREDICATE_RESOLVED;\n    this._onStart(event);\n  }\n};\n\n/**\n * Finalize start predicate.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._finishStartPredicate = function (event) {\n  var element = this._item._element;\n\n  // Check if this is a click (very subjective heuristics).\n  var isClick = Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200;\n\n  // Reset predicate.\n  this._resetStartPredicate();\n\n  // If the gesture can be interpreted as click let's try to open the element's\n  // href url (if it is an anchor element).\n  if (isClick) openAnchorHref(element);\n};\n\n/**\n * Reset drag sort heuristics.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n */\nItemDrag.prototype._resetHeuristics = function (x, y) {\n  this._blockedSortIndex = null;\n  this._sortX1 = this._sortX2 = x;\n  this._sortY1 = this._sortY2 = y;\n};\n\n/**\n * Run heuristics and return true if overlap check can be performed, and false\n * if it can not.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n * @returns {Boolean}\n */\nItemDrag.prototype._checkHeuristics = function (x, y) {\n  var settings = this._getGrid()._settings.dragSortHeuristics;\n  var minDist = settings.minDragDistance;\n\n  // Skip heuristics if not needed.\n  if (minDist <= 0) {\n    this._blockedSortIndex = null;\n    return true;\n  }\n\n  var diffX = x - this._sortX2;\n  var diffY = y - this._sortY2;\n\n  // If we can't do proper bounce back check make sure that the blocked index\n  // is not set.\n  var canCheckBounceBack = minDist > 3 && settings.minBounceBackAngle > 0;\n  if (!canCheckBounceBack) {\n    this._blockedSortIndex = null;\n  }\n\n  if (Math.abs(diffX) > minDist || Math.abs(diffY) > minDist) {\n    // Reset blocked index if angle changed enough. This check requires a\n    // minimum value of 3 for minDragDistance to function properly.\n    if (canCheckBounceBack) {\n      var angle = Math.atan2(diffX, diffY);\n      var prevAngle = Math.atan2(this._sortX2 - this._sortX1, this._sortY2 - this._sortY1);\n      var deltaAngle = Math.atan2(Math.sin(angle - prevAngle), Math.cos(angle - prevAngle));\n      if (Math.abs(deltaAngle) > settings.minBounceBackAngle) {\n        this._blockedSortIndex = null;\n      }\n    }\n\n    // Update points.\n    this._sortX1 = this._sortX2;\n    this._sortY1 = this._sortY2;\n    this._sortX2 = x;\n    this._sortY2 = y;\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Reset for default drag start predicate function.\n *\n * @private\n */\nItemDrag.prototype._resetStartPredicate = function () {\n  var predicate = this._startPredicateData;\n  if (predicate) {\n    if (predicate.delayTimer) {\n      predicate.delayTimer = window.clearTimeout(predicate.delayTimer);\n    }\n    this._startPredicateData = null;\n  }\n};\n\n/**\n * Handle the sorting procedure. Manage drag sort heuristics/interval and\n * check overlap when necessary.\n *\n * @private\n */\nItemDrag.prototype._handleSort = function () {\n  if (!this._isActive) return;\n\n  var settings = this._getGrid()._settings;\n\n  // No sorting when drag sort is disabled. Also, account for the scenario where\n  // dragSort is temporarily disabled during drag procedure so we need to reset\n  // sort timer heuristics state too.\n  if (\n    !settings.dragSort ||\n    (!settings.dragAutoScroll.sortDuringScroll && ItemDrag.autoScroller.isItemScrolling(this._item))\n  ) {\n    this._sortX1 = this._sortX2 = this._gridX;\n    this._sortY1 = this._sortY2 = this._gridY;\n    // We set this to true intentionally so that overlap check would be\n    // triggered as soon as possible after sort becomes enabled again.\n    this._isSortNeeded = true;\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n    return;\n  }\n\n  // If sorting is enabled we always need to run the heuristics check to keep\n  // the tracked coordinates updated. We also allow an exception when the sort\n  // timer is finished because the heuristics are intended to prevent overlap\n  // checks based on the dragged element's immediate movement and a delayed\n  // overlap check is valid if it comes through, because it was valid when it\n  // was invoked.\n  var shouldSort = this._checkHeuristics(this._gridX, this._gridY);\n  if (!this._isSortNeeded && !shouldSort) return;\n\n  var sortInterval = settings.dragSortHeuristics.sortInterval;\n  if (sortInterval <= 0 || this._isSortNeeded) {\n    this._isSortNeeded = false;\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n    this._checkOverlap();\n  } else if (this._sortTimer === undefined) {\n    this._sortTimer = window.setTimeout(this._handleSortDelayed, sortInterval);\n  }\n};\n\n/**\n * Delayed sort handler.\n *\n * @private\n */\nItemDrag.prototype._handleSortDelayed = function () {\n  this._isSortNeeded = true;\n  this._sortTimer = undefined;\n  addDragSortTick(this._item._id, this._handleSort);\n};\n\n/**\n * Cancel and reset sort procedure.\n *\n * @private\n */\nItemDrag.prototype._cancelSort = function () {\n  this._isSortNeeded = false;\n  if (this._sortTimer !== undefined) {\n    this._sortTimer = window.clearTimeout(this._sortTimer);\n  }\n  cancelDragSortTick(this._item._id);\n};\n\n/**\n * Handle the ending of the drag procedure for sorting.\n *\n * @private\n */\nItemDrag.prototype._finishSort = function () {\n  var isSortEnabled = this._getGrid()._settings.dragSort;\n  var needsFinalCheck = isSortEnabled && (this._isSortNeeded || this._sortTimer !== undefined);\n  this._cancelSort();\n  if (needsFinalCheck) this._checkOverlap();\n};\n\n/**\n * Check (during drag) if an item is overlapping other items and based on\n * the configuration layout the items.\n *\n * @private\n */\nItemDrag.prototype._checkOverlap = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  var settings = this._getGrid()._settings;\n  var result;\n  var currentGrid;\n  var currentIndex;\n  var targetGrid;\n  var targetIndex;\n  var targetItem;\n  var sortAction;\n  var isMigration;\n\n  // Get overlap check result.\n  if (isFunction(settings.dragSortPredicate)) {\n    result = settings.dragSortPredicate(item, this._dragMoveEvent);\n  } else {\n    result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);\n  }\n\n  // Let's make sure the result object has a valid index before going further.\n  if (!result || typeof result.index !== 'number') return;\n\n  sortAction = result.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n  currentGrid = item.getGrid();\n  targetGrid = result.grid || currentGrid;\n  isMigration = currentGrid !== targetGrid;\n  currentIndex = currentGrid._items.indexOf(item);\n  targetIndex = normalizeArrayIndex(\n    targetGrid._items,\n    result.index,\n    isMigration && sortAction === ACTION_MOVE ? 1 : 0\n  );\n\n  // Prevent position bounce.\n  if (!isMigration && targetIndex === this._blockedSortIndex) {\n    return;\n  }\n\n  // If the item was moved within it's current grid.\n  if (!isMigration) {\n    // Make sure the target index is not the current index.\n    if (currentIndex !== targetIndex) {\n      this._blockedSortIndex = currentIndex;\n\n      // Do the sort.\n      (sortAction === ACTION_SWAP ? arraySwap : arrayMove)(\n        currentGrid._items,\n        currentIndex,\n        targetIndex\n      );\n\n      // Emit move event.\n      if (currentGrid._hasListeners(EVENT_MOVE)) {\n        currentGrid._emit(EVENT_MOVE, {\n          item: item,\n          fromIndex: currentIndex,\n          toIndex: targetIndex,\n          action: sortAction,\n        });\n      }\n\n      // Layout the grid.\n      currentGrid.layout();\n    }\n  }\n\n  // If the item was moved to another grid.\n  else {\n    this._blockedSortIndex = null;\n\n    // Let's fetch the target item when it's still in it's original index.\n    targetItem = targetGrid._items[targetIndex];\n\n    // Emit beforeSend event.\n    if (currentGrid._hasListeners(EVENT_BEFORE_SEND)) {\n      currentGrid._emit(EVENT_BEFORE_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // Emit beforeReceive event.\n    if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n      targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // Update item's grid id reference.\n    item._gridId = targetGrid._id;\n\n    // Update drag instance's migrating indicator.\n    this._isMigrating = item._gridId !== this._gridId;\n\n    // Move item instance from current grid to target grid.\n    currentGrid._items.splice(currentIndex, 1);\n    arrayInsert(targetGrid._items, item, targetIndex);\n\n    // Reset sort data.\n    item._sortData = null;\n\n    // Emit send event.\n    if (currentGrid._hasListeners(EVENT_SEND)) {\n      currentGrid._emit(EVENT_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // Emit receive event.\n    if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n      targetGrid._emit(EVENT_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // If the sort action is \"swap\" let's respect it and send the target item\n    // (if it exists) from the target grid to the originating grid. This process\n    // is done on purpose after the dragged item placed within the target grid\n    // so that we can keep this implementation as simple as possible utilizing\n    // the existing API.\n    if (sortAction === ACTION_SWAP && targetItem && targetItem.isActive()) {\n      // Sanity check to make sure that the target item is still part of the\n      // target grid. It could have been manipulated in the event handlers.\n      if (targetGrid._items.indexOf(targetItem) > -1) {\n        targetGrid.send(targetItem, currentGrid, currentIndex, {\n          appendTo: this._container || document.body,\n          layoutSender: false,\n          layoutReceiver: false,\n        });\n      }\n    }\n\n    // Layout both grids.\n    currentGrid.layout();\n    targetGrid.layout();\n  }\n};\n\n/**\n * If item is dragged into another grid, finish the migration process\n * gracefully.\n *\n * @private\n */\nItemDrag.prototype._finishMigration = function () {\n  var item = this._item;\n  var release = item._dragRelease;\n  var element = item._element;\n  var isActive = item._isActive;\n  var targetGrid = item.getGrid();\n  var targetGridElement = targetGrid._element;\n  var targetSettings = targetGrid._settings;\n  var targetContainer = targetSettings.dragContainer || targetGridElement;\n  var currentSettings = this._getGrid()._settings;\n  var currentContainer = element.parentNode;\n  var currentVisClass = isActive\n    ? currentSettings.itemVisibleClass\n    : currentSettings.itemHiddenClass;\n  var nextVisClass = isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n  var translate;\n  var offsetDiff;\n\n  // Destroy current drag. Note that we need to set the migrating flag to\n  // false first, because otherwise we create an infinite loop between this\n  // and the drag.stop() method.\n  this._isMigrating = false;\n  this.destroy();\n\n  // Update item class.\n  if (currentSettings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, currentSettings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  }\n\n  // Update visibility class.\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  }\n\n  // Move the item inside the target container if it's different than the\n  // current container.\n  if (targetContainer !== currentContainer) {\n    targetContainer.appendChild(element);\n    offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n    translate = getTranslate(element);\n    translate.x -= offsetDiff.left;\n    translate.y -= offsetDiff.top;\n  }\n\n  // Update item's cached dimensions.\n  item._refreshDimensions();\n\n  // Calculate the offset difference between target's drag container (if any)\n  // and actual grid container element. We save it later for the release\n  // process.\n  offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n  release._containerDiffX = offsetDiff.left;\n  release._containerDiffY = offsetDiff.top;\n\n  // Recreate item's drag handler.\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n  // Adjust the position of the item element if it was moved from a container\n  // to another.\n  if (targetContainer !== currentContainer) {\n    item._setTranslate(translate.x, translate.y);\n  }\n\n  // Update child element's styles to reflect the current visibility state.\n  item._visibility.setStyles(isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\n\n  // Start the release.\n  release.start();\n};\n\n/**\n * Drag pre-start handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._preStartCheck = function (event) {\n  // Let's activate drag start predicate state.\n  if (this._startPredicateState === START_PREDICATE_INACTIVE) {\n    this._startPredicateState = START_PREDICATE_PENDING;\n  }\n\n  // If predicate is pending try to resolve it.\n  if (this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateResult = this._startPredicate(this._item, event);\n    if (this._startPredicateResult === true) {\n      this._startPredicateState = START_PREDICATE_RESOLVED;\n      this._onStart(event);\n    } else if (this._startPredicateResult === false) {\n      this._resetStartPredicate(event);\n      this._dragger._reset();\n      this._startPredicateState = START_PREDICATE_INACTIVE;\n    }\n  }\n\n  // Otherwise if predicate is resolved and drag is active, move the item.\n  else if (this._startPredicateState === START_PREDICATE_RESOLVED && this._isActive) {\n    this._onMove(event);\n  }\n};\n\n/**\n * Drag pre-end handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._preEndCheck = function (event) {\n  var isResolved = this._startPredicateState === START_PREDICATE_RESOLVED;\n\n  // Do final predicate check to allow user to unbind stuff for the current\n  // drag procedure within the predicate callback. The return value of this\n  // check will have no effect to the state of the predicate.\n  this._startPredicate(this._item, event);\n\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n\n  if (!isResolved || !this._isActive) return;\n\n  if (this._isStarted) {\n    this._onEnd(event);\n  } else {\n    this.stop();\n  }\n};\n\n/**\n * Drag start handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onStart = function (event) {\n  var item = this._item;\n  if (!item._isActive) return;\n\n  this._isActive = true;\n  this._dragStartEvent = event;\n  ItemDrag.autoScroller.addItem(item);\n\n  addDragStartTick(item._id, this._prepareStart, this._applyStart);\n};\n\n/**\n * Prepare item to be dragged.\n *\n * @private\n *  ItemDrag.prototype\n */\nItemDrag.prototype._prepareStart = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var element = item._element;\n  var grid = this._getGrid();\n  var settings = grid._settings;\n  var gridContainer = grid._element;\n  var dragContainer = settings.dragContainer || gridContainer;\n  var containingBlock = getContainingBlock(dragContainer);\n  var translate = getTranslate(element);\n  var elementRect = element.getBoundingClientRect();\n  var hasDragContainer = dragContainer !== gridContainer;\n\n  this._container = dragContainer;\n  this._containingBlock = containingBlock;\n  this._clientX = elementRect.left;\n  this._clientY = elementRect.top;\n  this._left = this._gridX = translate.x;\n  this._top = this._gridY = translate.y;\n  this._scrollDiffX = this._scrollDiffY = 0;\n  this._moveDiffX = this._moveDiffY = 0;\n\n  this._resetHeuristics(this._gridX, this._gridY);\n\n  // If a specific drag container is set and it is different from the\n  // grid's container element we store the offset between containers.\n  if (hasDragContainer) {\n    var offsetDiff = getOffsetDiff(containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  }\n};\n\n/**\n * Start drag for the item.\n *\n * @private\n */\nItemDrag.prototype._applyStart = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var grid = this._getGrid();\n  var element = item._element;\n  var release = item._dragRelease;\n  var migrate = item._migrate;\n  var hasDragContainer = this._container !== grid._element;\n\n  if (item.isPositioning()) {\n    item._layout.stop(true, this._left, this._top);\n  }\n\n  if (migrate._isActive) {\n    this._left -= migrate._containerDiffX;\n    this._top -= migrate._containerDiffY;\n    this._gridX -= migrate._containerDiffX;\n    this._gridY -= migrate._containerDiffY;\n    migrate.stop(true, this._left, this._top);\n  }\n\n  if (item.isReleasing()) {\n    release._reset();\n  }\n\n  if (grid._settings.dragPlaceholder.enabled) {\n    item._dragPlaceholder.create();\n  }\n\n  this._isStarted = true;\n\n  grid._emit(EVENT_DRAG_INIT, item, this._dragStartEvent);\n\n  if (hasDragContainer) {\n    // If the dragged element is a child of the drag container all we need to\n    // do is setup the relative drag position data.\n    if (element.parentNode === this._container) {\n      this._gridX -= this._containerDiffX;\n      this._gridY -= this._containerDiffY;\n    }\n    // Otherwise we need to append the element inside the correct container,\n    // setup the actual drag position data and adjust the element's translate\n    // values to account for the DOM position shift.\n    else {\n      this._left += this._containerDiffX;\n      this._top += this._containerDiffY;\n      this._container.appendChild(element);\n      item._setTranslate(this._left, this._top);\n    }\n  }\n\n  addClass(element, grid._settings.itemDraggingClass);\n  this._bindScrollListeners();\n  grid._emit(EVENT_DRAG_START, item, this._dragStartEvent);\n};\n\n/**\n * Drag move handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onMove = function (event) {\n  var item = this._item;\n\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  this._dragMoveEvent = event;\n  addDragMoveTick(item._id, this._prepareMove, this._applyMove);\n  addDragSortTick(item._id, this._handleSort);\n};\n\n/**\n * Prepare dragged item for moving.\n *\n * @private\n */\nItemDrag.prototype._prepareMove = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var settings = this._getGrid()._settings;\n  var axis = settings.dragAxis;\n  var nextEvent = this._dragMoveEvent;\n  var prevEvent = this._dragPrevMoveEvent || this._dragStartEvent || nextEvent;\n\n  // Update horizontal position data.\n  if (axis !== 'y') {\n    var moveDiffX = nextEvent.clientX - prevEvent.clientX;\n    this._left = this._left - this._moveDiffX + moveDiffX;\n    this._gridX = this._gridX - this._moveDiffX + moveDiffX;\n    this._clientX = this._clientX - this._moveDiffX + moveDiffX;\n    this._moveDiffX = moveDiffX;\n  }\n\n  // Update vertical position data.\n  if (axis !== 'x') {\n    var moveDiffY = nextEvent.clientY - prevEvent.clientY;\n    this._top = this._top - this._moveDiffY + moveDiffY;\n    this._gridY = this._gridY - this._moveDiffY + moveDiffY;\n    this._clientY = this._clientY - this._moveDiffY + moveDiffY;\n    this._moveDiffY = moveDiffY;\n  }\n\n  this._dragPrevMoveEvent = nextEvent;\n};\n\n/**\n * Apply movement to dragged item.\n *\n * @private\n */\nItemDrag.prototype._applyMove = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  this._moveDiffX = this._moveDiffY = 0;\n  item._setTranslate(this._left, this._top);\n  this._getGrid()._emit(EVENT_DRAG_MOVE, item, this._dragMoveEvent);\n  ItemDrag.autoScroller.updateItem(item);\n};\n\n/**\n * Drag scroll handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onScroll = function (event) {\n  var item = this._item;\n\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  this._scrollEvent = event;\n  addDragScrollTick(item._id, this._prepareScroll, this._applyScroll);\n  addDragSortTick(item._id, this._handleSort);\n};\n\n/**\n * Prepare dragged item for scrolling.\n *\n * @private\n */\nItemDrag.prototype._prepareScroll = function () {\n  if (!this._isActive) return;\n\n  // If item is not active do nothing.\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var element = item._element;\n  var grid = this._getGrid();\n  var gridContainer = grid._element;\n  var rect = element.getBoundingClientRect();\n\n  // Update container diff.\n  if (this._container !== gridContainer) {\n    var offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  }\n\n  // Update horizontal position data.\n  var scrollDiffX = this._clientX - this._moveDiffX - rect.left;\n  this._left = this._left - this._scrollDiffX + scrollDiffX;\n  this._scrollDiffX = scrollDiffX;\n\n  // Update vertical position data.\n  var scrollDiffY = this._clientY - this._moveDiffY - rect.top;\n  this._top = this._top - this._scrollDiffY + scrollDiffY;\n  this._scrollDiffY = scrollDiffY;\n\n  // Update grid position.\n  this._gridX = this._left - this._containerDiffX;\n  this._gridY = this._top - this._containerDiffY;\n};\n\n/**\n * Apply scroll to dragged item.\n *\n * @private\n */\nItemDrag.prototype._applyScroll = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  this._scrollDiffX = this._scrollDiffY = 0;\n  item._setTranslate(this._left, this._top);\n  this._getGrid()._emit(EVENT_DRAG_SCROLL, item, this._scrollEvent);\n};\n\n/**\n * Drag end handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onEnd = function (event) {\n  var item = this._item;\n  var element = item._element;\n  var grid = this._getGrid();\n  var settings = grid._settings;\n  var release = item._dragRelease;\n\n  // If item is not active, reset drag.\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  // Cancel queued ticks.\n  cancelDragStartTick(item._id);\n  cancelDragMoveTick(item._id);\n  cancelDragScrollTick(item._id);\n\n  // Finish sort procedure (does final overlap check if needed).\n  this._finishSort();\n\n  // Remove scroll listeners.\n  this._unbindScrollListeners();\n\n  // Setup release data.\n  release._containerDiffX = this._containerDiffX;\n  release._containerDiffY = this._containerDiffY;\n\n  // Reset drag data.\n  this._reset();\n\n  // Remove drag class name from element.\n  removeClass(element, settings.itemDraggingClass);\n\n  // Stop auto-scroll.\n  ItemDrag.autoScroller.removeItem(item);\n\n  // Emit dragEnd event.\n  grid._emit(EVENT_DRAG_END, item, event);\n\n  // Finish up the migration process or start the release process.\n  this._isMigrating ? this._finishMigration() : release.start();\n};\n\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Check if an element is an anchor element and open the href url if possible.\n *\n * @param {HTMLElement} element\n */\nfunction openAnchorHref(element) {\n  // Make sure the element is anchor element.\n  if (element.tagName.toLowerCase() !== 'a') return;\n\n  // Get href and make sure it exists.\n  var href = element.getAttribute('href');\n  if (!href) return;\n\n  // Finally let's navigate to the link href.\n  var target = element.getAttribute('target');\n  if (target && target !== '_self') {\n    window.open(href, target);\n  } else {\n    window.location.href = href;\n  }\n}\n\n/**\n * Get current values of the provided styles definition object or array.\n *\n * @param {HTMLElement} element\n * @param {(Object|Array} styles\n * @return {Object}\n */\nfunction getCurrentStyles(element, styles) {\n  var result = {};\n  var prop, i;\n\n  if (Array.isArray(styles)) {\n    for (i = 0; i < styles.length; i++) {\n      prop = styles[i];\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  } else {\n    for (prop in styles) {\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  }\n\n  return result;\n}\n\nvar unprefixRegEx = /^(webkit|moz|ms|o|Webkit|Moz|MS|O)(?=[A-Z])/;\nvar cache = {};\n\n/**\n * Remove any potential vendor prefixes from a property name.\n *\n * @param {String} prop\n * @returns {String}\n */\nfunction getUnprefixedPropName(prop) {\n  var result = cache[prop];\n  if (result) return result;\n\n  result = prop.replace(unprefixRegEx, '');\n\n  if (result !== prop) {\n    result = result[0].toLowerCase() + result.slice(1);\n  }\n\n  cache[prop] = result;\n\n  return result;\n}\n\nvar nativeCode = '[native code]';\n\n/**\n * Check if a value (e.g. a method or constructor) is native code. Good for\n * detecting when a polyfill is used and when not.\n *\n * @param {*} feat\n * @returns {Boolean}\n */\nfunction isNative(feat) {\n  var S = window.Symbol;\n  return !!(\n    feat &&\n    isFunction(S) &&\n    isFunction(S.toString) &&\n    S(feat).toString().indexOf(nativeCode) > -1\n  );\n}\n\n/**\n * Set inline styles to an element.\n *\n * @param {HTMLElement} element\n * @param {Object} styles\n */\nfunction setStyles(element, styles) {\n  for (var prop in styles) {\n    element.style[prop] = styles[prop];\n  }\n}\n\nvar HAS_WEB_ANIMATIONS = !!(Element && isFunction(Element.prototype.animate));\nvar HAS_NATIVE_WEB_ANIMATIONS = !!(Element && isNative(Element.prototype.animate));\n\n/**\n * Item animation handler powered by Web Animations API.\n *\n * @class\n * @param {HTMLElement} element\n */\nfunction Animator(element) {\n  this._element = element;\n  this._animation = null;\n  this._duration = 0;\n  this._easing = '';\n  this._callback = null;\n  this._props = [];\n  this._values = [];\n  this._isDestroyed = false;\n  this._onFinish = this._onFinish.bind(this);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start instance's animation. Automatically stops current animation if it is\n * running.\n *\n * @public\n * @param {Object} propsFrom\n * @param {Object} propsTo\n * @param {Object} [options]\n * @param {Number} [options.duration=300]\n * @param {String} [options.easing='ease']\n * @param {Function} [options.onFinish]\n */\nAnimator.prototype.start = function (propsFrom, propsTo, options) {\n  if (this._isDestroyed) return;\n\n  var element = this._element;\n  var opts = options || {};\n\n  // If we don't have web animations available let's not animate.\n  if (!HAS_WEB_ANIMATIONS) {\n    setStyles(element, propsTo);\n    this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n    this._onFinish();\n    return;\n  }\n\n  var animation = this._animation;\n  var currentProps = this._props;\n  var currentValues = this._values;\n  var duration = opts.duration || 300;\n  var easing = opts.easing || 'ease';\n  var cancelAnimation = false;\n  var propName, propCount, propIndex;\n\n  // If we have an existing animation running, let's check if it needs to be\n  // cancelled or if it can continue running.\n  if (animation) {\n    propCount = 0;\n\n    // Cancel animation if duration or easing has changed.\n    if (duration !== this._duration || easing !== this._easing) {\n      cancelAnimation = true;\n    }\n\n    // Check if the requested animation target props and values match with the\n    // current props and values.\n    if (!cancelAnimation) {\n      for (propName in propsTo) {\n        ++propCount;\n        propIndex = currentProps.indexOf(propName);\n        if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {\n          cancelAnimation = true;\n          break;\n        }\n      }\n\n      // Check if the target props count matches current props count. This is\n      // needed for the edge case scenario where target props contain the same\n      // styles as current props, but the current props have some additional\n      // props.\n      if (propCount !== currentProps.length) {\n        cancelAnimation = true;\n      }\n    }\n  }\n\n  // Cancel animation (if required).\n  if (cancelAnimation) animation.cancel();\n\n  // Store animation callback.\n  this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n\n  // If we have a running animation that does not need to be cancelled, let's\n  // call it a day here and let it run.\n  if (animation && !cancelAnimation) return;\n\n  // Store target props and values to instance.\n  currentProps.length = currentValues.length = 0;\n  for (propName in propsTo) {\n    currentProps.push(propName);\n    currentValues.push(propsTo[propName]);\n  }\n\n  // Start the animation. We need to provide unprefixed property names to the\n  // Web Animations polyfill if it is being used. If we have native Web\n  // Animations available we need to provide prefixed properties instead.\n  this._duration = duration;\n  this._easing = easing;\n  this._animation = element.animate(\n    [\n      createFrame(propsFrom, HAS_NATIVE_WEB_ANIMATIONS),\n      createFrame(propsTo, HAS_NATIVE_WEB_ANIMATIONS),\n    ],\n    {\n      duration: duration,\n      easing: easing,\n    }\n  );\n  this._animation.onfinish = this._onFinish;\n\n  // Set the end styles. This makes sure that the element stays at the end\n  // values after animation is finished.\n  setStyles(element, propsTo);\n};\n\n/**\n * Stop instance's current animation if running.\n *\n * @public\n */\nAnimator.prototype.stop = function () {\n  if (this._isDestroyed || !this._animation) return;\n  this._animation.cancel();\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n};\n\n/**\n * Read the current values of the element's animated styles from the DOM.\n *\n * @public\n * @return {Object}\n */\nAnimator.prototype.getCurrentStyles = function () {\n  return getCurrentStyles(element, currentProps);\n};\n\n/**\n * Check if the item is being animated currently.\n *\n * @public\n * @return {Boolean}\n */\nAnimator.prototype.isAnimating = function () {\n  return !!this._animation;\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nAnimator.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n  this._element = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Animation end handler.\n *\n * @private\n */\nAnimator.prototype._onFinish = function () {\n  var callback = this._callback;\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n  callback && callback();\n};\n\n/**\n * Private helpers\n * ***************\n */\n\nfunction createFrame(props, prefix) {\n  var frame = {};\n  for (var prop in props) {\n    frame[prefix ? prop : getUnprefixedPropName(prop)] = props[prop];\n  }\n  return frame;\n}\n\n/**\n * Transform translateX and translateY value into CSS transform style\n * property's value.\n *\n * @param {Number} x\n * @param {Number} y\n * @returns {String}\n */\nfunction getTranslateString(x, y) {\n  return 'translateX(' + x + 'px) translateY(' + y + 'px)';\n}\n\n/**\n * Drag placeholder.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDragPlaceholder(item) {\n  this._item = item;\n  this._animation = new Animator();\n  this._element = null;\n  this._className = '';\n  this._didMigrate = false;\n  this._resetAfterLayout = false;\n  this._left = 0;\n  this._top = 0;\n  this._transX = 0;\n  this._transY = 0;\n  this._nextTransX = 0;\n  this._nextTransY = 0;\n\n  // Bind animation handlers.\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n  this._updateDimensions = this._updateDimensions.bind(this);\n\n  // Bind event handlers.\n  this._onLayoutStart = this._onLayoutStart.bind(this);\n  this._onLayoutEnd = this._onLayoutEnd.bind(this);\n  this._onReleaseEnd = this._onReleaseEnd.bind(this);\n  this._onMigrate = this._onMigrate.bind(this);\n  this._onHide = this._onHide.bind(this);\n}\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Update placeholder's dimensions to match the item's dimensions.\n *\n * @private\n */\nItemDragPlaceholder.prototype._updateDimensions = function () {\n  if (!this.isActive()) return;\n  setStyles(this._element, {\n    width: this._item._width + 'px',\n    height: this._item._height + 'px',\n  });\n};\n\n/**\n * Move placeholder to a new position.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} isInstant\n */\nItemDragPlaceholder.prototype._onLayoutStart = function (items, isInstant) {\n  var item = this._item;\n\n  // If the item is not part of the layout anymore reset placeholder.\n  if (items.indexOf(item) === -1) {\n    this.reset();\n    return;\n  }\n\n  var nextLeft = item._left;\n  var nextTop = item._top;\n  var currentLeft = this._left;\n  var currentTop = this._top;\n\n  // Keep track of item layout position.\n  this._left = nextLeft;\n  this._top = nextTop;\n\n  // If item's position did not change, and the item did not migrate and the\n  // layout is not instant and we can safely skip layout.\n  if (!isInstant && !this._didMigrate && currentLeft === nextLeft && currentTop === nextTop) {\n    return;\n  }\n\n  // Slots data is calculated with item margins added to them so we need to add\n  // item's left and top margin to the slot data to get the placeholder's\n  // next position.\n  var nextX = nextLeft + item._marginLeft;\n  var nextY = nextTop + item._marginTop;\n\n  // Just snap to new position without any animations if no animation is\n  // required or if placeholder moves between grids.\n  var grid = item.getGrid();\n  var animEnabled = !isInstant && grid._settings.layoutDuration > 0;\n  if (!animEnabled || this._didMigrate) {\n    // Cancel potential (queued) layout tick.\n    cancelPlaceholderLayoutTick(item._id);\n\n    // Snap placeholder to correct position.\n    this._element.style[transformProp] = getTranslateString(nextX, nextY);\n    this._animation.stop();\n\n    // Move placeholder inside correct container after migration.\n    if (this._didMigrate) {\n      grid.getElement().appendChild(this._element);\n      this._didMigrate = false;\n    }\n\n    return;\n  }\n\n  // Start the placeholder's layout animation in the next tick. We do this to\n  // avoid layout thrashing.\n  this._nextTransX = nextX;\n  this._nextTransY = nextY;\n  addPlaceholderLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n\n/**\n * Prepare placeholder for layout animation.\n *\n * @private\n */\nItemDragPlaceholder.prototype._setupAnimation = function () {\n  if (!this.isActive()) return;\n\n  var translate = getTranslate(this._element);\n  this._transX = translate.x;\n  this._transY = translate.y;\n};\n\n/**\n * Start layout animation.\n *\n * @private\n */\nItemDragPlaceholder.prototype._startAnimation = function () {\n  if (!this.isActive()) return;\n\n  var animation = this._animation;\n  var currentX = this._transX;\n  var currentY = this._transY;\n  var nextX = this._nextTransX;\n  var nextY = this._nextTransY;\n\n  // If placeholder is already in correct position let's just stop animation\n  // and be done with it.\n  if (currentX === nextX && currentY === nextY) {\n    if (animation.isAnimating()) {\n      this._element.style[transformProp] = getTranslateString(nextX, nextY);\n      animation.stop();\n    }\n    return;\n  }\n\n  // Otherwise let's start the animation.\n  var settings = this._item.getGrid()._settings;\n  var currentStyles = {};\n  var targetStyles = {};\n  currentStyles[transformProp] = getTranslateString(currentX, currentY);\n  targetStyles[transformProp] = getTranslateString(nextX, nextY);\n  animation.start(currentStyles, targetStyles, {\n    duration: settings.layoutDuration,\n    easing: settings.layoutEasing,\n    onFinish: this._onLayoutEnd,\n  });\n};\n\n/**\n * Layout end handler.\n *\n * @private\n */\nItemDragPlaceholder.prototype._onLayoutEnd = function () {\n  if (this._resetAfterLayout) {\n    this.reset();\n  }\n};\n\n/**\n * Drag end handler. This handler is called when dragReleaseEnd event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Item} item\n */\nItemDragPlaceholder.prototype._onReleaseEnd = function (item) {\n  if (item._id === this._item._id) {\n    // If the placeholder is not animating anymore we can safely reset it.\n    if (!this._animation.isAnimating()) {\n      this.reset();\n      return;\n    }\n\n    // If the placeholder item is still animating here, let's wait for it to\n    // finish it's animation.\n    this._resetAfterLayout = true;\n  }\n};\n\n/**\n * Migration start handler. This handler is called when beforeSend event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Object} data\n * @param {Item} data.item\n * @param {Grid} data.fromGrid\n * @param {Number} data.fromIndex\n * @param {Grid} data.toGrid\n * @param {Number} data.toIndex\n */\nItemDragPlaceholder.prototype._onMigrate = function (data) {\n  // Make sure we have a matching item.\n  if (data.item !== this._item) return;\n\n  var grid = this._item.getGrid();\n  var nextGrid = data.toGrid;\n\n  // Unbind listeners from current grid.\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide);\n\n  // Bind listeners to the next grid.\n  nextGrid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  nextGrid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  nextGrid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  nextGrid.on(EVENT_HIDE_START, this._onHide);\n\n  // Mark the item as migrated.\n  this._didMigrate = true;\n};\n\n/**\n * Reset placeholder if the associated item is hidden.\n *\n * @private\n * @param {Item[]} items\n */\nItemDragPlaceholder.prototype._onHide = function (items) {\n  if (items.indexOf(this._item) > -1) this.reset();\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Create placeholder. Note that this method only writes to DOM and does not\n * read anything from DOM so it should not cause any additional layout\n * thrashing when it's called at the end of the drag start procedure.\n *\n * @public\n */\nItemDragPlaceholder.prototype.create = function () {\n  // If we already have placeholder set up we can skip the initiation logic.\n  if (this.isActive()) {\n    this._resetAfterLayout = false;\n    return;\n  }\n\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation;\n\n  // Keep track of layout position.\n  this._left = item._left;\n  this._top = item._top;\n\n  // Create placeholder element.\n  var element;\n  if (isFunction(settings.dragPlaceholder.createElement)) {\n    element = settings.dragPlaceholder.createElement(item);\n  } else {\n    element = document.createElement('div');\n  }\n  this._element = element;\n\n  // Update element to animation instance.\n  animation._element = element;\n\n  // Add placeholder class to the placeholder element.\n  this._className = settings.itemPlaceholderClass || '';\n  if (this._className) {\n    addClass(element, this._className);\n  }\n\n  // Set initial styles.\n  setStyles(element, {\n    position: 'absolute',\n    left: '0px',\n    top: '0px',\n    width: item._width + 'px',\n    height: item._height + 'px',\n  });\n\n  // Set initial position.\n  element.style[transformProp] = getTranslateString(\n    item._left + item._marginLeft,\n    item._top + item._marginTop\n  );\n\n  // Bind event listeners.\n  grid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.on(EVENT_HIDE_START, this._onHide);\n\n  // onCreate hook.\n  if (isFunction(settings.dragPlaceholder.onCreate)) {\n    settings.dragPlaceholder.onCreate(item, element);\n  }\n\n  // Insert the placeholder element to the grid.\n  grid.getElement().appendChild(element);\n};\n\n/**\n * Reset placeholder data.\n *\n * @public\n */\nItemDragPlaceholder.prototype.reset = function () {\n  if (!this.isActive()) return;\n\n  var element = this._element;\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation;\n\n  // Reset flag.\n  this._resetAfterLayout = false;\n\n  // Cancel potential (queued) layout tick.\n  cancelPlaceholderLayoutTick(item._id);\n  cancelPlaceholderResizeTick(item._id);\n\n  // Reset animation instance.\n  animation.stop();\n  animation._element = null;\n\n  // Unbind event listeners.\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide);\n\n  // Remove placeholder class from the placeholder element.\n  if (this._className) {\n    removeClass(element, this._className);\n    this._className = '';\n  }\n\n  // Remove element.\n  element.parentNode.removeChild(element);\n  this._element = null;\n\n  // onRemove hook. Note that here we use the current grid's onRemove callback\n  // so if the item has migrated during drag the onRemove method will not be\n  // the originating grid's method.\n  if (isFunction(settings.dragPlaceholder.onRemove)) {\n    settings.dragPlaceholder.onRemove(item, element);\n  }\n};\n\n/**\n * Check if placeholder is currently active (visible).\n *\n * @public\n * @returns {Boolean}\n */\nItemDragPlaceholder.prototype.isActive = function () {\n  return !!this._element;\n};\n\n/**\n * Get placeholder element.\n *\n * @public\n * @returns {?HTMLElement}\n */\nItemDragPlaceholder.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Update placeholder's dimensions to match the item's dimensions. Note that\n * the updating is done asynchronously in the next tick to avoid layout\n * thrashing.\n *\n * @public\n */\nItemDragPlaceholder.prototype.updateDimensions = function () {\n  if (!this.isActive()) return;\n  addPlaceholderResizeTick(this._item._id, this._updateDimensions);\n};\n\n/**\n * Destroy placeholder instance.\n *\n * @public\n */\nItemDragPlaceholder.prototype.destroy = function () {\n  this.reset();\n  this._animation.destroy();\n  this._item = this._animation = null;\n};\n\n/**\n * The release process handler constructor. Although this might seem as proper\n * fit for the drag process this needs to be separated into it's own logic\n * because there might be a scenario where drag is disabled, but the release\n * process still needs to be implemented (dragging from a grid to another).\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDragRelease(item) {\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the release process of an item.\n *\n * @public\n */\nItemDragRelease.prototype.start = function () {\n  if (this._isDestroyed || this._isActive) return;\n\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  this._isActive = true;\n  addClass(item._element, settings.itemReleasingClass);\n  if (!settings.dragRelease.useDragContainer) {\n    this._placeToGrid();\n  }\n  grid._emit(EVENT_DRAG_RELEASE_START, item);\n\n  // Let's start layout manually _only_ if there is no unfinished layout in\n  // about to finish.\n  if (!grid._nextLayoutData) item._layout.start(false);\n};\n\n/**\n * End the release process of an item. This method can be used to abort an\n * ongoing release process (animation) or finish the release process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the release be aborted? When true, the release end event won't be\n *    emitted. Set to true only when you need to abort the release process\n *    while the item is animating to it's position.\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\nItemDragRelease.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n\n  var item = this._item;\n  var grid = item.getGrid();\n\n  if (!abort && (left === undefined || top === undefined)) {\n    left = item._left;\n    top = item._top;\n  }\n\n  var didReparent = this._placeToGrid(left, top);\n  this._reset(didReparent);\n\n  if (!abort) grid._emit(EVENT_DRAG_RELEASE_END, item);\n};\n\nItemDragRelease.prototype.isJustReleased = function () {\n  return this._isActive && this._isPositioningStarted === false;\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemDragRelease.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Move the element back to the grid container element if it does not exist\n * there already.\n *\n * @private\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n * @returns {Boolean}\n *   - Returns `true` if the element was reparented.\n */\nItemDragRelease.prototype._placeToGrid = function (left, top) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var container = item.getGrid()._element;\n  var didReparent = false;\n\n  if (element.parentNode !== container) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(element);\n      left = translate.x - this._containerDiffX;\n      top = translate.y - this._containerDiffY;\n    }\n\n    container.appendChild(element);\n    item._setTranslate(left, top);\n    didReparent = true;\n  }\n\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n\n  return didReparent;\n};\n\n/**\n * Reset data and remove releasing class.\n *\n * @private\n * @param {Boolean} [needsReflow]\n */\nItemDragRelease.prototype._reset = function (needsReflow) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var releasingClass = item.getGrid()._settings.itemReleasingClass;\n\n  this._isActive = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n\n  // If the element was just reparented we need to do a forced reflow to remove\n  // the class gracefully.\n  if (releasingClass) {\n    // eslint-disable-next-line\n    if (needsReflow) item._element.clientWidth;\n    removeClass(item._element, releasingClass);\n  }\n};\n\nvar MIN_ANIMATION_DISTANCE = 2;\n\n/**\n * Layout manager for Item instance, handles the positioning of an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemLayout(item) {\n  var element = item._element;\n  var elementStyle = element.style;\n\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isInterrupted = false;\n  this._currentStyles = {};\n  this._targetStyles = {};\n  this._nextLeft = 0;\n  this._nextTop = 0;\n  this._offsetLeft = 0;\n  this._offsetTop = 0;\n  this._skipNextAnimation = false;\n  this._animOptions = {\n    onFinish: this._finish.bind(this),\n    duration: 0,\n    easing: 0,\n  };\n\n  // Set element's initial position styles.\n  elementStyle.left = '0px';\n  elementStyle.top = '0px';\n  item._setTranslate(0, 0);\n\n  this._animation = new Animator(element);\n  this._queue = 'layout-' + item._id;\n\n  // Bind animation handlers and finish method.\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start item layout based on it's current data.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemLayout.prototype.start = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var release = item._dragRelease;\n  var gridSettings = item.getGrid()._settings;\n  var isPositioning = this._isActive;\n  var isJustReleased = release.isJustReleased();\n  var animDuration = isJustReleased\n    ? gridSettings.dragRelease.duration\n    : gridSettings.layoutDuration;\n  var animEasing = isJustReleased ? gridSettings.dragRelease.easing : gridSettings.layoutEasing;\n  var animEnabled = !instant && !this._skipNextAnimation && animDuration > 0;\n\n  // If the item is currently positioning cancel potential queued layout tick\n  // and process current layout callback queue with interrupted flag on.\n  if (isPositioning) {\n    cancelLayoutTick(item._id);\n    item._emitter.burst(this._queue, true, item);\n  }\n\n  // Mark release positioning as started.\n  if (isJustReleased) release._isPositioningStarted = true;\n\n  // Push the callback to the callback queue.\n  if (isFunction(onFinish)) {\n    item._emitter.on(this._queue, onFinish);\n  }\n\n  // Reset animation skipping flag.\n  this._skipNextAnimation = false;\n\n  // If no animations are needed, easy peasy!\n  if (!animEnabled) {\n    this._updateOffsets();\n    item._setTranslate(this._nextLeft, this._nextTop);\n    this._animation.stop();\n    this._finish();\n    return;\n  }\n\n  // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n  if (this._animation.isAnimating()) {\n    this._animation._animation.onfinish = null;\n  }\n\n  // Kick off animation to be started in the next tick.\n  this._isActive = true;\n  this._animOptions.easing = animEasing;\n  this._animOptions.duration = animDuration;\n  this._isInterrupted = isPositioning;\n  addLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n\n/**\n * Stop item's position animation if it is currently animating.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n * @param {Number} [left]\n * @param {Number} [top]\n */\nItemLayout.prototype.stop = function (processCallbackQueue, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n\n  var item = this._item;\n\n  // Cancel animation init.\n  cancelLayoutTick(item._id);\n\n  // Stop animation.\n  if (this._animation.isAnimating()) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(item._element);\n      left = translate.x;\n      top = translate.y;\n    }\n    item._setTranslate(left, top);\n    this._animation.stop();\n  }\n\n  // Remove positioning class.\n  removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n\n  // Reset active state.\n  this._isActive = false;\n\n  // Process callback queue if needed.\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nItemLayout.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var elementStyle = this._item._element.style;\n\n  this.stop(true, 0, 0);\n  this._item._emitter.clear(this._queue);\n  this._animation.destroy();\n\n  elementStyle[transformProp] = '';\n  elementStyle.left = '';\n  elementStyle.top = '';\n\n  this._item = null;\n  this._currentStyles = null;\n  this._targetStyles = null;\n  this._animOptions = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Calculate and update item's current layout offset data.\n *\n * @private\n */\nItemLayout.prototype._updateOffsets = function () {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease;\n\n  this._offsetLeft = release._isActive\n    ? release._containerDiffX\n    : migrate._isActive\n    ? migrate._containerDiffX\n    : 0;\n\n  this._offsetTop = release._isActive\n    ? release._containerDiffY\n    : migrate._isActive\n    ? migrate._containerDiffY\n    : 0;\n\n  this._nextLeft = this._item._left + this._offsetLeft;\n  this._nextTop = this._item._top + this._offsetTop;\n};\n\n/**\n * Finish item layout procedure.\n *\n * @private\n */\nItemLayout.prototype._finish = function () {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease;\n\n  // Update internal translate values.\n  item._tX = this._nextLeft;\n  item._tY = this._nextTop;\n\n  // Mark the item as inactive and remove positioning classes.\n  if (this._isActive) {\n    this._isActive = false;\n    removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n  }\n\n  // Finish up release and migration.\n  if (release._isActive) release.stop();\n  if (migrate._isActive) migrate.stop();\n\n  // Process the callback queue.\n  item._emitter.burst(this._queue, false, item);\n};\n\n/**\n * Prepare item for layout animation.\n *\n * @private\n */\nItemLayout.prototype._setupAnimation = function () {\n  var item = this._item;\n  if (item._tX === undefined || item._tY === undefined) {\n    var translate = getTranslate(item._element);\n    item._tX = translate.x;\n    item._tY = translate.y;\n  }\n};\n\n/**\n * Start layout animation.\n *\n * @private\n */\nItemLayout.prototype._startAnimation = function () {\n  var item = this._item;\n  var settings = item.getGrid()._settings;\n  var isInstant = this._animOptions.duration <= 0;\n\n  // Let's update the offset data and target styles.\n  this._updateOffsets();\n\n  var xDiff = Math.abs(item._left - (item._tX - this._offsetLeft));\n  var yDiff = Math.abs(item._top - (item._tY - this._offsetTop));\n\n  // If there is no need for animation or if the item is already in correct\n  // position (or near it) let's finish the process early.\n  if (isInstant || (xDiff < MIN_ANIMATION_DISTANCE && yDiff < MIN_ANIMATION_DISTANCE)) {\n    if (xDiff || yDiff || this._isInterrupted) {\n      item._setTranslate(this._nextLeft, this._nextTop);\n    }\n    this._animation.stop();\n    this._finish();\n    return;\n  }\n\n  // Set item's positioning class if needed.\n  if (!this._isInterrupted) {\n    addClass(item._element, settings.itemPositioningClass);\n  }\n\n  // Get current/next styles for animation.\n  this._currentStyles[transformProp] = getTranslateString(item._tX, item._tY);\n  this._targetStyles[transformProp] = getTranslateString(this._nextLeft, this._nextTop);\n\n  // Set internal translation values to undefined for the duration of the\n  // animation since they will be changing on each animation frame for the\n  // duration of the animation and tracking them would mean reading the DOM on\n  // each frame, which is pretty darn expensive.\n  item._tX = item._tY = undefined;\n\n  // Start animation.\n  this._animation.start(this._currentStyles, this._targetStyles, this._animOptions);\n};\n\n/**\n * The migrate process handler constructor.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemMigrate(item) {\n  // Private props.\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._container = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the migrate process of an item.\n *\n * @public\n * @param {Grid} targetGrid\n * @param {(HTMLElement|Number|Item)} position\n * @param {HTMLElement} [container]\n */\nItemMigrate.prototype.start = function (targetGrid, position, container) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var isActive = item.isActive();\n  var isVisible = item.isVisible();\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var targetSettings = targetGrid._settings;\n  var targetElement = targetGrid._element;\n  var targetItems = targetGrid._items;\n  var currentIndex = grid._items.indexOf(item);\n  var targetContainer = container || document.body;\n  var targetIndex;\n  var targetItem;\n  var currentContainer;\n  var offsetDiff;\n  var containerDiff;\n  var translate;\n  var translateX;\n  var translateY;\n  var currentVisClass;\n  var nextVisClass;\n\n  // Get target index.\n  if (typeof position === 'number') {\n    targetIndex = normalizeArrayIndex(targetItems, position, 1);\n  } else {\n    targetItem = targetGrid.getItem(position);\n    if (!targetItem) return;\n    targetIndex = targetItems.indexOf(targetItem);\n  }\n\n  // Get current translateX and translateY values if needed.\n  if (item.isPositioning() || this._isActive || item.isReleasing()) {\n    translate = getTranslate(element);\n    translateX = translate.x;\n    translateY = translate.y;\n  }\n\n  // Abort current positioning.\n  if (item.isPositioning()) {\n    item._layout.stop(true, translateX, translateY);\n  }\n\n  // Abort current migration.\n  if (this._isActive) {\n    translateX -= this._containerDiffX;\n    translateY -= this._containerDiffY;\n    this.stop(true, translateX, translateY);\n  }\n\n  // Abort current release.\n  if (item.isReleasing()) {\n    translateX -= item._dragRelease._containerDiffX;\n    translateY -= item._dragRelease._containerDiffY;\n    item._dragRelease.stop(true, translateX, translateY);\n  }\n\n  // Stop current visibility animation.\n  item._visibility.stop(true);\n\n  // Destroy current drag.\n  if (item._drag) item._drag.destroy();\n\n  // Emit beforeSend event.\n  if (grid._hasListeners(EVENT_BEFORE_SEND)) {\n    grid._emit(EVENT_BEFORE_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n\n  // Emit beforeReceive event.\n  if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n    targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n\n  // Update item class.\n  if (settings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, settings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  }\n\n  // Update visibility class.\n  currentVisClass = isVisible ? settings.itemVisibleClass : settings.itemHiddenClass;\n  nextVisClass = isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  }\n\n  // Move item instance from current grid to target grid.\n  grid._items.splice(currentIndex, 1);\n  arrayInsert(targetItems, item, targetIndex);\n\n  // Update item's grid id reference.\n  item._gridId = targetGrid._id;\n\n  // If item is active we need to move the item inside the target container for\n  // the duration of the (potential) animation if it's different than the\n  // current container.\n  if (isActive) {\n    currentContainer = element.parentNode;\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n      if (!translate) {\n        translate = getTranslate(element);\n        translateX = translate.x;\n        translateY = translate.y;\n      }\n      item._setTranslate(translateX + offsetDiff.left, translateY + offsetDiff.top);\n    }\n  }\n  // If item is not active let's just append it to the target grid's element.\n  else {\n    targetElement.appendChild(element);\n  }\n\n  // Update child element's styles to reflect the current visibility state.\n  item._visibility.setStyles(\n    isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles\n  );\n\n  // Get offset diff for the migration data, if the item is active.\n  if (isActive) {\n    containerDiff = getOffsetDiff(targetContainer, targetElement, true);\n  }\n\n  // Update item's cached dimensions.\n  item._refreshDimensions();\n\n  // Reset item's sort data.\n  item._sortData = null;\n\n  // Create new drag handler.\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n  // Setup migration data.\n  if (isActive) {\n    this._isActive = true;\n    this._container = targetContainer;\n    this._containerDiffX = containerDiff.left;\n    this._containerDiffY = containerDiff.top;\n  } else {\n    this._isActive = false;\n    this._container = null;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n  }\n\n  // Emit send event.\n  if (grid._hasListeners(EVENT_SEND)) {\n    grid._emit(EVENT_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n\n  // Emit receive event.\n  if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n    targetGrid._emit(EVENT_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n};\n\n/**\n * End the migrate process of an item. This method can be used to abort an\n * ongoing migrate process (animation) or finish the migrate process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the migration be aborted?\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\nItemMigrate.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var gridElement = grid._element;\n  var translate;\n\n  if (this._container !== gridElement) {\n    if (left === undefined || top === undefined) {\n      if (abort) {\n        translate = getTranslate(element);\n        left = translate.x - this._containerDiffX;\n        top = translate.y - this._containerDiffY;\n      } else {\n        left = item._left;\n        top = item._top;\n      }\n    }\n\n    gridElement.appendChild(element);\n    item._setTranslate(left, top);\n  }\n\n  this._isActive = false;\n  this._container = null;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemMigrate.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Visibility manager for Item instance, handles visibility of an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemVisibility(item) {\n  var isActive = item._isActive;\n  var element = item._element;\n  var childElement = element.children[0];\n  var settings = item.getGrid()._settings;\n\n  if (!childElement) {\n    throw new Error('No valid child element found within item element.');\n  }\n\n  this._item = item;\n  this._isDestroyed = false;\n  this._isHidden = !isActive;\n  this._isHiding = false;\n  this._isShowing = false;\n  this._childElement = childElement;\n  this._currentStyleProps = [];\n  this._animation = new Animator(childElement);\n  this._queue = 'visibility-' + item._id;\n  this._finishShow = this._finishShow.bind(this);\n  this._finishHide = this._finishHide.bind(this);\n\n  element.style.display = isActive ? '' : 'none';\n  addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass);\n  this.setStyles(isActive ? settings.visibleStyles : settings.hiddenStyles);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Show item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype.show = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  // If item is visible call the callback and be done with it.\n  if (!this._isShowing && !this._isHidden) {\n    callback && callback(false, item);\n    return;\n  }\n\n  // If item is showing and does not need to be shown instantly, let's just\n  // push callback to the callback queue and be done with it.\n  if (this._isShowing && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  }\n\n  // If the item is hiding or hidden process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n  if (!this._isShowing) {\n    item._emitter.burst(this._queue, true, item);\n    removeClass(element, settings.itemHiddenClass);\n    addClass(element, settings.itemVisibleClass);\n    if (!this._isHiding) element.style.display = '';\n  }\n\n  // Push callback to the callback queue.\n  callback && item._emitter.on(this._queue, callback);\n\n  // Update visibility states.\n  this._isShowing = true;\n  this._isHiding = this._isHidden = false;\n\n  // Finally let's start show animation.\n  this._startAnimation(true, instant, this._finishShow);\n};\n\n/**\n * Hide item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype.hide = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  // If item is already hidden call the callback and be done with it.\n  if (!this._isHiding && this._isHidden) {\n    callback && callback(false, item);\n    return;\n  }\n\n  // If item is hiding and does not need to be hidden instantly, let's just\n  // push callback to the callback queue and be done with it.\n  if (this._isHiding && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  }\n\n  // If the item is showing or visible process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n  if (!this._isHiding) {\n    item._emitter.burst(this._queue, true, item);\n    addClass(element, settings.itemHiddenClass);\n    removeClass(element, settings.itemVisibleClass);\n  }\n\n  // Push callback to the callback queue.\n  callback && item._emitter.on(this._queue, callback);\n\n  // Update visibility states.\n  this._isHidden = this._isHiding = true;\n  this._isShowing = false;\n\n  // Finally let's start hide animation.\n  this._startAnimation(false, instant, this._finishHide);\n};\n\n/**\n * Stop current hiding/showing process.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n */\nItemVisibility.prototype.stop = function (processCallbackQueue) {\n  if (this._isDestroyed) return;\n  if (!this._isHiding && !this._isShowing) return;\n\n  var item = this._item;\n\n  cancelVisibilityTick(item._id);\n  this._animation.stop();\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n\n/**\n * Reset all existing visibility styles and apply new visibility styles to the\n * visibility element. This method should be used to set styles when there is a\n * chance that the current style properties differ from the new ones (basically\n * on init and on migrations).\n *\n * @public\n * @param {Object} styles\n */\nItemVisibility.prototype.setStyles = function (styles) {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n  this._removeCurrentStyles();\n  for (var prop in styles) {\n    currentStyleProps.push(prop);\n    childElement.style[prop] = styles[prop];\n  }\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nItemVisibility.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  this.stop(true);\n  item._emitter.clear(this._queue);\n  this._animation.destroy();\n  this._removeCurrentStyles();\n  removeClass(element, settings.itemVisibleClass);\n  removeClass(element, settings.itemHiddenClass);\n  element.style.display = '';\n\n  // Reset state.\n  this._isHiding = this._isShowing = false;\n  this._isDestroyed = this._isHidden = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Start visibility animation.\n *\n * @private\n * @param {Boolean} toVisible\n * @param {Boolean} [instant]\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype._startAnimation = function (toVisible, instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var animation = this._animation;\n  var childElement = this._childElement;\n  var settings = item.getGrid()._settings;\n  var targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;\n  var duration = toVisible ? settings.showDuration : settings.hideDuration;\n  var easing = toVisible ? settings.showEasing : settings.hideEasing;\n  var isInstant = instant || duration <= 0;\n  var currentStyles;\n\n  // No target styles? Let's quit early.\n  if (!targetStyles) {\n    onFinish && onFinish();\n    return;\n  }\n\n  // Cancel queued visibility tick.\n  cancelVisibilityTick(item._id);\n\n  // If we need to apply the styles instantly without animation.\n  if (isInstant) {\n    setStyles(childElement, targetStyles);\n    animation.stop();\n    onFinish && onFinish();\n    return;\n  }\n\n  // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n  if (animation.isAnimating()) {\n    animation._animation.onfinish = null;\n  }\n\n  // Start the animation in the next tick (to avoid layout thrashing).\n  addVisibilityTick(\n    item._id,\n    function () {\n      currentStyles = getCurrentStyles(childElement, targetStyles);\n    },\n    function () {\n      animation.start(currentStyles, targetStyles, {\n        duration: duration,\n        easing: easing,\n        onFinish: onFinish,\n      });\n    }\n  );\n};\n\n/**\n * Finish show procedure.\n *\n * @private\n */\nItemVisibility.prototype._finishShow = function () {\n  if (this._isHidden) return;\n  this._isShowing = false;\n  this._item._emitter.burst(this._queue, false, this._item);\n};\n\n/**\n * Finish hide procedure.\n *\n * @private\n */\nItemVisibility.prototype._finishHide = function () {\n  if (!this._isHidden) return;\n  var item = this._item;\n  this._isHiding = false;\n  item._layout.stop(true, 0, 0);\n  item._element.style.display = 'none';\n  item._emitter.burst(this._queue, false, item);\n};\n\n/**\n * Remove currently applied visibility related inline style properties.\n *\n * @private\n */\nItemVisibility.prototype._removeCurrentStyles = function () {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n\n  for (var i = 0; i < currentStyleProps.length; i++) {\n    childElement.style[currentStyleProps[i]] = '';\n  }\n\n  currentStyleProps.length = 0;\n};\n\nvar id = 0;\n\n/**\n * Returns a unique numeric id (increments a base value on every call).\n * @returns {Number}\n */\nfunction createUid() {\n  return ++id;\n}\n\n/**\n * Creates a new Item instance for a Grid instance.\n *\n * @class\n * @param {Grid} grid\n * @param {HTMLElement} element\n * @param {Boolean} [isActive]\n */\nfunction Item(grid, element, isActive) {\n  var settings = grid._settings;\n\n  // Store item/element pair to a map (for faster item querying by element).\n  if (ITEM_ELEMENT_MAP) {\n    if (ITEM_ELEMENT_MAP.has(element)) {\n      throw new Error('You can only create one Muuri Item per element!');\n    } else {\n      ITEM_ELEMENT_MAP.set(element, this);\n    }\n  }\n\n  this._id = createUid();\n  this._gridId = grid._id;\n  this._element = element;\n  this._isDestroyed = false;\n  this._left = 0;\n  this._top = 0;\n  this._width = 0;\n  this._height = 0;\n  this._marginLeft = 0;\n  this._marginRight = 0;\n  this._marginTop = 0;\n  this._marginBottom = 0;\n  this._tX = undefined;\n  this._tY = undefined;\n  this._sortData = null;\n  this._emitter = new Emitter();\n\n  // If the provided item element is not a direct child of the grid container\n  // element, append it to the grid container. Note, we are indeed reading the\n  // DOM here but it's a property that does not cause reflowing.\n  if (element.parentNode !== grid._element) {\n    grid._element.appendChild(element);\n  }\n\n  // Set item class.\n  addClass(element, settings.itemClass);\n\n  // If isActive is not defined, let's try to auto-detect it. Note, we are\n  // indeed reading the DOM here but it's a property that does not cause\n  // reflowing.\n  if (typeof isActive !== 'boolean') {\n    isActive = getStyle(element, 'display') !== 'none';\n  }\n\n  // Set up active state (defines if the item is considered part of the layout\n  // or not).\n  this._isActive = isActive;\n\n  // Setup visibility handler.\n  this._visibility = new ItemVisibility(this);\n\n  // Set up layout handler.\n  this._layout = new ItemLayout(this);\n\n  // Set up migration handler data.\n  this._migrate = new ItemMigrate(this);\n\n  // Set up drag handler.\n  this._drag = settings.dragEnabled ? new ItemDrag(this) : null;\n\n  // Set up release handler. Note that although this is fully linked to dragging\n  // this still needs to be always instantiated to handle migration scenarios\n  // correctly.\n  this._dragRelease = new ItemDragRelease(this);\n\n  // Set up drag placeholder handler. Note that although this is fully linked to\n  // dragging this still needs to be always instantiated to handle migration\n  // scenarios correctly.\n  this._dragPlaceholder = new ItemDragPlaceholder(this);\n\n  // Note! You must call the following methods before you start using the\n  // instance. They are deliberately not called in the end as it would cause\n  // potentially a massive amount of reflows if multiple items were instantiated\n  // in a loop.\n  // this._refreshDimensions();\n  // this._refreshSortData();\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Get the instance grid reference.\n *\n * @public\n * @returns {Grid}\n */\nItem.prototype.getGrid = function () {\n  return GRID_INSTANCES[this._gridId];\n};\n\n/**\n * Get the instance element.\n *\n * @public\n * @returns {HTMLElement}\n */\nItem.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Get instance element's cached width.\n *\n * @public\n * @returns {Number}\n */\nItem.prototype.getWidth = function () {\n  return this._width;\n};\n\n/**\n * Get instance element's cached height.\n *\n * @public\n * @returns {Number}\n */\nItem.prototype.getHeight = function () {\n  return this._height;\n};\n\n/**\n * Get instance element's cached margins.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left, right, top and bottom properties\n *     which indicate the item element's cached margins.\n */\nItem.prototype.getMargin = function () {\n  return {\n    left: this._marginLeft,\n    right: this._marginRight,\n    top: this._marginTop,\n    bottom: this._marginBottom,\n  };\n};\n\n/**\n * Get instance element's cached position.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left and top properties which indicate the\n *     item element's cached position in the grid.\n */\nItem.prototype.getPosition = function () {\n  return {\n    left: this._left,\n    top: this._top,\n  };\n};\n\n/**\n * Is the item active?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isActive = function () {\n  return this._isActive;\n};\n\n/**\n * Is the item visible?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isVisible = function () {\n  return !!this._visibility && !this._visibility._isHidden;\n};\n\n/**\n * Is the item being animated to visible?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isShowing = function () {\n  return !!(this._visibility && this._visibility._isShowing);\n};\n\n/**\n * Is the item being animated to hidden?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isHiding = function () {\n  return !!(this._visibility && this._visibility._isHiding);\n};\n\n/**\n * Is the item positioning?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isPositioning = function () {\n  return !!(this._layout && this._layout._isActive);\n};\n\n/**\n * Is the item being dragged (or queued for dragging)?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isDragging = function () {\n  return !!(this._drag && this._drag._isActive);\n};\n\n/**\n * Is the item being released?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isReleasing = function () {\n  return !!(this._dragRelease && this._dragRelease._isActive);\n};\n\n/**\n * Is the item destroyed?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isDestroyed = function () {\n  return this._isDestroyed;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Recalculate item's dimensions.\n *\n * @private\n * @param {Boolean} [force=false]\n */\nItem.prototype._refreshDimensions = function (force) {\n  if (this._isDestroyed) return;\n  if (force !== true && this._visibility._isHidden) return;\n\n  var element = this._element;\n  var dragPlaceholder = this._dragPlaceholder;\n  var rect = element.getBoundingClientRect();\n\n  // Calculate width and height.\n  this._width = rect.width;\n  this._height = rect.height;\n\n  // Calculate margins (ignore negative margins).\n  this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));\n  this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));\n  this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));\n  this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom'));\n\n  // Keep drag placeholder's dimensions synced with the item's.\n  if (dragPlaceholder) dragPlaceholder.updateDimensions();\n};\n\n/**\n * Fetch and store item's sort data.\n *\n * @private\n */\nItem.prototype._refreshSortData = function () {\n  if (this._isDestroyed) return;\n\n  var data = (this._sortData = {});\n  var getters = this.getGrid()._settings.sortData;\n  var prop;\n\n  for (prop in getters) {\n    data[prop] = getters[prop](this, this._element);\n  }\n};\n\n/**\n * Add item to layout.\n *\n * @private\n */\nItem.prototype._addToLayout = function (left, top) {\n  if (this._isActive === true) return;\n  this._isActive = true;\n  this._left = left || 0;\n  this._top = top || 0;\n};\n\n/**\n * Remove item from layout.\n *\n * @private\n */\nItem.prototype._removeFromLayout = function () {\n  if (this._isActive === false) return;\n  this._isActive = false;\n  this._left = 0;\n  this._top = 0;\n};\n\n/**\n * Check if the layout procedure can be skipped for the item.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\nItem.prototype._canSkipLayout = function (left, top) {\n  return (\n    this._left === left &&\n    this._top === top &&\n    !this._migrate._isActive &&\n    !this._layout._skipNextAnimation &&\n    !this._dragRelease.isJustReleased()\n  );\n};\n\n/**\n * Set the provided left and top arguments as the item element's translate\n * values in the DOM. This method keeps track of the currently applied\n * translate values and skips the update operation if the provided values are\n * identical to the currently applied values. Returns `false` if there was no\n * need for update and `true` if the translate value was updated.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\nItem.prototype._setTranslate = function (left, top) {\n  if (this._tX === left && this._tY === top) return false;\n  this._tX = left;\n  this._tY = top;\n  this._element.style[transformProp] = getTranslateString(left, top);\n  return true;\n};\n\n/**\n * Destroy item instance.\n *\n * @private\n * @param {Boolean} [removeElement=false]\n */\nItem.prototype._destroy = function (removeElement) {\n  if (this._isDestroyed) return;\n\n  var element = this._element;\n  var grid = this.getGrid();\n  var settings = grid._settings;\n\n  // Destroy handlers.\n  this._dragPlaceholder.destroy();\n  this._dragRelease.destroy();\n  this._migrate.destroy();\n  this._layout.destroy();\n  this._visibility.destroy();\n  if (this._drag) this._drag.destroy();\n\n  // Destroy emitter.\n  this._emitter.destroy();\n\n  // Remove item class.\n  removeClass(element, settings.itemClass);\n\n  // Remove element from DOM.\n  if (removeElement) element.parentNode.removeChild(element);\n\n  // Remove item/element pair from map.\n  if (ITEM_ELEMENT_MAP) ITEM_ELEMENT_MAP.delete(element);\n\n  // Reset state.\n  this._isActive = false;\n  this._isDestroyed = true;\n};\n\nfunction createPackerProcessor(isWorker) {\n  var FILL_GAPS = 1;\n  var HORIZONTAL = 2;\n  var ALIGN_RIGHT = 4;\n  var ALIGN_BOTTOM = 8;\n  var ROUNDING = 16;\n\n  var EPS = 0.001;\n  var MIN_SLOT_SIZE = 0.5;\n\n  // Rounds number first to three decimal precision and then floors the result\n  // to two decimal precision.\n  // Math.floor(Math.round(number * 1000) / 10) / 100\n  function roundNumber(number) {\n    return ((((number * 1000 + 0.5) << 0) / 10) << 0) / 100;\n  }\n\n  /**\n   * @class\n   */\n  function PackerProcessor() {\n    this.currentRects = [];\n    this.nextRects = [];\n    this.rectTarget = {};\n    this.rectStore = [];\n    this.slotSizes = [];\n    this.rectId = 0;\n    this.slotIndex = -1;\n    this.slotData = { left: 0, top: 0, width: 0, height: 0 };\n    this.sortRectsLeftTop = this.sortRectsLeftTop.bind(this);\n    this.sortRectsTopLeft = this.sortRectsTopLeft.bind(this);\n  }\n\n  /**\n   * Takes a layout object as an argument and computes positions (slots) for the\n   * layout items. Also computes the final width and height of the layout. The\n   * provided layout object's slots array is mutated as well as the width and\n   * height properties.\n   *\n   * @param {Object} layout\n   * @param {Number} layout.width\n   *   - The start (current) width of the layout in pixels.\n   * @param {Number} layout.height\n   *   - The start (current) height of the layout in pixels.\n   * @param {(Item[]|Number[])} layout.items\n   *   - List of Muuri.Item instances or a list of item dimensions\n   *     (e.g [ item1Width, item1Height, item2Width, item2Height, ... ]).\n   * @param {(Array|Float32Array)} layout.slots\n   *   - An Array/Float32Array instance which's length should equal to\n   *     the amount of items times two. The position (width and height) of each\n   *     item will be written into this array.\n   * @param {Number} settings\n   *   - The layout's settings as bitmasks.\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.computeLayout = function (layout, settings) {\n    var items = layout.items;\n    var slots = layout.slots;\n    var fillGaps = !!(settings & FILL_GAPS);\n    var horizontal = !!(settings & HORIZONTAL);\n    var alignRight = !!(settings & ALIGN_RIGHT);\n    var alignBottom = !!(settings & ALIGN_BOTTOM);\n    var rounding = !!(settings & ROUNDING);\n    var isPreProcessed = typeof items[0] === 'number';\n    var i, bump, item, slotWidth, slotHeight, slot;\n\n    // No need to go further if items do not exist.\n    if (!items.length) return layout;\n\n    // Compute slots for the items.\n    bump = isPreProcessed ? 2 : 1;\n    for (i = 0; i < items.length; i += bump) {\n      // If items are pre-processed it means that items array contains only\n      // the raw dimensions of the items. Otherwise we assume it is an array\n      // of normal Muuri items.\n      if (isPreProcessed) {\n        slotWidth = items[i];\n        slotHeight = items[i + 1];\n      } else {\n        item = items[i];\n        slotWidth = item._width + item._marginLeft + item._marginRight;\n        slotHeight = item._height + item._marginTop + item._marginBottom;\n      }\n\n      // If rounding is enabled let's round the item's width and height to\n      // make the layout algorithm a bit more stable. This has a performance\n      // cost so don't use this if not necessary.\n      if (rounding) {\n        slotWidth = roundNumber(slotWidth);\n        slotHeight = roundNumber(slotHeight);\n      }\n\n      // Get slot data.\n      slot = this.computeNextSlot(layout, slotWidth, slotHeight, fillGaps, horizontal);\n\n      // Update layout width/height.\n      if (horizontal) {\n        if (slot.left + slot.width > layout.width) {\n          layout.width = slot.left + slot.width;\n        }\n      } else {\n        if (slot.top + slot.height > layout.height) {\n          layout.height = slot.top + slot.height;\n        }\n      }\n\n      // Add item slot data to layout slots.\n      slots[++this.slotIndex] = slot.left;\n      slots[++this.slotIndex] = slot.top;\n\n      // Store the size too (for later usage) if needed.\n      if (alignRight || alignBottom) {\n        this.slotSizes.push(slot.width, slot.height);\n      }\n    }\n\n    // If the alignment is set to right we need to adjust the results.\n    if (alignRight) {\n      for (i = 0; i < slots.length; i += 2) {\n        slots[i] = layout.width - (slots[i] + this.slotSizes[i]);\n      }\n    }\n\n    // If the alignment is set to bottom we need to adjust the results.\n    if (alignBottom) {\n      for (i = 1; i < slots.length; i += 2) {\n        slots[i] = layout.height - (slots[i] + this.slotSizes[i]);\n      }\n    }\n\n    // Reset stuff.\n    this.slotSizes.length = 0;\n    this.currentRects.length = 0;\n    this.nextRects.length = 0;\n    this.rectStore.length = 0;\n    this.rectId = 0;\n    this.slotIndex = -1;\n\n    return layout;\n  };\n\n  /**\n   * Calculate next slot in the layout. Returns a slot object with position and\n   * dimensions data. The returned object is reused between calls.\n   *\n   * @param {Object} layout\n   * @param {Number} slotWidth\n   * @param {Number} slotHeight\n   * @param {Boolean} fillGaps\n   * @param {Boolean} horizontal\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.computeNextSlot = function (\n    layout,\n    slotWidth,\n    slotHeight,\n    fillGaps,\n    horizontal\n  ) {\n    var slot = this.slotData;\n    var currentRects = this.currentRects;\n    var nextRects = this.nextRects;\n    var ignoreCurrentRects = false;\n    var rect;\n    var rectId;\n    var shards;\n    var i;\n    var j;\n\n    // Reset new slots.\n    nextRects.length = 0;\n\n    // Set item slot initial data.\n    slot.left = null;\n    slot.top = null;\n    slot.width = slotWidth;\n    slot.height = slotHeight;\n\n    // Try to find position for the slot from the existing free spaces in the\n    // layout.\n    for (i = 0; i < currentRects.length; i++) {\n      rectId = currentRects[i];\n      if (!rectId) continue;\n      rect = this.getRect(rectId);\n      if (slot.width <= rect.width + EPS && slot.height <= rect.height + EPS) {\n        slot.left = rect.left;\n        slot.top = rect.top;\n        break;\n      }\n    }\n\n    // If no position was found for the slot let's position the slot to\n    // the bottom left (in vertical mode) or top right (in horizontal mode) of\n    // the layout.\n    if (slot.left === null) {\n      if (horizontal) {\n        slot.left = layout.width;\n        slot.top = 0;\n      } else {\n        slot.left = 0;\n        slot.top = layout.height;\n      }\n\n      // If gaps don't need filling let's throw away all the current free spaces\n      // (currentRects).\n      if (!fillGaps) {\n        ignoreCurrentRects = true;\n      }\n    }\n\n    // In vertical mode, if the slot's bottom overlaps the layout's bottom.\n    if (!horizontal && slot.top + slot.height > layout.height + EPS) {\n      // If slot is not aligned to the left edge, create a new free space to the\n      // left of the slot.\n      if (slot.left > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(0, layout.height, slot.left, Infinity));\n      }\n\n      // If slot is not aligned to the right edge, create a new free space to\n      // the right of the slot.\n      if (slot.left + slot.width < layout.width - MIN_SLOT_SIZE) {\n        nextRects.push(\n          this.addRect(\n            slot.left + slot.width,\n            layout.height,\n            layout.width - slot.left - slot.width,\n            Infinity\n          )\n        );\n      }\n\n      // Update layout height.\n      layout.height = slot.top + slot.height;\n    }\n\n    // In horizontal mode, if the slot's right overlaps the layout's right edge.\n    if (horizontal && slot.left + slot.width > layout.width + EPS) {\n      // If slot is not aligned to the top, create a new free space above the\n      // slot.\n      if (slot.top > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(layout.width, 0, Infinity, slot.top));\n      }\n\n      // If slot is not aligned to the bottom, create a new free space below\n      // the slot.\n      if (slot.top + slot.height < layout.height - MIN_SLOT_SIZE) {\n        nextRects.push(\n          this.addRect(\n            layout.width,\n            slot.top + slot.height,\n            Infinity,\n            layout.height - slot.top - slot.height\n          )\n        );\n      }\n\n      // Update layout width.\n      layout.width = slot.left + slot.width;\n    }\n\n    // Clean up the current free spaces making sure none of them overlap with\n    // the slot. Split all overlapping free spaces into smaller shards that do\n    // not overlap with the slot.\n    if (!ignoreCurrentRects) {\n      if (fillGaps) i = 0;\n      for (; i < currentRects.length; i++) {\n        rectId = currentRects[i];\n        if (!rectId) continue;\n        rect = this.getRect(rectId);\n        shards = this.splitRect(rect, slot);\n        for (j = 0; j < shards.length; j++) {\n          rectId = shards[j];\n          rect = this.getRect(rectId);\n          // Make sure that the free space is within the boundaries of the\n          // layout. This routine is critical to the algorithm as it makes sure\n          // that there are no leftover spaces with infinite height/width.\n          // It's also essential that we don't compare values absolutely to each\n          // other but leave a little headroom (EPSILON) to get rid of false\n          // positives.\n          if (\n            horizontal ? rect.left + EPS < layout.width - EPS : rect.top + EPS < layout.height - EPS\n          ) {\n            nextRects.push(rectId);\n          }\n        }\n      }\n    }\n\n    // Sanitize and sort all the new free spaces that will be used in the next\n    // iteration. This procedure is critical to make the bin-packing algorithm\n    // work. The free spaces have to be in correct order in the beginning of the\n    // next iteration.\n    if (nextRects.length > 1) {\n      this.purgeRects(nextRects).sort(horizontal ? this.sortRectsLeftTop : this.sortRectsTopLeft);\n    }\n\n    // Finally we need to make sure that `this.currentRects` points to\n    // `nextRects` array as that is used in the next iteration's beginning when\n    // we try to find a space for the next slot.\n    this.currentRects = nextRects;\n    this.nextRects = currentRects;\n\n    return slot;\n  };\n\n  /**\n   * Add a new rectangle to the rectangle store. Returns the id of the new\n   * rectangle.\n   *\n   * @param {Number} left\n   * @param {Number} top\n   * @param {Number} width\n   * @param {Number} height\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.addRect = function (left, top, width, height) {\n    var rectId = ++this.rectId;\n    this.rectStore[rectId] = left || 0;\n    this.rectStore[++this.rectId] = top || 0;\n    this.rectStore[++this.rectId] = width || 0;\n    this.rectStore[++this.rectId] = height || 0;\n    return rectId;\n  };\n\n  /**\n   * Get rectangle data from the rectangle store by id. Optionally you can\n   * provide a target object where the rectangle data will be written in. By\n   * default an internal object is reused as a target object.\n   *\n   * @param {Number} id\n   * @param {Object} [target]\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.getRect = function (id, target) {\n    if (!target) target = this.rectTarget;\n    target.left = this.rectStore[id] || 0;\n    target.top = this.rectStore[++id] || 0;\n    target.width = this.rectStore[++id] || 0;\n    target.height = this.rectStore[++id] || 0;\n    return target;\n  };\n\n  /**\n   * Punch a hole into a rectangle and return the shards (1-4).\n   *\n   * @param {Object} rect\n   * @param {Object} hole\n   * @returns {Number[]}\n   */\n  PackerProcessor.prototype.splitRect = (function () {\n    var shards = [];\n    var width = 0;\n    var height = 0;\n    return function (rect, hole) {\n      // Reset old shards.\n      shards.length = 0;\n\n      // If the slot does not overlap with the hole add slot to the return data\n      // as is. Note that in this case we are eager to keep the slot as is if\n      // possible so we use the EPSILON in favour of that logic.\n      if (\n        rect.left + rect.width <= hole.left + EPS ||\n        hole.left + hole.width <= rect.left + EPS ||\n        rect.top + rect.height <= hole.top + EPS ||\n        hole.top + hole.height <= rect.top + EPS\n      ) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, rect.height));\n        return shards;\n      }\n\n      // Left split.\n      width = hole.left - rect.left;\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, width, rect.height));\n      }\n\n      // Right split.\n      width = rect.left + rect.width - (hole.left + hole.width);\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(hole.left + hole.width, rect.top, width, rect.height));\n      }\n\n      // Top split.\n      height = hole.top - rect.top;\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, height));\n      }\n\n      // Bottom split.\n      height = rect.top + rect.height - (hole.top + hole.height);\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, hole.top + hole.height, rect.width, height));\n      }\n\n      return shards;\n    };\n  })();\n\n  /**\n   * Check if a rectangle is fully within another rectangle.\n   *\n   * @param {Object} a\n   * @param {Object} b\n   * @returns {Boolean}\n   */\n  PackerProcessor.prototype.isRectAWithinRectB = function (a, b) {\n    return (\n      a.left + EPS >= b.left &&\n      a.top + EPS >= b.top &&\n      a.left + a.width - EPS <= b.left + b.width &&\n      a.top + a.height - EPS <= b.top + b.height\n    );\n  };\n\n  /**\n   * Loops through an array of rectangle ids and resets all that are fully\n   * within another rectangle in the array. Resetting in this case means that\n   * the rectangle id value is replaced with zero.\n   *\n   * @param {Number[]} rectIds\n   * @returns {Number[]}\n   */\n  PackerProcessor.prototype.purgeRects = (function () {\n    var rectA = {};\n    var rectB = {};\n    return function (rectIds) {\n      var i = rectIds.length;\n      var j;\n\n      while (i--) {\n        j = rectIds.length;\n        if (!rectIds[i]) continue;\n        this.getRect(rectIds[i], rectA);\n        while (j--) {\n          if (!rectIds[j] || i === j) continue;\n          this.getRect(rectIds[j], rectB);\n          if (this.isRectAWithinRectB(rectA, rectB)) {\n            rectIds[i] = 0;\n            break;\n          }\n        }\n      }\n\n      return rectIds;\n    };\n  })();\n\n  /**\n   * Sort rectangles with top-left gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.sortRectsTopLeft = (function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n\n      return rectA.top < rectB.top && rectA.top + EPS < rectB.top\n        ? -1\n        : rectA.top > rectB.top && rectA.top - EPS > rectB.top\n        ? 1\n        : rectA.left < rectB.left && rectA.left + EPS < rectB.left\n        ? -1\n        : rectA.left > rectB.left && rectA.left - EPS > rectB.left\n        ? 1\n        : 0;\n    };\n  })();\n\n  /**\n   * Sort rectangles with left-top gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.sortRectsLeftTop = (function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n      return rectA.left < rectB.left && rectA.left + EPS < rectB.left\n        ? -1\n        : rectA.left > rectB.left && rectA.left - EPS < rectB.left\n        ? 1\n        : rectA.top < rectB.top && rectA.top + EPS < rectB.top\n        ? -1\n        : rectA.top > rectB.top && rectA.top - EPS > rectB.top\n        ? 1\n        : 0;\n    };\n  })();\n\n  if (isWorker) {\n    var PACKET_INDEX_WIDTH = 1;\n    var PACKET_INDEX_HEIGHT = 2;\n    var PACKET_INDEX_OPTIONS = 3;\n    var PACKET_HEADER_SLOTS = 4;\n    var processor = new PackerProcessor();\n\n    self.onmessage = function (msg) {\n      var data = new Float32Array(msg.data);\n      var items = data.subarray(PACKET_HEADER_SLOTS, data.length);\n      var slots = new Float32Array(items.length);\n      var settings = data[PACKET_INDEX_OPTIONS];\n      var layout = {\n        items: items,\n        slots: slots,\n        width: data[PACKET_INDEX_WIDTH],\n        height: data[PACKET_INDEX_HEIGHT],\n      };\n\n      // Compute the layout (width / height / slots).\n      processor.computeLayout(layout, settings);\n\n      // Copy layout data to the return data.\n      data[PACKET_INDEX_WIDTH] = layout.width;\n      data[PACKET_INDEX_HEIGHT] = layout.height;\n      data.set(layout.slots, PACKET_HEADER_SLOTS);\n\n      // Send layout back to the main thread.\n      postMessage(data.buffer, [data.buffer]);\n    };\n  }\n\n  return PackerProcessor;\n}\n\nvar PackerProcessor = createPackerProcessor();\n\n//\n// WORKER UTILS\n//\n\nvar blobUrl = null;\nvar activeWorkers = [];\n\nfunction createWorkerProcessors(amount, onmessage) {\n  var workers = [];\n\n  if (amount > 0) {\n    if (!blobUrl) {\n      blobUrl = URL.createObjectURL(\n        new Blob(['(' + createPackerProcessor.toString() + ')(true)'], {\n          type: 'application/javascript',\n        })\n      );\n    }\n\n    for (var i = 0, worker; i < amount; i++) {\n      worker = new Worker(blobUrl);\n      if (onmessage) worker.onmessage = onmessage;\n      workers.push(worker);\n      activeWorkers.push(worker);\n    }\n  }\n\n  return workers;\n}\n\nfunction destroyWorkerProcessors(workers) {\n  var worker;\n  var index;\n\n  for (var i = 0; i < workers.length; i++) {\n    worker = workers[i];\n    worker.onmessage = null;\n    worker.onerror = null;\n    worker.onmessageerror = null;\n    worker.terminate();\n\n    index = activeWorkers.indexOf(worker);\n    if (index > -1) activeWorkers.splice(index, 1);\n  }\n\n  if (blobUrl && !activeWorkers.length) {\n    URL.revokeObjectURL(blobUrl);\n    blobUrl = null;\n  }\n}\n\nfunction isWorkerProcessorsSupported() {\n  return !!(window.Worker && window.URL && window.Blob);\n}\n\nvar FILL_GAPS = 1;\nvar HORIZONTAL = 2;\nvar ALIGN_RIGHT = 4;\nvar ALIGN_BOTTOM = 8;\nvar ROUNDING = 16;\nvar PACKET_INDEX_ID = 0;\nvar PACKET_INDEX_WIDTH = 1;\nvar PACKET_INDEX_HEIGHT = 2;\nvar PACKET_INDEX_OPTIONS = 3;\nvar PACKET_HEADER_SLOTS = 4;\n\n/**\n * @class\n * @param {Number} [numWorkers=0]\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps=false]\n * @param {Boolean} [options.horizontal=false]\n * @param {Boolean} [options.alignRight=false]\n * @param {Boolean} [options.alignBottom=false]\n * @param {Boolean} [options.rounding=false]\n */\nfunction Packer(numWorkers, options) {\n  this._options = 0;\n  this._processor = null;\n  this._layoutQueue = [];\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n  this._workers = [];\n  this._onWorkerMessage = this._onWorkerMessage.bind(this);\n\n  // Set initial options.\n  this.setOptions(options);\n\n  // Init the worker(s) or the processor if workers can't be used.\n  numWorkers = typeof numWorkers === 'number' ? Math.max(0, numWorkers) : 0;\n  if (numWorkers && isWorkerProcessorsSupported()) {\n    try {\n      this._workers = createWorkerProcessors(numWorkers, this._onWorkerMessage);\n    } catch (e) {\n      this._processor = new PackerProcessor();\n    }\n  } else {\n    this._processor = new PackerProcessor();\n  }\n}\n\nPacker.prototype._sendToWorker = function () {\n  if (!this._layoutQueue.length || !this._workers.length) return;\n\n  var layoutId = this._layoutQueue.shift();\n  var worker = this._workers.pop();\n  var data = this._layoutWorkerData[layoutId];\n\n  delete this._layoutWorkerData[layoutId];\n  this._layoutWorkers[layoutId] = worker;\n  worker.postMessage(data.buffer, [data.buffer]);\n};\n\nPacker.prototype._onWorkerMessage = function (msg) {\n  var data = new Float32Array(msg.data);\n  var layoutId = data[PACKET_INDEX_ID];\n  var layout = this._layouts[layoutId];\n  var callback = this._layoutCallbacks[layoutId];\n  var worker = this._layoutWorkers[layoutId];\n\n  if (layout) delete this._layouts[layoutId];\n  if (callback) delete this._layoutCallbacks[layoutId];\n  if (worker) delete this._layoutWorkers[layoutId];\n\n  if (layout && callback) {\n    layout.width = data[PACKET_INDEX_WIDTH];\n    layout.height = data[PACKET_INDEX_HEIGHT];\n    layout.slots = data.subarray(PACKET_HEADER_SLOTS, data.length);\n    this._finalizeLayout(layout);\n    callback(layout);\n  }\n\n  if (worker) {\n    this._workers.push(worker);\n    this._sendToWorker();\n  }\n};\n\nPacker.prototype._finalizeLayout = function (layout) {\n  var grid = layout._grid;\n  var isHorizontal = layout._settings & HORIZONTAL;\n  var isBorderBox = grid._boxSizing === 'border-box';\n\n  delete layout._grid;\n  delete layout._settings;\n\n  layout.styles = {};\n\n  if (isHorizontal) {\n    layout.styles.width =\n      (isBorderBox ? layout.width + grid._borderLeft + grid._borderRight : layout.width) + 'px';\n  } else {\n    layout.styles.height =\n      (isBorderBox ? layout.height + grid._borderTop + grid._borderBottom : layout.height) + 'px';\n  }\n\n  return layout;\n};\n\n/**\n * @public\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps]\n * @param {Boolean} [options.horizontal]\n * @param {Boolean} [options.alignRight]\n * @param {Boolean} [options.alignBottom]\n * @param {Boolean} [options.rounding]\n */\nPacker.prototype.setOptions = function (options) {\n  if (!options) return;\n\n  var fillGaps;\n  if (typeof options.fillGaps === 'boolean') {\n    fillGaps = options.fillGaps ? FILL_GAPS : 0;\n  } else {\n    fillGaps = this._options & FILL_GAPS;\n  }\n\n  var horizontal;\n  if (typeof options.horizontal === 'boolean') {\n    horizontal = options.horizontal ? HORIZONTAL : 0;\n  } else {\n    horizontal = this._options & HORIZONTAL;\n  }\n\n  var alignRight;\n  if (typeof options.alignRight === 'boolean') {\n    alignRight = options.alignRight ? ALIGN_RIGHT : 0;\n  } else {\n    alignRight = this._options & ALIGN_RIGHT;\n  }\n\n  var alignBottom;\n  if (typeof options.alignBottom === 'boolean') {\n    alignBottom = options.alignBottom ? ALIGN_BOTTOM : 0;\n  } else {\n    alignBottom = this._options & ALIGN_BOTTOM;\n  }\n\n  var rounding;\n  if (typeof options.rounding === 'boolean') {\n    rounding = options.rounding ? ROUNDING : 0;\n  } else {\n    rounding = this._options & ROUNDING;\n  }\n\n  this._options = fillGaps | horizontal | alignRight | alignBottom | rounding;\n};\n\n/**\n * @public\n * @param {Grid} grid\n * @param {Number} layoutId\n * @param {Item[]} items\n * @param {Number} width\n * @param {Number} height\n * @param {Function} callback\n * @returns {?Function}\n */\nPacker.prototype.createLayout = function (grid, layoutId, items, width, height, callback) {\n  if (this._layouts[layoutId]) {\n    throw new Error('A layout with the provided id is currently being processed.');\n  }\n\n  var horizontal = this._options & HORIZONTAL;\n  var layout = {\n    id: layoutId,\n    items: items,\n    slots: null,\n    width: horizontal ? 0 : width,\n    height: !horizontal ? 0 : height,\n    // Temporary data, which will be removed before sending the layout data\n    // outside of Packer's context.\n    _grid: grid,\n    _settings: this._options,\n  };\n\n  // If there are no items let's call the callback immediately.\n  if (!items.length) {\n    layout.slots = [];\n    this._finalizeLayout(layout);\n    callback(layout);\n    return;\n  }\n\n  // Create layout synchronously if needed.\n  if (this._processor) {\n    layout.slots = window.Float32Array\n      ? new Float32Array(items.length * 2)\n      : new Array(items.length * 2);\n    this._processor.computeLayout(layout, layout._settings);\n    this._finalizeLayout(layout);\n    callback(layout);\n    return;\n  }\n\n  // Worker data.\n  var data = new Float32Array(PACKET_HEADER_SLOTS + items.length * 2);\n\n  // Worker data header.\n  data[PACKET_INDEX_ID] = layoutId;\n  data[PACKET_INDEX_WIDTH] = layout.width;\n  data[PACKET_INDEX_HEIGHT] = layout.height;\n  data[PACKET_INDEX_OPTIONS] = layout._settings;\n\n  // Worker data items.\n  var i, j, item;\n  for (i = 0, j = PACKET_HEADER_SLOTS - 1, item; i < items.length; i++) {\n    item = items[i];\n    data[++j] = item._width + item._marginLeft + item._marginRight;\n    data[++j] = item._height + item._marginTop + item._marginBottom;\n  }\n\n  this._layoutQueue.push(layoutId);\n  this._layouts[layoutId] = layout;\n  this._layoutCallbacks[layoutId] = callback;\n  this._layoutWorkerData[layoutId] = data;\n\n  this._sendToWorker();\n\n  return this.cancelLayout.bind(this, layoutId);\n};\n\n/**\n * @public\n * @param {Number} layoutId\n */\nPacker.prototype.cancelLayout = function (layoutId) {\n  var layout = this._layouts[layoutId];\n  if (!layout) return;\n\n  delete this._layouts[layoutId];\n  delete this._layoutCallbacks[layoutId];\n\n  if (this._layoutWorkerData[layoutId]) {\n    delete this._layoutWorkerData[layoutId];\n    var queueIndex = this._layoutQueue.indexOf(layoutId);\n    if (queueIndex > -1) this._layoutQueue.splice(queueIndex, 1);\n  }\n};\n\n/**\n * @public\n */\nPacker.prototype.destroy = function () {\n  // Move all currently used workers back in the workers array.\n  for (var key in this._layoutWorkers) {\n    this._workers.push(this._layoutWorkers[key]);\n  }\n\n  // Destroy all instance's workers.\n  destroyWorkerProcessors(this._workers);\n\n  // Reset data.\n  this._workers.length = 0;\n  this._layoutQueue.length = 0;\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n};\n\nvar debounceId = 0;\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. The returned function accepts one argument which, when\n * being `true`, cancels the debounce function immediately. When the debounce\n * function is canceled it cannot be invoked again.\n *\n * @param {Function} fn\n * @param {Number} durationMs\n * @returns {Function}\n */\nfunction debounce(fn, durationMs) {\n  var id = ++debounceId;\n  var timer = 0;\n  var lastTime = 0;\n  var isCanceled = false;\n  var tick = function (time) {\n    if (isCanceled) return;\n\n    if (lastTime) timer -= time - lastTime;\n    lastTime = time;\n\n    if (timer > 0) {\n      addDebounceTick(id, tick);\n    } else {\n      timer = lastTime = 0;\n      fn();\n    }\n  };\n\n  return function (cancel) {\n    if (isCanceled) return;\n\n    if (durationMs <= 0) {\n      if (cancel !== true) fn();\n      return;\n    }\n\n    if (cancel === true) {\n      isCanceled = true;\n      timer = lastTime = 0;\n      tick = undefined;\n      cancelDebounceTick(id);\n      return;\n    }\n\n    if (timer <= 0) {\n      timer = durationMs;\n      tick(0);\n    } else {\n      timer = durationMs;\n    }\n  };\n}\n\nvar htmlCollectionType = '[object HTMLCollection]';\nvar nodeListType = '[object NodeList]';\n\n/**\n * Check if a value is a node list or a html collection.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isNodeList(val) {\n  var type = Object.prototype.toString.call(val);\n  return type === htmlCollectionType || type === nodeListType;\n}\n\nvar objectType = 'object';\nvar objectToStringType = '[object Object]';\nvar toString = Object.prototype.toString;\n\n/**\n * Check if a value is a plain object.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isPlainObject(val) {\n  return typeof val === objectType && toString.call(val) === objectToStringType;\n}\n\nfunction noop() {}\n\n/**\n * Converts a value to an array or clones an array.\n *\n * @param {*} val\n * @returns {Array}\n */\nfunction toArray(val) {\n  return isNodeList(val) ? Array.prototype.slice.call(val) : Array.prototype.concat(val);\n}\n\nvar NUMBER_TYPE = 'number';\nvar STRING_TYPE = 'string';\nvar INSTANT_LAYOUT = 'instant';\nvar layoutId = 0;\n\n/**\n * Creates a new Grid instance.\n *\n * @class\n * @param {(HTMLElement|String)} element\n * @param {Object} [options]\n * @param {(String|HTMLElement[]|NodeList|HTMLCollection)} [options.items=\"*\"]\n * @param {Number} [options.showDuration=300]\n * @param {String} [options.showEasing=\"ease\"]\n * @param {Object} [options.visibleStyles={opacity: \"1\", transform: \"scale(1)\"}]\n * @param {Number} [options.hideDuration=300]\n * @param {String} [options.hideEasing=\"ease\"]\n * @param {Object} [options.hiddenStyles={opacity: \"0\", transform: \"scale(0.5)\"}]\n * @param {(Function|Object)} [options.layout]\n * @param {Boolean} [options.layout.fillGaps=false]\n * @param {Boolean} [options.layout.horizontal=false]\n * @param {Boolean} [options.layout.alignRight=false]\n * @param {Boolean} [options.layout.alignBottom=false]\n * @param {Boolean} [options.layout.rounding=false]\n * @param {(Boolean|Number)} [options.layoutOnResize=150]\n * @param {Boolean} [options.layoutOnInit=true]\n * @param {Number} [options.layoutDuration=300]\n * @param {String} [options.layoutEasing=\"ease\"]\n * @param {?Object} [options.sortData=null]\n * @param {Boolean} [options.dragEnabled=false]\n * @param {?String} [options.dragHandle=null]\n * @param {?HtmlElement} [options.dragContainer=null]\n * @param {?Function} [options.dragStartPredicate]\n * @param {Number} [options.dragStartPredicate.distance=0]\n * @param {Number} [options.dragStartPredicate.delay=0]\n * @param {String} [options.dragAxis=\"xy\"]\n * @param {(Boolean|Function)} [options.dragSort=true]\n * @param {Object} [options.dragSortHeuristics]\n * @param {Number} [options.dragSortHeuristics.sortInterval=100]\n * @param {Number} [options.dragSortHeuristics.minDragDistance=10]\n * @param {Number} [options.dragSortHeuristics.minBounceBackAngle=1]\n * @param {(Function|Object)} [options.dragSortPredicate]\n * @param {Number} [options.dragSortPredicate.threshold=50]\n * @param {String} [options.dragSortPredicate.action=\"move\"]\n * @param {String} [options.dragSortPredicate.migrateAction=\"move\"]\n * @param {Object} [options.dragRelease]\n * @param {Number} [options.dragRelease.duration=300]\n * @param {String} [options.dragRelease.easing=\"ease\"]\n * @param {Boolean} [options.dragRelease.useDragContainer=true]\n * @param {Object} [options.dragCssProps]\n * @param {Object} [options.dragPlaceholder]\n * @param {Boolean} [options.dragPlaceholder.enabled=false]\n * @param {?Function} [options.dragPlaceholder.createElement=null]\n * @param {?Function} [options.dragPlaceholder.onCreate=null]\n * @param {?Function} [options.dragPlaceholder.onRemove=null]\n * @param {Object} [options.dragAutoScroll]\n * @param {(Function|Array)} [options.dragAutoScroll.targets=[]]\n * @param {?Function} [options.dragAutoScroll.handle=null]\n * @param {Number} [options.dragAutoScroll.threshold=50]\n * @param {Number} [options.dragAutoScroll.safeZone=0.2]\n * @param {(Function|Number)} [options.dragAutoScroll.speed]\n * @param {Boolean} [options.dragAutoScroll.sortDuringScroll=true]\n * @param {Boolean} [options.dragAutoScroll.smoothStop=false]\n * @param {?Function} [options.dragAutoScroll.onStart=null]\n * @param {?Function} [options.dragAutoScroll.onStop=null]\n * @param {String} [options.containerClass=\"muuri\"]\n * @param {String} [options.itemClass=\"muuri-item\"]\n * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\n * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\n * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\n * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\n * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\n * @param {String} [options.itemPlaceholderClass=\"muuri-item-placeholder\"]\n */\nfunction Grid(element, options) {\n  // Allow passing element as selector string\n  if (typeof element === STRING_TYPE) {\n    element = document.querySelector(element);\n  }\n\n  // Throw an error if the container element is not body element or does not\n  // exist within the body element.\n  var isElementInDom = element.getRootNode\n    ? element.getRootNode({ composed: true }) === document\n    : document.body.contains(element);\n  if (!isElementInDom || element === document.documentElement) {\n    throw new Error('Container element must be an existing DOM element.');\n  }\n\n  // Create instance settings by merging the options with default options.\n  var settings = mergeSettings(Grid.defaultOptions, options);\n  settings.visibleStyles = normalizeStyles(settings.visibleStyles);\n  settings.hiddenStyles = normalizeStyles(settings.hiddenStyles);\n  if (!isFunction(settings.dragSort)) {\n    settings.dragSort = !!settings.dragSort;\n  }\n\n  this._id = createUid();\n  this._element = element;\n  this._settings = settings;\n  this._isDestroyed = false;\n  this._items = [];\n  this._layout = {\n    id: 0,\n    items: [],\n    slots: [],\n  };\n  this._isLayoutFinished = true;\n  this._nextLayoutData = null;\n  this._emitter = new Emitter();\n  this._onLayoutDataReceived = this._onLayoutDataReceived.bind(this);\n\n  // Store grid instance to the grid instances collection.\n  GRID_INSTANCES[this._id] = this;\n\n  // Add container element's class name.\n  addClass(element, settings.containerClass);\n\n  // If layoutOnResize option is a valid number sanitize it and bind the resize\n  // handler.\n  bindLayoutOnResize(this, settings.layoutOnResize);\n\n  // Add initial items.\n  this.add(getInitialGridElements(element, settings.items), { layout: false });\n\n  // Layout on init if necessary.\n  if (settings.layoutOnInit) {\n    this.layout(true);\n  }\n}\n\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @see Item\n */\nGrid.Item = Item;\n\n/**\n * @public\n * @static\n * @see ItemLayout\n */\nGrid.ItemLayout = ItemLayout;\n\n/**\n * @public\n * @static\n * @see ItemVisibility\n */\nGrid.ItemVisibility = ItemVisibility;\n\n/**\n * @public\n * @static\n * @see ItemMigrate\n */\nGrid.ItemMigrate = ItemMigrate;\n\n/**\n * @public\n * @static\n * @see ItemDrag\n */\nGrid.ItemDrag = ItemDrag;\n\n/**\n * @public\n * @static\n * @see ItemDragRelease\n */\nGrid.ItemDragRelease = ItemDragRelease;\n\n/**\n * @public\n * @static\n * @see ItemDragPlaceholder\n */\nGrid.ItemDragPlaceholder = ItemDragPlaceholder;\n\n/**\n * @public\n * @static\n * @see Emitter\n */\nGrid.Emitter = Emitter;\n\n/**\n * @public\n * @static\n * @see Animator\n */\nGrid.Animator = Animator;\n\n/**\n * @public\n * @static\n * @see Dragger\n */\nGrid.Dragger = Dragger;\n\n/**\n * @public\n * @static\n * @see Packer\n */\nGrid.Packer = Packer;\n\n/**\n * @public\n * @static\n * @see AutoScroller\n */\nGrid.AutoScroller = AutoScroller;\n\n/**\n * The default Packer instance used by default for all layouts.\n *\n * @public\n * @static\n * @type {Packer}\n */\nGrid.defaultPacker = new Packer(2);\n\n/**\n * Default options for Grid instance.\n *\n * @public\n * @static\n * @type {Object}\n */\nGrid.defaultOptions = {\n  // Initial item elements\n  items: '*',\n\n  // Default show animation\n  showDuration: 300,\n  showEasing: 'ease',\n\n  // Default hide animation\n  hideDuration: 300,\n  hideEasing: 'ease',\n\n  // Item's visible/hidden state styles\n  visibleStyles: {\n    opacity: '1',\n    transform: 'scale(1)',\n  },\n  hiddenStyles: {\n    opacity: '0',\n    transform: 'scale(0.5)',\n  },\n\n  // Layout\n  layout: {\n    fillGaps: false,\n    horizontal: false,\n    alignRight: false,\n    alignBottom: false,\n    rounding: false,\n  },\n  layoutOnResize: 150,\n  layoutOnInit: true,\n  layoutDuration: 300,\n  layoutEasing: 'ease',\n\n  // Sorting\n  sortData: null,\n\n  // Drag & Drop\n  dragEnabled: false,\n  dragContainer: null,\n  dragHandle: null,\n  dragStartPredicate: {\n    distance: 0,\n    delay: 0,\n  },\n  dragAxis: 'xy',\n  dragSort: true,\n  dragSortHeuristics: {\n    sortInterval: 100,\n    minDragDistance: 10,\n    minBounceBackAngle: 1,\n  },\n  dragSortPredicate: {\n    threshold: 50,\n    action: ACTION_MOVE,\n    migrateAction: ACTION_MOVE,\n  },\n  dragRelease: {\n    duration: 300,\n    easing: 'ease',\n    useDragContainer: true,\n  },\n  dragCssProps: {\n    touchAction: 'none',\n    userSelect: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0, 0, 0, 0)',\n    touchCallout: 'none',\n    contentZooming: 'none',\n  },\n  dragPlaceholder: {\n    enabled: false,\n    createElement: null,\n    onCreate: null,\n    onRemove: null,\n  },\n  dragAutoScroll: {\n    targets: [],\n    handle: null,\n    threshold: 50,\n    safeZone: 0.2,\n    speed: AutoScroller.smoothSpeed(1000, 2000, 2500),\n    sortDuringScroll: true,\n    smoothStop: false,\n    onStart: null,\n    onStop: null,\n  },\n\n  // Classnames\n  containerClass: 'muuri',\n  itemClass: 'muuri-item',\n  itemVisibleClass: 'muuri-item-shown',\n  itemHiddenClass: 'muuri-item-hidden',\n  itemPositioningClass: 'muuri-item-positioning',\n  itemDraggingClass: 'muuri-item-dragging',\n  itemReleasingClass: 'muuri-item-releasing',\n  itemPlaceholderClass: 'muuri-item-placeholder',\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\nGrid.prototype.on = function (event, listener) {\n  this._emitter.on(event, listener);\n  return this;\n};\n\n/**\n * Unbind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\nGrid.prototype.off = function (event, listener) {\n  this._emitter.off(event, listener);\n  return this;\n};\n\n/**\n * Get the container element.\n *\n * @public\n * @returns {HTMLElement}\n */\nGrid.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Get instance's item by element or by index. Target can also be an Item\n * instance in which case the function returns the item if it exists within\n * related Grid instance. If nothing is found with the provided target, null\n * is returned.\n *\n * @private\n * @param {(HtmlElement|Number|Item)} [target]\n * @returns {?Item}\n */\nGrid.prototype.getItem = function (target) {\n  // If no target is specified or the instance is destroyed, return null.\n  if (this._isDestroyed || (!target && target !== 0)) {\n    return null;\n  }\n\n  // If target is number return the item in that index. If the number is lower\n  // than zero look for the item starting from the end of the items array. For\n  // example -1 for the last item, -2 for the second last item, etc.\n  if (typeof target === NUMBER_TYPE) {\n    return this._items[target > -1 ? target : this._items.length + target] || null;\n  }\n\n  // If the target is an instance of Item return it if it is attached to this\n  // Grid instance, otherwise return null.\n  if (target instanceof Item) {\n    return target._gridId === this._id ? target : null;\n  }\n\n  // In other cases let's assume that the target is an element, so let's try\n  // to find an item that matches the element and return it. If item is not\n  // found return null.\n  if (ITEM_ELEMENT_MAP) {\n    var item = ITEM_ELEMENT_MAP.get(target);\n    return item && item._gridId === this._id ? item : null;\n  } else {\n    for (var i = 0; i < this._items.length; i++) {\n      if (this._items[i]._element === target) {\n        return this._items[i];\n      }\n    }\n  }\n\n  return null;\n};\n\n/**\n * Get all items. Optionally you can provide specific targets (elements,\n * indices and item instances). All items that are not found are omitted from\n * the returned array.\n *\n * @public\n * @param {(HtmlElement|Number|Item|Array)} [targets]\n * @returns {Item[]}\n */\nGrid.prototype.getItems = function (targets) {\n  // Return all items immediately if no targets were provided or if the\n  // instance is destroyed.\n  if (this._isDestroyed || targets === undefined) {\n    return this._items.slice(0);\n  }\n\n  var items = [];\n  var i, item;\n\n  if (Array.isArray(targets) || isNodeList(targets)) {\n    for (i = 0; i < targets.length; i++) {\n      item = this.getItem(targets[i]);\n      if (item) items.push(item);\n    }\n  } else {\n    item = this.getItem(targets);\n    if (item) items.push(item);\n  }\n\n  return items;\n};\n\n/**\n * Update the cached dimensions of the instance's items. By default all the\n * items are refreshed, but you can also provide an array of target items as the\n * first argument if you want to refresh specific items. Note that all hidden\n * items are not refreshed by default since their \"display\" property is \"none\"\n * and their dimensions are therefore not readable from the DOM. However, if you\n * do want to force update hidden item dimensions too you can provide `true`\n * as the second argument, which makes the elements temporarily visible while\n * their dimensions are being read.\n *\n * @public\n * @param {Item[]} [items]\n * @param {Boolean} [force=false]\n * @returns {Grid}\n */\nGrid.prototype.refreshItems = function (items, force) {\n  if (this._isDestroyed) return this;\n\n  var targets = items || this._items;\n  var i, item, style, hiddenItemStyles;\n\n  if (force === true) {\n    hiddenItemStyles = [];\n    for (i = 0; i < targets.length; i++) {\n      item = targets[i];\n      if (!item.isVisible() && !item.isHiding()) {\n        style = item.getElement().style;\n        style.visibility = 'hidden';\n        style.display = '';\n        hiddenItemStyles.push(style);\n      }\n    }\n  }\n\n  for (i = 0; i < targets.length; i++) {\n    targets[i]._refreshDimensions(force);\n  }\n\n  if (force === true) {\n    for (i = 0; i < hiddenItemStyles.length; i++) {\n      style = hiddenItemStyles[i];\n      style.visibility = '';\n      style.display = 'none';\n    }\n    hiddenItemStyles.length = 0;\n  }\n\n  return this;\n};\n\n/**\n * Update the sort data of the instance's items. By default all the items are\n * refreshed, but you can also provide an array of target items if you want to\n * refresh specific items.\n *\n * @public\n * @param {Item[]} [items]\n * @returns {Grid}\n */\nGrid.prototype.refreshSortData = function (items) {\n  if (this._isDestroyed) return this;\n\n  var targets = items || this._items;\n  for (var i = 0; i < targets.length; i++) {\n    targets[i]._refreshSortData();\n  }\n\n  return this;\n};\n\n/**\n * Synchronize the item elements to match the order of the items in the DOM.\n * This comes handy if you need to keep the DOM structure matched with the\n * order of the items. Note that if an item's element is not currently a child\n * of the container element (if it is dragged for example) it is ignored and\n * left untouched.\n *\n * @public\n * @returns {Grid}\n */\nGrid.prototype.synchronize = function () {\n  if (this._isDestroyed) return this;\n\n  var items = this._items;\n  if (!items.length) return this;\n\n  var fragment;\n  var element;\n\n  for (var i = 0; i < items.length; i++) {\n    element = items[i]._element;\n    if (element.parentNode === this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  }\n\n  if (!fragment) return this;\n\n  this._element.appendChild(fragment);\n  this._emit(EVENT_SYNCHRONIZE);\n\n  return this;\n};\n\n/**\n * Calculate and apply item positions.\n *\n * @public\n * @param {Boolean} [instant=false]\n * @param {Function} [onFinish]\n * @returns {Grid}\n */\nGrid.prototype.layout = function (instant, onFinish) {\n  if (this._isDestroyed) return this;\n\n  // Cancel unfinished layout algorithm if possible.\n  var unfinishedLayout = this._nextLayoutData;\n  if (unfinishedLayout && isFunction(unfinishedLayout.cancel)) {\n    unfinishedLayout.cancel();\n  }\n\n  // Compute layout id (let's stay in Float32 range).\n  layoutId = (layoutId % MAX_SAFE_FLOAT32_INTEGER) + 1;\n  var nextLayoutId = layoutId;\n\n  // Store data for next layout.\n  this._nextLayoutData = {\n    id: nextLayoutId,\n    instant: instant,\n    onFinish: onFinish,\n    cancel: null,\n  };\n\n  // Collect layout items (all active grid items).\n  var items = this._items;\n  var layoutItems = [];\n  for (var i = 0; i < items.length; i++) {\n    if (items[i]._isActive) layoutItems.push(items[i]);\n  }\n\n  // Compute new layout.\n  this._refreshDimensions();\n  var gridWidth = this._width - this._borderLeft - this._borderRight;\n  var gridHeight = this._height - this._borderTop - this._borderBottom;\n  var layoutSettings = this._settings.layout;\n  var cancelLayout;\n  if (isFunction(layoutSettings)) {\n    cancelLayout = layoutSettings(\n      this,\n      nextLayoutId,\n      layoutItems,\n      gridWidth,\n      gridHeight,\n      this._onLayoutDataReceived\n    );\n  } else {\n    Grid.defaultPacker.setOptions(layoutSettings);\n    cancelLayout = Grid.defaultPacker.createLayout(\n      this,\n      nextLayoutId,\n      layoutItems,\n      gridWidth,\n      gridHeight,\n      this._onLayoutDataReceived\n    );\n  }\n\n  // Store layout cancel method if available.\n  if (\n    isFunction(cancelLayout) &&\n    this._nextLayoutData &&\n    this._nextLayoutData.id === nextLayoutId\n  ) {\n    this._nextLayoutData.cancel = cancelLayout;\n  }\n\n  return this;\n};\n\n/**\n * Add new items by providing the elements you wish to add to the instance and\n * optionally provide the index where you want the items to be inserted into.\n * All elements that are not already children of the container element will be\n * automatically appended to the container element. If an element has it's CSS\n * display property set to \"none\" it will be marked as inactive during the\n * initiation process. As long as the item is inactive it will not be part of\n * the layout, but it will retain it's index. You can activate items at any\n * point with grid.show() method. This method will automatically call\n * grid.layout() if one or more of the added elements are visible. If only\n * hidden items are added no layout will be called. All the new visible items\n * are positioned without animation during their first layout.\n *\n * @public\n * @param {(HTMLElement|HTMLElement[])} elements\n * @param {Object} [options]\n * @param {Number} [options.index=-1]\n * @param {Boolean} [options.active]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\nGrid.prototype.add = function (elements, options) {\n  if (this._isDestroyed || !elements) return [];\n\n  var newItems = toArray(elements);\n  if (!newItems.length) return newItems;\n\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var items = this._items;\n  var needsLayout = false;\n  var fragment;\n  var element;\n  var item;\n  var i;\n\n  // Collect all the elements that are not child of the grid element into a\n  // document fragment.\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n    if (element.parentNode !== this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  }\n\n  // If we have a fragment, let's append it to the grid element. We could just\n  // not do this and the `new Item()` instantiation would handle this for us,\n  // but this way we can add the elements into the DOM a bit faster.\n  if (fragment) {\n    this._element.appendChild(fragment);\n  }\n\n  // Map provided elements into new grid items.\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n    item = newItems[i] = new Item(this, element, opts.active);\n\n    // If the item to be added is active, we need to do a layout. Also, we\n    // need to mark the item with the skipNextAnimation flag to make it\n    // position instantly (without animation) during the next layout. Without\n    // the hack the item would animate to it's new position from the northwest\n    // corner of the grid, which feels a bit buggy (imho).\n    if (item._isActive) {\n      needsLayout = true;\n      item._layout._skipNextAnimation = true;\n    }\n  }\n\n  // Set up the items' initial dimensions and sort data. This needs to be done\n  // in a separate loop to avoid layout thrashing.\n  for (i = 0; i < newItems.length; i++) {\n    item = newItems[i];\n    item._refreshDimensions();\n    item._refreshSortData();\n  }\n\n  // Add the new items to the items collection to correct index.\n  arrayInsert(items, newItems, opts.index);\n\n  // Emit add event.\n  if (this._hasListeners(EVENT_ADD)) {\n    this._emit(EVENT_ADD, newItems.slice(0));\n  }\n\n  // If layout is needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n\n  return newItems;\n};\n\n/**\n * Remove items from the instance.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.removeElements=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\nGrid.prototype.remove = function (items, options) {\n  if (this._isDestroyed || !items.length) return [];\n\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var needsLayout = false;\n  var allItems = this.getItems();\n  var targetItems = [];\n  var indices = [];\n  var index;\n  var item;\n  var i;\n\n  // Remove the individual items.\n  for (i = 0; i < items.length; i++) {\n    item = items[i];\n    if (item._isDestroyed) continue;\n\n    index = this._items.indexOf(item);\n    if (index === -1) continue;\n\n    if (item._isActive) needsLayout = true;\n\n    targetItems.push(item);\n    indices.push(allItems.indexOf(item));\n    item._destroy(opts.removeElements);\n    this._items.splice(index, 1);\n  }\n\n  // Emit remove event.\n  if (this._hasListeners(EVENT_REMOVE)) {\n    this._emit(EVENT_REMOVE, targetItems.slice(0), indices);\n  }\n\n  // If layout is needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n\n  return targetItems;\n};\n\n/**\n * Show specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.show = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, true, options);\n  }\n  return this;\n};\n\n/**\n * Hide specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.hide = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, false, options);\n  }\n  return this;\n};\n\n/**\n * Filter items. Expects at least one argument, a predicate, which should be\n * either a function or a string. The predicate callback is executed for every\n * item in the instance. If the return value of the predicate is truthy the\n * item in question will be shown and otherwise hidden. The predicate callback\n * receives the item instance as it's argument. If the predicate is a string\n * it is considered to be a selector and it is checked against every item\n * element in the instance with the native element.matches() method. All the\n * matching items will be shown and others hidden.\n *\n * @public\n * @param {(Function|String)} predicate\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {FilterCallback} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.filter = function (predicate, options) {\n  if (this._isDestroyed || !this._items.length) return this;\n\n  var itemsToShow = [];\n  var itemsToHide = [];\n  var isPredicateString = typeof predicate === STRING_TYPE;\n  var isPredicateFn = isFunction(predicate);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var syncWithLayout = opts.syncWithLayout;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var onFinish = isFunction(opts.onFinish) ? opts.onFinish : null;\n  var tryFinishCounter = -1;\n  var tryFinish = noop;\n  var item;\n  var i;\n\n  // If we have onFinish callback, let's create proper tryFinish callback.\n  if (onFinish) {\n    tryFinish = function () {\n      ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));\n    };\n  }\n\n  // Check which items need to be shown and which hidden.\n  if (isPredicateFn || isPredicateString) {\n    for (i = 0; i < this._items.length; i++) {\n      item = this._items[i];\n      if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n        itemsToShow.push(item);\n      } else {\n        itemsToHide.push(item);\n      }\n    }\n  }\n\n  // Show items that need to be shown.\n  if (itemsToShow.length) {\n    this.show(itemsToShow, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false,\n    });\n  } else {\n    tryFinish();\n  }\n\n  // Hide items that need to be hidden.\n  if (itemsToHide.length) {\n    this.hide(itemsToHide, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false,\n    });\n  } else {\n    tryFinish();\n  }\n\n  // If there are any items to filter.\n  if (itemsToShow.length || itemsToHide.length) {\n    // Emit filter event.\n    if (this._hasListeners(EVENT_FILTER)) {\n      this._emit(EVENT_FILTER, itemsToShow.slice(0), itemsToHide.slice(0));\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sort items. There are three ways to sort the items. The first is simply by\n * providing a function as the comparer which works identically to native\n * array sort. Alternatively you can sort by the sort data you have provided\n * in the instance's options. Just provide the sort data key(s) as a string\n * (separated by space) and the items will be sorted based on the provided\n * sort data keys. Lastly you have the opportunity to provide a presorted\n * array of items which will be used to sync the internal items array in the\n * same order.\n *\n * @public\n * @param {(Function|String|Item[])} comparer\n * @param {Object} [options]\n * @param {Boolean} [options.descending=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.sort = (function () {\n  var sortComparer;\n  var isDescending;\n  var origItems;\n  var indexMap;\n\n  function defaultComparer(a, b) {\n    var result = 0;\n    var criteriaName;\n    var criteriaOrder;\n    var valA;\n    var valB;\n\n    // Loop through the list of sort criteria.\n    for (var i = 0; i < sortComparer.length; i++) {\n      // Get the criteria name, which should match an item's sort data key.\n      criteriaName = sortComparer[i][0];\n      criteriaOrder = sortComparer[i][1];\n\n      // Get items' cached sort values for the criteria. If the item has no sort\n      // data let's update the items sort data (this is a lazy load mechanism).\n      valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];\n      valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName];\n\n      // Sort the items in descending order if defined so explicitly. Otherwise\n      // sort items in ascending order.\n      if (criteriaOrder === 'desc' || (!criteriaOrder && isDescending)) {\n        result = valB < valA ? -1 : valB > valA ? 1 : 0;\n      } else {\n        result = valA < valB ? -1 : valA > valB ? 1 : 0;\n      }\n\n      // If we have -1 or 1 as the return value, let's return it immediately.\n      if (result) return result;\n    }\n\n    // If values are equal let's compare the item indices to make sure we\n    // have a stable sort. Note that this is not necessary in evergreen browsers\n    // because Array.sort() is nowadays stable. However, in order to guarantee\n    // same results in older browsers we need this.\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n    return result;\n  }\n\n  function customComparer(a, b) {\n    var result = isDescending ? -sortComparer(a, b) : sortComparer(a, b);\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n    return result;\n  }\n\n  return function (comparer, options) {\n    if (this._isDestroyed || this._items.length < 2) return this;\n\n    var items = this._items;\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n\n    // Setup parent scope data.\n    isDescending = !!opts.descending;\n    origItems = items.slice(0);\n    indexMap = null;\n\n    // If function is provided do a native array sort.\n    if (isFunction(comparer)) {\n      sortComparer = comparer;\n      items.sort(customComparer);\n    }\n    // Otherwise if we got a string, let's sort by the sort data as provided in\n    // the instance's options.\n    else if (typeof comparer === STRING_TYPE) {\n      sortComparer = comparer\n        .trim()\n        .split(' ')\n        .filter(function (val) {\n          return val;\n        })\n        .map(function (val) {\n          return val.split(':');\n        });\n      items.sort(defaultComparer);\n    }\n    // Otherwise if we got an array, let's assume it's a presorted array of the\n    // items and order the items based on it. Here we blindly trust that the\n    // presorted array consists of the same item instances as the current\n    // `gird._items` array.\n    else if (Array.isArray(comparer)) {\n      items.length = 0;\n      items.push.apply(items, comparer);\n    }\n    // Otherwise let's throw an error.\n    else {\n      sortComparer = isDescending = origItems = indexMap = null;\n      throw new Error('Invalid comparer argument provided.');\n    }\n\n    // Emit sort event.\n    if (this._hasListeners(EVENT_SORT)) {\n      this._emit(EVENT_SORT, items.slice(0), origItems);\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n\n    // Reset data (to avoid mem leaks).\n    sortComparer = isDescending = origItems = indexMap = null;\n\n    return this;\n  };\n})();\n\n/**\n * Move item to another index or in place of another item.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {String} [options.action=\"move\"]\n *   - Accepts either \"move\" or \"swap\".\n *   - \"move\" moves the item in place of the other item.\n *   - \"swap\" swaps the position of the items.\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.move = function (item, position, options) {\n  if (this._isDestroyed || this._items.length < 2) return this;\n\n  var items = this._items;\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var isSwap = opts.action === ACTION_SWAP;\n  var action = isSwap ? ACTION_SWAP : ACTION_MOVE;\n  var fromItem = this.getItem(item);\n  var toItem = this.getItem(position);\n  var fromIndex;\n  var toIndex;\n\n  // Make sure the items exist and are not the same.\n  if (fromItem && toItem && fromItem !== toItem) {\n    // Get the indices of the items.\n    fromIndex = items.indexOf(fromItem);\n    toIndex = items.indexOf(toItem);\n\n    // Do the move/swap.\n    if (isSwap) {\n      arraySwap(items, fromIndex, toIndex);\n    } else {\n      arrayMove(items, fromIndex, toIndex);\n    }\n\n    // Emit move event.\n    if (this._hasListeners(EVENT_MOVE)) {\n      this._emit(EVENT_MOVE, {\n        item: fromItem,\n        fromIndex: fromIndex,\n        toIndex: toIndex,\n        action: action,\n      });\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Send item to another Grid instance.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {Grid} targetGrid\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {HTMLElement} [options.appendTo=document.body]\n * @param {(Boolean|Function|String)} [options.layoutSender=true]\n * @param {(Boolean|Function|String)} [options.layoutReceiver=true]\n * @returns {Grid}\n */\nGrid.prototype.send = function (item, targetGrid, position, options) {\n  if (this._isDestroyed || targetGrid._isDestroyed || this === targetGrid) return this;\n\n  // Make sure we have a valid target item.\n  item = this.getItem(item);\n  if (!item) return this;\n\n  var opts = options || {};\n  var container = opts.appendTo || document.body;\n  var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n  var layoutReceiver = opts.layoutReceiver\n    ? opts.layoutReceiver\n    : opts.layoutReceiver === undefined;\n\n  // Start the migration process.\n  item._migrate.start(targetGrid, position, container);\n\n  // If migration was started successfully and the item is active, let's layout\n  // the grids.\n  if (item._migrate._isActive && item._isActive) {\n    if (layoutSender) {\n      this.layout(\n        layoutSender === INSTANT_LAYOUT,\n        isFunction(layoutSender) ? layoutSender : undefined\n      );\n    }\n    if (layoutReceiver) {\n      targetGrid.layout(\n        layoutReceiver === INSTANT_LAYOUT,\n        isFunction(layoutReceiver) ? layoutReceiver : undefined\n      );\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the instance.\n *\n * @public\n * @param {Boolean} [removeElements=false]\n * @returns {Grid}\n */\nGrid.prototype.destroy = function (removeElements) {\n  if (this._isDestroyed) return this;\n\n  var container = this._element;\n  var items = this._items.slice(0);\n  var layoutStyles = (this._layout && this._layout.styles) || {};\n  var i, prop;\n\n  // Unbind window resize event listener.\n  unbindLayoutOnResize(this);\n\n  // Destroy items.\n  for (i = 0; i < items.length; i++) items[i]._destroy(removeElements);\n  this._items.length = 0;\n\n  // Restore container.\n  removeClass(container, this._settings.containerClass);\n  for (prop in layoutStyles) container.style[prop] = '';\n\n  // Emit destroy event and unbind all events.\n  this._emit(EVENT_DESTROY);\n  this._emitter.destroy();\n\n  // Remove reference from the grid instances collection.\n  delete GRID_INSTANCES[this._id];\n\n  // Flag instance as destroyed.\n  this._isDestroyed = true;\n\n  return this;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Emit a grid event.\n *\n * @private\n * @param {String} event\n * @param {...*} [arg]\n */\nGrid.prototype._emit = function () {\n  if (this._isDestroyed) return;\n  this._emitter.emit.apply(this._emitter, arguments);\n};\n\n/**\n * Check if there are any events listeners for an event.\n *\n * @private\n * @param {String} event\n * @returns {Boolean}\n */\nGrid.prototype._hasListeners = function (event) {\n  if (this._isDestroyed) return false;\n  return this._emitter.countListeners(event) > 0;\n};\n\n/**\n * Update container's width, height and offsets.\n *\n * @private\n */\nGrid.prototype._updateBoundingRect = function () {\n  var element = this._element;\n  var rect = element.getBoundingClientRect();\n  this._width = rect.width;\n  this._height = rect.height;\n  this._left = rect.left;\n  this._top = rect.top;\n  this._right = rect.right;\n  this._bottom = rect.bottom;\n};\n\n/**\n * Update container's border sizes.\n *\n * @private\n * @param {Boolean} left\n * @param {Boolean} right\n * @param {Boolean} top\n * @param {Boolean} bottom\n */\nGrid.prototype._updateBorders = function (left, right, top, bottom) {\n  var element = this._element;\n  if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');\n  if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');\n  if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');\n  if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');\n};\n\n/**\n * Refresh all of container's internal dimensions and offsets.\n *\n * @private\n */\nGrid.prototype._refreshDimensions = function () {\n  this._updateBoundingRect();\n  this._updateBorders(1, 1, 1, 1);\n  this._boxSizing = getStyle(this._element, 'box-sizing');\n};\n\n/**\n * Calculate and apply item positions.\n *\n * @private\n * @param {Object} layout\n */\nGrid.prototype._onLayoutDataReceived = (function () {\n  var itemsToLayout = [];\n  return function (layout) {\n    if (this._isDestroyed || !this._nextLayoutData || this._nextLayoutData.id !== layout.id) return;\n\n    var grid = this;\n    var instant = this._nextLayoutData.instant;\n    var onFinish = this._nextLayoutData.onFinish;\n    var numItems = layout.items.length;\n    var counter = numItems;\n    var item;\n    var left;\n    var top;\n    var i;\n\n    // Reset next layout data.\n    this._nextLayoutData = null;\n\n    if (!this._isLayoutFinished && this._hasListeners(EVENT_LAYOUT_ABORT)) {\n      this._emit(EVENT_LAYOUT_ABORT, this._layout.items.slice(0));\n    }\n\n    // Update the layout reference.\n    this._layout = layout;\n\n    // Update the item positions and collect all items that need to be laid\n    // out. It is critical that we update the item position _before_ the\n    // layoutStart event as the new data might be needed in the callback.\n    itemsToLayout.length = 0;\n    for (i = 0; i < numItems; i++) {\n      item = layout.items[i];\n\n      // Make sure we have a matching item.\n      if (!item) {\n        --counter;\n        continue;\n      }\n\n      // Get the item's new left and top values.\n      left = layout.slots[i * 2];\n      top = layout.slots[i * 2 + 1];\n\n      // Let's skip the layout process if we can. Possibly avoids a lot of DOM\n      // operations which saves us some CPU cycles.\n      if (item._canSkipLayout(left, top)) {\n        --counter;\n        continue;\n      }\n\n      // Update the item's position.\n      item._left = left;\n      item._top = top;\n\n      // Only active non-dragged items need to be moved.\n      if (item.isActive() && !item.isDragging()) {\n        itemsToLayout.push(item);\n      } else {\n        --counter;\n      }\n    }\n\n    // Set layout styles to the grid element.\n    if (layout.styles) {\n      setStyles(this._element, layout.styles);\n    }\n\n    // layoutStart event is intentionally emitted after the container element's\n    // dimensions are set, because otherwise there would be no hook for reacting\n    // to container dimension changes.\n    if (this._hasListeners(EVENT_LAYOUT_START)) {\n      this._emit(EVENT_LAYOUT_START, layout.items.slice(0), instant === true);\n      // Let's make sure that the current layout process has not been overridden\n      // in the layoutStart event, and if so, let's stop processing the aborted\n      // layout.\n      if (this._layout.id !== layout.id) return;\n    }\n\n    var tryFinish = function () {\n      if (--counter > 0) return;\n\n      var hasLayoutChanged = grid._layout.id !== layout.id;\n      var callback = isFunction(instant) ? instant : onFinish;\n\n      if (!hasLayoutChanged) {\n        grid._isLayoutFinished = true;\n      }\n\n      if (isFunction(callback)) {\n        callback(layout.items.slice(0), hasLayoutChanged);\n      }\n\n      if (!hasLayoutChanged && grid._hasListeners(EVENT_LAYOUT_END)) {\n        grid._emit(EVENT_LAYOUT_END, layout.items.slice(0));\n      }\n    };\n\n    if (!itemsToLayout.length) {\n      tryFinish();\n      return this;\n    }\n\n    this._isLayoutFinished = false;\n\n    for (i = 0; i < itemsToLayout.length; i++) {\n      if (this._layout.id !== layout.id) break;\n      itemsToLayout[i]._layout.start(instant === true, tryFinish);\n    }\n\n    if (this._layout.id === layout.id) {\n      itemsToLayout.length = 0;\n    }\n\n    return this;\n  };\n})();\n\n/**\n * Show or hide Grid instance's items.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} toVisible\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n */\nGrid.prototype._setItemsVisibility = function (items, toVisible, options) {\n  var grid = this;\n  var targetItems = items.slice(0);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var callback = opts.onFinish;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var counter = targetItems.length;\n  var startEvent = toVisible ? EVENT_SHOW_START : EVENT_HIDE_START;\n  var endEvent = toVisible ? EVENT_SHOW_END : EVENT_HIDE_END;\n  var method = toVisible ? 'show' : 'hide';\n  var needsLayout = false;\n  var completedItems = [];\n  var hiddenItems = [];\n  var item;\n  var i;\n\n  // If there are no items call the callback, but don't emit any events.\n  if (!counter) {\n    if (isFunction(callback)) callback(targetItems);\n    return;\n  }\n\n  // Prepare the items.\n  for (i = 0; i < targetItems.length; i++) {\n    item = targetItems[i];\n\n    // If inactive item is shown or active item is hidden we need to do\n    // layout.\n    if ((toVisible && !item._isActive) || (!toVisible && item._isActive)) {\n      needsLayout = true;\n    }\n\n    // If inactive item is shown we also need to do a little hack to make the\n    // item not animate it's next positioning (layout).\n    item._layout._skipNextAnimation = !!(toVisible && !item._isActive);\n\n    // If a hidden item is being shown we need to refresh the item's\n    // dimensions.\n    if (toVisible && item._visibility._isHidden) {\n      hiddenItems.push(item);\n    }\n\n    // Add item to layout or remove it from layout.\n    if (toVisible) {\n      item._addToLayout();\n    } else {\n      item._removeFromLayout();\n    }\n  }\n\n  // Force refresh the dimensions of all hidden items.\n  if (hiddenItems.length) {\n    this.refreshItems(hiddenItems, true);\n    hiddenItems.length = 0;\n  }\n\n  // Show the items in sync with the next layout.\n  function triggerVisibilityChange() {\n    if (needsLayout && opts.syncWithLayout !== false) {\n      grid.off(EVENT_LAYOUT_START, triggerVisibilityChange);\n    }\n\n    if (grid._hasListeners(startEvent)) {\n      grid._emit(startEvent, targetItems.slice(0));\n    }\n\n    for (i = 0; i < targetItems.length; i++) {\n      // Make sure the item is still in the original grid. There is a chance\n      // that the item starts migrating before tiggerVisibilityChange is called.\n      if (targetItems[i]._gridId !== grid._id) {\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n        continue;\n      }\n\n      targetItems[i]._visibility[method](isInstant, function (interrupted, item) {\n        // If the current item's animation was not interrupted add it to the\n        // completedItems array.\n        if (!interrupted) completedItems.push(item);\n\n        // If all items have finished their animations call the callback\n        // and emit showEnd/hideEnd event.\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n      });\n    }\n  }\n\n  // Trigger the visibility change, either async with layout or instantly.\n  if (needsLayout && opts.syncWithLayout !== false) {\n    this.on(EVENT_LAYOUT_START, triggerVisibilityChange);\n  } else {\n    triggerVisibilityChange();\n  }\n\n  // Trigger layout if needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n};\n\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Merge default settings with user settings. The returned object is a new\n * object with merged values. The merging is a deep merge meaning that all\n * objects and arrays within the provided settings objects will be also merged\n * so that modifying the values of the settings object will have no effect on\n * the returned object.\n *\n * @param {Object} defaultSettings\n * @param {Object} [userSettings]\n * @returns {Object} Returns a new object.\n */\nfunction mergeSettings(defaultSettings, userSettings) {\n  // Create a fresh copy of default settings.\n  var settings = mergeObjects({}, defaultSettings);\n\n  // Merge user settings to default settings.\n  if (userSettings) {\n    settings = mergeObjects(settings, userSettings);\n  }\n\n  // Handle visible/hidden styles manually so that the whole object is\n  // overridden instead of the props.\n\n  if (userSettings && userSettings.visibleStyles) {\n    settings.visibleStyles = userSettings.visibleStyles;\n  } else if (defaultSettings && defaultSettings.visibleStyles) {\n    settings.visibleStyles = defaultSettings.visibleStyles;\n  }\n\n  if (userSettings && userSettings.hiddenStyles) {\n    settings.hiddenStyles = userSettings.hiddenStyles;\n  } else if (defaultSettings && defaultSettings.hiddenStyles) {\n    settings.hiddenStyles = defaultSettings.hiddenStyles;\n  }\n\n  return settings;\n}\n\n/**\n * Merge two objects recursively (deep merge). The source object's properties\n * are merged to the target object.\n *\n * @param {Object} target\n *   - The target object.\n * @param {Object} source\n *   - The source object.\n * @returns {Object} Returns the target object.\n */\nfunction mergeObjects(target, source) {\n  var sourceKeys = Object.keys(source);\n  var length = sourceKeys.length;\n  var isSourceObject;\n  var propName;\n  var i;\n\n  for (i = 0; i < length; i++) {\n    propName = sourceKeys[i];\n    isSourceObject = isPlainObject(source[propName]);\n\n    // If target and source values are both objects, merge the objects and\n    // assign the merged value to the target property.\n    if (isPlainObject(target[propName]) && isSourceObject) {\n      target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);\n      continue;\n    }\n\n    // If source's value is object and target's is not let's clone the object as\n    // the target's value.\n    if (isSourceObject) {\n      target[propName] = mergeObjects({}, source[propName]);\n      continue;\n    }\n\n    // If source's value is an array let's clone the array as the target's\n    // value.\n    if (Array.isArray(source[propName])) {\n      target[propName] = source[propName].slice(0);\n      continue;\n    }\n\n    // In all other cases let's just directly assign the source's value as the\n    // target's value.\n    target[propName] = source[propName];\n  }\n\n  return target;\n}\n\n/**\n * Collect and return initial items for grid.\n *\n * @param {HTMLElement} gridElement\n * @param {?(HTMLElement[]|NodeList|HtmlCollection|String)} elements\n * @returns {(HTMLElement[]|NodeList|HtmlCollection)}\n */\nfunction getInitialGridElements(gridElement, elements) {\n  // If we have a wildcard selector let's return all the children.\n  if (elements === '*') {\n    return gridElement.children;\n  }\n\n  // If we have some more specific selector, let's filter the elements.\n  if (typeof elements === STRING_TYPE) {\n    var result = [];\n    var children = gridElement.children;\n    for (var i = 0; i < children.length; i++) {\n      if (elementMatches(children[i], elements)) {\n        result.push(children[i]);\n      }\n    }\n    return result;\n  }\n\n  // If we have an array of elements or a node list.\n  if (Array.isArray(elements) || isNodeList(elements)) {\n    return elements;\n  }\n\n  // Otherwise just return an empty array.\n  return [];\n}\n\n/**\n * Bind grid's resize handler to window.\n *\n * @param {Grid} grid\n * @param {(Number|Boolean)} delay\n */\nfunction bindLayoutOnResize(grid, delay) {\n  if (typeof delay !== NUMBER_TYPE) {\n    delay = delay === true ? 0 : -1;\n  }\n\n  if (delay >= 0) {\n    grid._resizeHandler = debounce(function () {\n      grid.refreshItems().layout();\n    }, delay);\n\n    window.addEventListener('resize', grid._resizeHandler);\n  }\n}\n\n/**\n * Unbind grid's resize handler from window.\n *\n * @param {Grid} grid\n */\nfunction unbindLayoutOnResize(grid) {\n  if (grid._resizeHandler) {\n    grid._resizeHandler(true);\n    window.removeEventListener('resize', grid._resizeHandler);\n    grid._resizeHandler = null;\n  }\n}\n\n/**\n * Normalize style declaration object, returns a normalized (new) styles object\n * (prefixed properties and invalid properties removed).\n *\n * @param {Object} styles\n * @returns {Object}\n */\nfunction normalizeStyles(styles) {\n  var normalized = {};\n  var docElemStyle = document.documentElement.style;\n  var prop, prefixedProp;\n\n  // Normalize visible styles (prefix and remove invalid).\n  for (prop in styles) {\n    if (!styles[prop]) continue;\n    prefixedProp = getPrefixedPropName(docElemStyle, prop);\n    if (!prefixedProp) continue;\n    normalized[prefixedProp] = styles[prop];\n  }\n\n  return normalized;\n}\n\n/**\n * Create index map from items.\n *\n * @param {Item[]} items\n * @returns {Object}\n */\nfunction createIndexMap(items) {\n  var result = {};\n  for (var i = 0; i < items.length; i++) {\n    result[items[i]._id] = i;\n  }\n  return result;\n}\n\n/**\n * Sort comparer function for items' index map.\n *\n * @param {Object} indexMap\n * @param {Item} itemA\n * @param {Item} itemB\n * @returns {Number}\n */\nfunction compareIndexMap(indexMap, itemA, itemB) {\n  var indexA = indexMap[itemA._id];\n  var indexB = indexMap[itemB._id];\n  return indexA - indexB;\n}\n\nexport default Grid;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}